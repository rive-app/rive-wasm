(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["rive"] = factory();
	else
		root["rive"] = factory();
})(this, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

var Rive = (function() {
  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
  if (typeof __filename !== 'undefined') _scriptDir = _scriptDir || __filename;
  return (
function(Rive) {
  Rive = Rive || {};

null;

var Module = typeof Rive !== "undefined" ? Rive : {};

var readyPromiseResolve, readyPromiseReject;

Module["ready"] = new Promise(function(resolve, reject) {
 readyPromiseResolve = resolve;
 readyPromiseReject = reject;
});

var moduleOverrides = {};

var key;

for (key in Module) {
 if (Module.hasOwnProperty(key)) {
  moduleOverrides[key] = Module[key];
 }
}

var arguments_ = [];

var thisProgram = "./this.program";

var quit_ = function(status, toThrow) {
 throw toThrow;
};

var ENVIRONMENT_IS_WEB = false;

var ENVIRONMENT_IS_WORKER = false;

var ENVIRONMENT_IS_NODE = false;

var ENVIRONMENT_IS_SHELL = false;

ENVIRONMENT_IS_WEB = typeof window === "object";

ENVIRONMENT_IS_WORKER = typeof importScripts === "function";

ENVIRONMENT_IS_NODE = typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node === "string";

ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;

var scriptDirectory = "";

function locateFile(path) {
 if (Module["locateFile"]) {
  return Module["locateFile"](path, scriptDirectory);
 }
 return scriptDirectory + path;
}

var read_, readAsync, readBinary, setWindowTitle;

var nodeFS;

var nodePath;

if (ENVIRONMENT_IS_NODE) {
 if (ENVIRONMENT_IS_WORKER) {
  scriptDirectory = require("path").dirname(scriptDirectory) + "/";
 } else {
  scriptDirectory = __dirname + "/";
 }
 read_ = function shell_read(filename, binary) {
  var ret = tryParseAsDataURI(filename);
  if (ret) {
   return binary ? ret : ret.toString();
  }
  if (!nodeFS) nodeFS = require("fs");
  if (!nodePath) nodePath = require("path");
  filename = nodePath["normalize"](filename);
  return nodeFS["readFileSync"](filename, binary ? null : "utf8");
 };
 readBinary = function readBinary(filename) {
  var ret = read_(filename, true);
  if (!ret.buffer) {
   ret = new Uint8Array(ret);
  }
  assert(ret.buffer);
  return ret;
 };
 if (process["argv"].length > 1) {
  thisProgram = process["argv"][1].replace(/\\/g, "/");
 }
 arguments_ = process["argv"].slice(2);
 process["on"]("uncaughtException", function(ex) {
  if (!(ex instanceof ExitStatus)) {
   throw ex;
  }
 });
 process["on"]("unhandledRejection", abort);
 quit_ = function(status) {
  process["exit"](status);
 };
 Module["inspect"] = function() {
  return "[Emscripten Module object]";
 };
} else if (ENVIRONMENT_IS_SHELL) {
 if (typeof read != "undefined") {
  read_ = function shell_read(f) {
   var data = tryParseAsDataURI(f);
   if (data) {
    return intArrayToString(data);
   }
   return read(f);
  };
 }
 readBinary = function readBinary(f) {
  var data;
  data = tryParseAsDataURI(f);
  if (data) {
   return data;
  }
  if (typeof readbuffer === "function") {
   return new Uint8Array(readbuffer(f));
  }
  data = read(f, "binary");
  assert(typeof data === "object");
  return data;
 };
 if (typeof scriptArgs != "undefined") {
  arguments_ = scriptArgs;
 } else if (typeof arguments != "undefined") {
  arguments_ = arguments;
 }
 if (typeof quit === "function") {
  quit_ = function(status) {
   quit(status);
  };
 }
 if (typeof print !== "undefined") {
  if (typeof console === "undefined") console = {};
  console.log = print;
  console.warn = console.error = typeof printErr !== "undefined" ? printErr : print;
 }
} else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
 if (ENVIRONMENT_IS_WORKER) {
  scriptDirectory = self.location.href;
 } else if (typeof document !== "undefined" && document.currentScript) {
  scriptDirectory = document.currentScript.src;
 }
 if (_scriptDir) {
  scriptDirectory = _scriptDir;
 }
 if (scriptDirectory.indexOf("blob:") !== 0) {
  scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1);
 } else {
  scriptDirectory = "";
 }
 {
  read_ = function(url) {
   try {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", url, false);
    xhr.send(null);
    return xhr.responseText;
   } catch (err) {
    var data = tryParseAsDataURI(url);
    if (data) {
     return intArrayToString(data);
    }
    throw err;
   }
  };
  if (ENVIRONMENT_IS_WORKER) {
   readBinary = function(url) {
    try {
     var xhr = new XMLHttpRequest();
     xhr.open("GET", url, false);
     xhr.responseType = "arraybuffer";
     xhr.send(null);
     return new Uint8Array(xhr.response);
    } catch (err) {
     var data = tryParseAsDataURI(url);
     if (data) {
      return data;
     }
     throw err;
    }
   };
  }
  readAsync = function(url, onload, onerror) {
   var xhr = new XMLHttpRequest();
   xhr.open("GET", url, true);
   xhr.responseType = "arraybuffer";
   xhr.onload = function() {
    if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
     onload(xhr.response);
     return;
    }
    var data = tryParseAsDataURI(url);
    if (data) {
     onload(data.buffer);
     return;
    }
    onerror();
   };
   xhr.onerror = onerror;
   xhr.send(null);
  };
 }
 setWindowTitle = function(title) {
  document.title = title;
 };
} else {}

var out = Module["print"] || console.log.bind(console);

var err = Module["printErr"] || console.warn.bind(console);

for (key in moduleOverrides) {
 if (moduleOverrides.hasOwnProperty(key)) {
  Module[key] = moduleOverrides[key];
 }
}

moduleOverrides = null;

if (Module["arguments"]) arguments_ = Module["arguments"];

if (Module["thisProgram"]) thisProgram = Module["thisProgram"];

if (Module["quit"]) quit_ = Module["quit"];

var tempRet0 = 0;

var setTempRet0 = function(value) {
 tempRet0 = value;
};

var wasmBinary;

if (Module["wasmBinary"]) wasmBinary = Module["wasmBinary"];

var noExitRuntime = Module["noExitRuntime"] || true;

if (typeof WebAssembly !== "object") {
 abort("no native wasm support detected");
}

var wasmMemory;

var ABORT = false;

var EXITSTATUS;

function assert(condition, text) {
 if (!condition) {
  abort("Assertion failed: " + text);
 }
}

var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : undefined;

function UTF8ArrayToString(heap, idx, maxBytesToRead) {
 var endIdx = idx + maxBytesToRead;
 var endPtr = idx;
 while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;
 if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
  return UTF8Decoder.decode(heap.subarray(idx, endPtr));
 } else {
  var str = "";
  while (idx < endPtr) {
   var u0 = heap[idx++];
   if (!(u0 & 128)) {
    str += String.fromCharCode(u0);
    continue;
   }
   var u1 = heap[idx++] & 63;
   if ((u0 & 224) == 192) {
    str += String.fromCharCode((u0 & 31) << 6 | u1);
    continue;
   }
   var u2 = heap[idx++] & 63;
   if ((u0 & 240) == 224) {
    u0 = (u0 & 15) << 12 | u1 << 6 | u2;
   } else {
    u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63;
   }
   if (u0 < 65536) {
    str += String.fromCharCode(u0);
   } else {
    var ch = u0 - 65536;
    str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
   }
  }
 }
 return str;
}

function UTF8ToString(ptr, maxBytesToRead) {
 return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
}

function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
 if (!(maxBytesToWrite > 0)) return 0;
 var startIdx = outIdx;
 var endIdx = outIdx + maxBytesToWrite - 1;
 for (var i = 0; i < str.length; ++i) {
  var u = str.charCodeAt(i);
  if (u >= 55296 && u <= 57343) {
   var u1 = str.charCodeAt(++i);
   u = 65536 + ((u & 1023) << 10) | u1 & 1023;
  }
  if (u <= 127) {
   if (outIdx >= endIdx) break;
   heap[outIdx++] = u;
  } else if (u <= 2047) {
   if (outIdx + 1 >= endIdx) break;
   heap[outIdx++] = 192 | u >> 6;
   heap[outIdx++] = 128 | u & 63;
  } else if (u <= 65535) {
   if (outIdx + 2 >= endIdx) break;
   heap[outIdx++] = 224 | u >> 12;
   heap[outIdx++] = 128 | u >> 6 & 63;
   heap[outIdx++] = 128 | u & 63;
  } else {
   if (outIdx + 3 >= endIdx) break;
   heap[outIdx++] = 240 | u >> 18;
   heap[outIdx++] = 128 | u >> 12 & 63;
   heap[outIdx++] = 128 | u >> 6 & 63;
   heap[outIdx++] = 128 | u & 63;
  }
 }
 heap[outIdx] = 0;
 return outIdx - startIdx;
}

function stringToUTF8(str, outPtr, maxBytesToWrite) {
 return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
}

function lengthBytesUTF8(str) {
 var len = 0;
 for (var i = 0; i < str.length; ++i) {
  var u = str.charCodeAt(i);
  if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
  if (u <= 127) ++len; else if (u <= 2047) len += 2; else if (u <= 65535) len += 3; else len += 4;
 }
 return len;
}

var UTF16Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le") : undefined;

function UTF16ToString(ptr, maxBytesToRead) {
 var endPtr = ptr;
 var idx = endPtr >> 1;
 var maxIdx = idx + maxBytesToRead / 2;
 while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;
 endPtr = idx << 1;
 if (endPtr - ptr > 32 && UTF16Decoder) {
  return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
 } else {
  var str = "";
  for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {
   var codeUnit = HEAP16[ptr + i * 2 >> 1];
   if (codeUnit == 0) break;
   str += String.fromCharCode(codeUnit);
  }
  return str;
 }
}

function stringToUTF16(str, outPtr, maxBytesToWrite) {
 if (maxBytesToWrite === undefined) {
  maxBytesToWrite = 2147483647;
 }
 if (maxBytesToWrite < 2) return 0;
 maxBytesToWrite -= 2;
 var startPtr = outPtr;
 var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;
 for (var i = 0; i < numCharsToWrite; ++i) {
  var codeUnit = str.charCodeAt(i);
  HEAP16[outPtr >> 1] = codeUnit;
  outPtr += 2;
 }
 HEAP16[outPtr >> 1] = 0;
 return outPtr - startPtr;
}

function lengthBytesUTF16(str) {
 return str.length * 2;
}

function UTF32ToString(ptr, maxBytesToRead) {
 var i = 0;
 var str = "";
 while (!(i >= maxBytesToRead / 4)) {
  var utf32 = HEAP32[ptr + i * 4 >> 2];
  if (utf32 == 0) break;
  ++i;
  if (utf32 >= 65536) {
   var ch = utf32 - 65536;
   str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
  } else {
   str += String.fromCharCode(utf32);
  }
 }
 return str;
}

function stringToUTF32(str, outPtr, maxBytesToWrite) {
 if (maxBytesToWrite === undefined) {
  maxBytesToWrite = 2147483647;
 }
 if (maxBytesToWrite < 4) return 0;
 var startPtr = outPtr;
 var endPtr = startPtr + maxBytesToWrite - 4;
 for (var i = 0; i < str.length; ++i) {
  var codeUnit = str.charCodeAt(i);
  if (codeUnit >= 55296 && codeUnit <= 57343) {
   var trailSurrogate = str.charCodeAt(++i);
   codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;
  }
  HEAP32[outPtr >> 2] = codeUnit;
  outPtr += 4;
  if (outPtr + 4 > endPtr) break;
 }
 HEAP32[outPtr >> 2] = 0;
 return outPtr - startPtr;
}

function lengthBytesUTF32(str) {
 var len = 0;
 for (var i = 0; i < str.length; ++i) {
  var codeUnit = str.charCodeAt(i);
  if (codeUnit >= 55296 && codeUnit <= 57343) ++i;
  len += 4;
 }
 return len;
}

function alignUp(x, multiple) {
 if (x % multiple > 0) {
  x += multiple - x % multiple;
 }
 return x;
}

var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;

function updateGlobalBufferAndViews(buf) {
 buffer = buf;
 Module["HEAP8"] = HEAP8 = new Int8Array(buf);
 Module["HEAP16"] = HEAP16 = new Int16Array(buf);
 Module["HEAP32"] = HEAP32 = new Int32Array(buf);
 Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
 Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
 Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
 Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
 Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
}

var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;

var wasmTable;

var __ATPRERUN__ = [];

var __ATINIT__ = [];

var __ATMAIN__ = [];

var __ATPOSTRUN__ = [];

var runtimeInitialized = false;

function preRun() {
 if (Module["preRun"]) {
  if (typeof Module["preRun"] == "function") Module["preRun"] = [ Module["preRun"] ];
  while (Module["preRun"].length) {
   addOnPreRun(Module["preRun"].shift());
  }
 }
 callRuntimeCallbacks(__ATPRERUN__);
}

function initRuntime() {
 runtimeInitialized = true;
 callRuntimeCallbacks(__ATINIT__);
}

function preMain() {
 callRuntimeCallbacks(__ATMAIN__);
}

function postRun() {
 if (Module["postRun"]) {
  if (typeof Module["postRun"] == "function") Module["postRun"] = [ Module["postRun"] ];
  while (Module["postRun"].length) {
   addOnPostRun(Module["postRun"].shift());
  }
 }
 callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
 __ATPRERUN__.unshift(cb);
}

function addOnInit(cb) {
 __ATINIT__.unshift(cb);
}

function addOnPostRun(cb) {
 __ATPOSTRUN__.unshift(cb);
}

var runDependencies = 0;

var runDependencyWatcher = null;

var dependenciesFulfilled = null;

function addRunDependency(id) {
 runDependencies++;
 if (Module["monitorRunDependencies"]) {
  Module["monitorRunDependencies"](runDependencies);
 }
}

function removeRunDependency(id) {
 runDependencies--;
 if (Module["monitorRunDependencies"]) {
  Module["monitorRunDependencies"](runDependencies);
 }
 if (runDependencies == 0) {
  if (runDependencyWatcher !== null) {
   clearInterval(runDependencyWatcher);
   runDependencyWatcher = null;
  }
  if (dependenciesFulfilled) {
   var callback = dependenciesFulfilled;
   dependenciesFulfilled = null;
   callback();
  }
 }
}

Module["preloadedImages"] = {};

Module["preloadedAudios"] = {};

function abort(what) {
 if (Module["onAbort"]) {
  Module["onAbort"](what);
 }
 what += "";
 err(what);
 ABORT = true;
 EXITSTATUS = 1;
 what = "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
 var e = new WebAssembly.RuntimeError(what);
 readyPromiseReject(e);
 throw e;
}

function hasPrefix(str, prefix) {
 return String.prototype.startsWith ? str.startsWith(prefix) : str.indexOf(prefix) === 0;
}

var dataURIPrefix = "data:application/octet-stream;base64,";

function isDataURI(filename) {
 return hasPrefix(filename, dataURIPrefix);
}

var fileURIPrefix = "file://";

function isFileURI(filename) {
 return hasPrefix(filename, fileURIPrefix);
}

var wasmBinaryFile = "data:application/octet-stream;base64,AGFzbQEAAAAB1AM/YAF/AX9gAn9/AX9gAX8AYAJ/fwBgA39/fwF/YAN/f38AYAF/AX1gA399fQBgAn99AGAHf319fX19fQBgA39/fQBgBH9/f30AYAN/fX8AYAAAYAR/f39/AGAFf39/f38AYAR/f39/AX9gBX99fX19AGAGf39/f39/AGAAAX9gA39/fQF/YAZ/f399f30AYAR/f319AGABfQF9YAV/f39/fwF/YAJ/fQF/YAJ/fwF9YAN9fX0BfWAIf39/f39/f38AYAp/f39/f39/f39/AGACf3wBf2AGf3x/f39/AX9gA39+fwF+YAF8AX1gAnx/AXxgB39/f39/f38AYA1/f39/f39/f39/f39/AGAGf39/f31/AGAFf39/fX0AYAR/f31/AGAGf399fX9/AGAFf399fX0AYAZ/f319fX0AYAh/f319fX19fQBgBX99fX9/AGAHfX1/f39/fwBgAXwBf2AGf39/f39/AX9gB39/f39/f38Bf2AEf39/fQF/YAN/f3wBf2ADf319AX9gAn5/AX9gAn1/AX9gAX8BfmADf39/AX1gCH9/f399fX1/AX1gAn99AX1gAn19AX1gAX8BfGADf39/AXxgBX9/f39/AXxgAn1/AXwC5QEmAWEBYQAcAWEBYgAdAWEBYwAkAWEBZAABAWEBZQAOAWEBZgAcAWEBZwAFAWEBaAAPAWEBaQAjAWEBagAFAWEBawAOAWEBbAA8AWEBbQAFAWEBbgAEAWEBbwAQAWEBcAAFAWEBcQADAWEBcgASAWEBcwANAWEBdAABAWEBdQABAWEBdgAYAWEBdwACAWEBeAAAAWEBeQAAAWEBegADAWEBQQAPAWEBQgADAWEBQwACAWEBRAACAWEBRQAAAWEBRgACAWEBRwA9AWEBSAACAWEBSQAdAWEBSgASAWEBSwASAWEBTAAAA6gJpgkBAAIAAAABAgEAAjsABAIAAwAAAwABAgACADMBAgAAAA0FBQIBAwMBAAUBAQIAAAAPBAEEAQgICAIEAQIBAgMEAQMCAiEhCwIAAgMAAAICDQUDABoDAAMACwIANgAAAAIDAAAAAAAGBgACAAEAEwMCAAMAFxcEBBABBAADAAgBABMANAEKAAQEBAIBAgEAAwEFBQUCAAIAAgEEAAABEwICAhQDAQMABAUCAAMDAAEDAhACJQICAwMA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BHJrIgFBAXQgACABQRVqdkEBcXJBHGohAgsgAyACNgIcIAJBAnRB6MIBaiEBAkACQAJAQbzAASgCACIEQQEgAnQiB3FFBEBBvMABIAQgB3I2AgAgASADNgIAIAMgATYCGAwBCyAAQQBBGSACQQF2ayACQR9GG3QhAiABKAIAIQEDQCABIgQoAgRBeHEgAEYNAiACQR12IQEgAkEBdCECIAQgAUEEcWoiB0EQaigCACIBDQALIAcgAzYCECADIAQ2AhgLIAMgAzYCDCADIAM2AggMAQsgBCgCCCIAIAM2AgwgBCADNgIIIANBADYCGCADIAQ2AgwgAyAANgIIC0HYwAFB2MABKAIAQQFrIgBBfyAAGzYCAAsLVAICfwF9IwBBEGsiASQAAn0gACgCACAAKAIEIAFBDGoQ/QMiAkUEQCAAELsBQwAAAAAMAQsgACAAKAIAIAJqNgIAIAEqAgwLIQMgAUEQaiQAIAO7CwcAIABBDGoLKQEBfyACBEAgACEDA0AgAyABOgAAIANBAWohAyACQQFrIgINAAsLIAALBgAgABAwCwgAIAAQgQGnCzUBAX8jAEEQayICJAAgAiAAKAIANgIMIAAgASgCADYCACABIAJBDGooAgA2AgAgAkEQaiQACykBAX8jAEEQayIBJAAgASAAKQIANwMIIAFBCGoQOCEAIAFBEGokACAACxQBAX9BCBAnIgEgACkCADcDACABCwwAIAAgASkCADcCAAsJACAAEPEEIAALKAEBfyABIAFBAWsiAnFFBEAgACACcQ8LIAAgAU8EfyAAIAFwBSAACwsLACAAEEMaIAAQMAsHACAAQQRqCywBAX8gABC6AiAAKAIABEAgABCrBCAAECkaIAAoAgAhASAAEJIBGiABEDALCwQAIAALEgAgACACOAIEIAAgATgCACAACwsAIAAgATYCACAACwMAAAsaACAAQbjnADYCACAAQRhqED4gABCQAhogAAsLACAAQgA3AgAgAAsHACAAQRBqCwUAEBIACxMAIAAgARC9AiAAQQRqIAIQ6AELDAAgASACKAIANgIAC1UBAX8gACgCBCEBA0AgASAAKAIIRwRAIAAoAhAaIAAgACgCCEEEazYCCAwBCwsgACgCAARAIAAoAhAaIAAoAgAhASAAEDIoAgAgACgCAGsaIAEQMAsLWQECfyMAQRBrIgIkACACIAE2AgwgASAAEL4EIgNNBEAgABCSASIAIANBAXZJBEAgAiAAQQF0NgIIIAJBCGogAkEMahBYKAIAIQMLIAJBEGokACADDwsQdQALPQECfyMAQRBrIgMkACADIABBARC/ASECIAAQKSACKAIEIAEQSCACIAIoAgRBBGo2AgQgAhBoIANBEGokAAtQAQF/IAAQugIgABApIAAoAgAgACgCBCABQQRqIgIQ6gEgACACEDYgAEEEaiABQQhqEDYgABApIAEQMhA2IAEgASgCBDYCACAAIAAQLxDEAgsNACAAKAIAIAFBA3RqCxAAIAAoAgQgACgCAGtBA3ULGAAgAC0AAEEgcUUEQCABIAIgABDaAhoLCwsAIAAgARBaQQBHC1IBAX8jAEEQayICJAAgAiABOwEOIAIgACACQQ5qEMMENgIIIAIQpgE2AgBBACEAIAJBCGogAhDCBEUEQCACQQhqEHIoAgQhAAsgAkEQaiQAIAALSwECfyMAQRBrIgEkACABIAAQ/wQhACMAQRBrIgIkACACQQhqIAAoAgQQQSgCAEEBOgAAIAAoAghBAToAACACQRBqJAAgAUEQaiQAC3UBA38jAEEQayICJAAgAiAAEP8EIQAjAEEQayIDJAAgA0EIaiAAKAIEEEEoAgAtAABFBEACfwJAIAAoAggiAC0AACIBQQFHBH8gAUECcQ0BIABBAjoAAEEBBUEACwwBCwALIQELIANBEGokACACQRBqJAAgAQsoACAAQdTQACkCADcCECAAQczQACkCADcCCCAAQcTQACkCADcCACAACwkAIAAQPSgCAAttAQF/IwBBgAJrIgUkACAEQYDABHEgAiADTHJFBEAgBSABQf8BcSACIANrIgJBgAIgAkGAAkkiARsQMxogAUUEQANAIAAgBUGAAhBPIAJBgAJrIgJB/wFLDQALCyAAIAUgAhBPCyAFQYACaiQACw4AQdO+ASABIAIQCSAACyQBAn8jAEEQayICJAAgACABEMMCIQMgAkEQaiQAIAEgACADGwtQAQJ/IwBBEGsiAyQAAkACQAJAAkAgAUEEaw4CAAEDCyADIAIQyAEgAEEEaiADEMsCIAMQbwwBCyAAIAIQNTYCEAtBASEECyADQRBqJAAgBAsHACAAIAFxCyEAIAEgACoCNFwEQCAAIAE4AjQgACAAKAIAKAI8EQIACwshACABIAAqAjBcBEAgACABOAIwIAAgACgCACgCOBECAAsLGQAgACgCACABOAIAIAAgACgCAEEIajYCAAsJACAAKAIAEB0LugEBAn8jAEEQayIDJAACf0EAIAAvASwgARBaIAFGDQAaIABBLGogARDRASAAIAAvASwgACgCACgCMBEDACAAKAIoIgRBLGpBAhDRASAAKAIkIAQoAqQBSQRAIAQgACgCJDYCpAELQQEgAkUNABogAyAAQRhqIgAQKjYCCCADIAAQKzYCAAN/IANBCGogAxAsBH8gAygCCCgCACABQQEQXxogA0EIahAtDAEFQQELCwshACADQRBqJAAgAAtaAQJ/IAAgAUHIAGtBACABGyIDNgIoAkAgACADRg0AQQEhAiABIAAoAhAgASgCACgCABEBACIBRQ0AIAFBCyABKAIAKAIMEQEARQ0AIAAgATYCFEEAIQILIAILDwAgACAAKAIAKAJkEQIACwQAQQALFAAgAARAIAAgACgCACgCBBECAAsLKQEBfyMAQRBrIgIkACACIAE2AgwgAEGMAWogAkEMahC+AyACQRBqJAALMwEBfyACBEAgACEDA0AgAyABLQAAOgAAIANBAWohAyABQQFqIQEgAkEBayICDQALCyAACxgAIAAgASoCADgCACAAIAEqAgQ4AgQgAAsZACAAQQRqIAFBBGoQgQUgACABKAIQNgIQCw8AIAAoAgAgACgCBDYCBAsKACAAQagMNgIAC0sBAnwgACAAoiIBIACiIgIgASABoqIgAUSnRjuMh83GPqJEdOfK4vkAKr+goiACIAFEsvtuiRARgT+iRHesy1RVVcW/oKIgAKCgtgtPAQF8IAAgAKIiAESBXgz9///fv6JEAAAAAAAA8D+gIAAgAKIiAURCOgXhU1WlP6KgIAAgAaIgAERpUO7gQpP5PqJEJx4P6IfAVr+goqC2C1IBAn0gAUEAECYqAgAhBCACQQAQJioCACEFIABBABAmIAQgBSADlJI4AgAgAUEBECYqAgAhBCACQQEQJioCACEFIABBARAmIAQgBSADlJI4AgALDAAgABDsARogABAwCyEAIAAQ/AIgAEEANgI8IABB9Bw2AgAgAEHs4wA2AgAgAAsdAQF/IAAQgwEEQCAAKAIAIQEgABDBAhogARAwCwsoAQF/IwBBEGsiAiQAIAIgATYC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IQnARBgtRFT7IQlAIARBf0obIAGgmhBqIQAMAQsgA0HV44iHBE0EQCAAuyEBIANB39u/hQRNBEAgBEF/TARAIAFE0iEzf3zZEkCgEGshAAwDCyABRNIhM3982RLAoBBrjCEADAILRBgtRFT7IRnARBgtRFT7IRlAIARBf0obIAGgEGohAAwBCyADQYCAgPwHTwRAIAAgAJMhAAwBCwJAAkACQAJAIAAgAkEIahCKBUEDcQ4DAAECAwsgAisDCBBqIQAMAwsgAisDCBBrIQAMAgsgAisDCJoQaiEADAELIAIrAwgQa4whAAsgAkEQaiQAIAALVwECfyMAQRBrIgMkACAAKAIEIgRBAXUgAWohASAAKAIAIQAgBEEBcQRAIAEoAgAgAGooAgAhAAsgAyACEJoFIAEgAyAAEQEAIQAgAxBvIANBEGokACAACw4AQYS+ASABIAIQCSAAC5oBAQJ/IAEoAgAgACgCACADKAIAEQEAIQUgAigCACABKAIAIAMoAgARAQAhBAJ/AkAgBUUEQEEAIARFDQIaIAEgAhA2QQEgASgCACAAKAIAIAMoAgARAQBFDQIaIAAgARA2DAELIAQEQCAAIAIQNkEBDwsgACABEDZBASACKAIAIAEoAgAgAygCABEBAEUNARogASACEDYLQQILCw4AIAAgASgCADYCACAACwsAIAAgASACEMwBCwcAIABBAkcL5w0CC38JfSAAIAEQhQIgAUEIEFAEQCAAKAKIASEDIAAgACgCACgCaBEAACELIwBBkAFrIgIkACADIAMoAgAoAggRAgACQCAAQYwBaiIIEC8iCUECSQ0AAkAgCEEAEC4oAgAiABCzASIKBEAgAkFAayAAEN0BEGYiAUEAECYqAgAhESABQQEQJioCACESIAJBiAFqIAAQowIQZiIBQQAQJioCACENIAFBARAmKgIAIQ8gAkGAAWogABB8IAMgAkGAAWpBABAmKgIAIhMgAkGAAWpBARAmKgIAIhQgAygCACgCFBEHAAwBCyACIAJBQGsgABC8AyIEKgI8Ig04AjwCQCANQwAAAABeBEAgCCAJQQFrEC4oAgAhASACQYgBaiAEEHwgAkGAAWoQRCEAAkAgARCzAQRAIAJBMGogARCjAhBmGgwBCyACQTBqIAEQfAsgACACQTBqIAJBiAFqELYBIAIgABDeASINOAIsIABBABAmIgEgASoCACANlTgCACACKgIsIQ0gAEEBECYiASABKgIAIA2VOAIAIAhBARAuKAIAIQUgAkEwahBEIQECQCAFELMBBEAgAkEgaiAFEN0BEGYaDAELIAJBIGogBRB8CyABIAJBIGogAkGIAWoQtgEgAiABEN4BIg04AhwgAUEAECYiBSAFKgIAIA2VOAIAIAIqAhwhDSABQQEQJiIFIAUqAgAgDZU4AgAgAkEsaiACQRxqIAJBPGoQpAEQpAEqAgAhDSACQSBqEEQiBSACQYgBaiAAIA0QbCADIAVBABAmKgIAIhEgBUEBECYqAgAiEiADKAIAKAIUEQcAIAJBEGoQRCIFIAJBiAFqIAAgDUPuOuU+lCIPEGwgAkEIahBEIgAgAkGIAWogASAPEGwgAhBEIgcgAkGIAWogASANEGwgAyAFQQAQJioCACAFQQEQJioCACAAQQAQJioCACAAQQEQJioCACAHQQAQJioCACINIAdBARAmKgIAIg8gAygCACgCHBEJAAwBCyACQYgBaiAEEHwgAyACQYgBakEAECYqAgAiESACQYgBakEBECYqAgAiEiADKAIAKAIUEQcAIBIhDyARIQ0LIAQQQxogEiEUIBEhEwsgCUEBIAlBAUsbIQxBASEFIAohAAJAA0AgBSAMRgRAAkAgC0UNBCAAIApyQQFxRQ0AIAMgDSAPIBEgEiATIBQgAygCACgCHBEJAAwDCwUCQCAIIAUQLigCACIEELMBIgEEQCACQUBrIAQQ3QEQZiEAIAJBiAFqIAQQfCADIA0gDyAAQQAQJioCACAAQQEQJioCACACQYgBakEAECYqAgAgAkGIAWpBARAmKgIAIAMoAgAoAhwRCQAgAkGAAWogBBCjAhBmIgBBABAmKgIAIQ0gAEEBECYqAgAhDwwBCyACQUBrIAQQvAMaIAJBiAFqIAJBQGsQfCACIAJBQGsqAjwiDjgCPAJAIA5DAAAAAF4EQCACQYABahBEIgcgAkEwaiANIA8QQCACQYgBahC2ASACIAcQ3gEiDjgCLCAHQQAQJiIEIAQqAgAgDpU4AgAgAioCLCEOIAdBARAmIgQgBCoCACAOlTgCACAIIAVBAWogCXAQLigCACEGIAJBMGoQRCEEAkAgBhCzAQRAIAJBIGogBhDdARBmGgwBCyACQSBqIAYQfAsgBCACQSBqIAJBiAFqELYBIAIgBBDeASIOOAIcIARBABAmIgYgBioCACAOlTgCACACKgIcIQ4gBEEBECYiBiAGKgIAIA6VOAIAIAJBLGogAkEcaiACQTxqEKQBEKQBKgIAIQ4gAkEgahBEIgYgAkGIAWogByAOEGwgBkEAECYqAgAhECAGQQEQJioCACEVAkAgAEEBcQRAIAMgDSAPIBAgFSAGQQAQJioCACAGQQEQJioCACADKAIAKAIcEQkADAELIAMgECAVIAMoAgAoAhgRBwALIAJBEGoQRCIAIAJBiAFqIAcgDkPuOuU+lCINEGwgAkEIahBEIgcgAkGIAWogBCANEGwgAhBEIgYgAkGIAWogBCAOEGwgAyAAQQAQJioCACAAQQEQJioCACAHQQAQJioCACAHQQEQJioCACAGQQAQJioCACINIAZBARAmKgIAIg8gAygCACgCHBEJAAwBCyACQYgBakEAECYqAgAhDiACQYgBakEBECYqAgAhEAJAIABBAXEEQCADIA0gDyAOIBAgDiAQIAMoAgAoAhwRCQAMAQsgAyAOIBAgAygCACgCGBEHAAsgECEPIA4hDQsgAkFAaxBDGgsgBUEBaiEFIAEhAAwBCwsgAyATIBQgAygCACgCGBEHAAsgAyADKAIAKAIgEQIACyACQZABaiQACwsRACAAQT0gACgCACgCDBEBAAshACABIAAqAjxcBEAgACABOAI8IAAgACgCACgCRBECAAsLJAECfyMAQRBrIgIkACABIAAQsgQhAyACQRBqJAAgASAAIAMbCxIAIAAQKSgCACAAKAIAa0EobQslAQJ/IwBBEGsiACQAIABBCGoQkwEQQSgCACEBIABBEGokACABCyEAIAAQ5AQgAEH8JDYCACAAQfg9NgIAIABBBGoQOhogAAuDAQIDfwF+AkAgAEKAgICAEFQEQCAAIQUMAQsDQCABQQFrIgEgACAAQgqAIgVCCn59p0EwcjoAACAAQv////+fAVYhAiAFIQAgAg0ACwsgBaciAgRAA0AgAUEBayIBIAIgAkEKbiIDQQpsa0EwcjoAACACQQlLIQQgAyECIAQNAAsLIAELKQEBfyMAQRBrIgIkACACIAA2AgwgAkEMaiABKAIAEHcgAkEQaiQAIAALNwEBfyABIAAoAgQiA0EBdWohASAAKAIAIQAgASACIANBAXEEfyABKAIAIABqKAIABSAACxEIAAsoACAAEIACIABCADcCUCAAQagTNgIAIABCADcCWCAAQdTSADYCACAACzcAAkACQAJAIAFBGGsOAgABAgsgACACEDG2OAIwQQEPCyAAIAIQMbY4AjRBAQ8LIAAgASACEFkLMQEBfyMAQRBrIgMkACADIAE2AgwgACADQQxqENABIAAgAikCADcCBCADQRBqJAAgAAsSACAAIAI6AAQgACABNgIAIAALLgECfyAAKAIIIQEgABApGgNAIAEEQCABKAIAIQIgARAwIAIhAQwBCwsgABDdBQv7AQEDfyMAQRBrIgIkACABIAAtAAAQtQFBEBBaIQMgAiAAQQRqIgAQKjYCCCACIAAQKzYCACADQRBGIQRBACEAAn8DQCACQQhqIAIQLARAIAIoAggoAgAhAwJ/AkAgAQRAIAEgAyADKAIAKAJAEQAAEFogAUcNAQsgAxCOAgRAQQEgAygCSA0CGgtBASEECyAACyEAIAJBCGoQLQwBBSAAIARxBEBB7AAQJyIAEM0DIABB8NYANgIAIAAQwwE2AmggAAwDCwsLIABBAXEEQEHoABAnQQBB6AAQMyIAEM0DIABB4OEANgIAIAAMAQsQwwELIQAgAkEQaiQAIAALHAAgACgCFARAIAAoAhQiACAAKAIAKAJkEQIACwsYACABQf////8DSwRAEEYACyABQQJ0ECcLEQAgAEEkIAAoAgAoAgwRAQALogEBAn8gACgCBCAAECkoAgBJBEAjAEEQayIDJAAgAyAAQQEQmwIhAiAAECkgAigCBCABEJYCIAIgAigCBEEIajYCBCACEGggA0EQaiQADwsjAEEgayIDJAAgABApIgIgA0EIaiAAIAAQTkEBahCaAiAAEE4gAhCZAiICKAIIIAEQlgIgAiACKAIIQQhqNgIIIAAgAhDDAyACEJgCIANBIGokAAsHACAAIAFyC0wBAn0gAUEAECYqAgAhAyACQQAQJioCACEEIABBABAmIAMgBJM4AgAgAUEBECYqAgAhAyACQQEQJioCACEEIABBARAmIAMgBJM4AgALTAECfSABQQAQJioCACEDIAJBABAmKgIAIQQgAEEAECYgAyAEkjgCACABQQEQJioCACEDIAJBARAmKgIAIQQgAEEBECYgAyAEkjgCAAuGAgEMfSABQQAQJioCACEDIAFBARAmKgIAIQQgAUECECYqAgAhBSABQQMQJioCACEGIAFBBBAmKgIAIQ0gAUEFECYqAgAhDiACQQAQJioCACEHIAJBARAmKgIAIQggAkECECYqAgAhCSACQQMQJioCACEKIAJBBBAmKgIAIQsgAkEFECYqAgAhDCAAQQAQJiADIAeUIAUgCJSSOAIAIABBARAmIAQgB5QgBiAIlJI4AgAgAEECECYgAyAJlCAFIAqUkjgCACAAQQMQJiAEIAmUIAYgCpSSOAIAIABBBBAmIA0gAyALlCAFIAyUkpI4AgAgAEEFECYgDiAEIAuUIAYgDJSSkjgCAAsJACAAQQA6AAALTgECfyMAQRBrIgEkAAJ/IAAoAgAgACgCBCABQQxqEP0DIgJFBEAgABC7AUEADAELIAAgACgCACACajYCACABKAIMCyEAIAFBEGokACAACxMAIABBAToACCAAIAAoAgQ2AgALCwAgACgCCEH/AXELDwAgACAAKAIAQShqNgIACyQBAn8jAEEQayICJAAgASAAEMMCIQMgAkEQaiQAIAEgACADGwskACAAIAE2AgAgACABKAIEIgE2AgQgACABIAJBAnRqNgIIIAALEwAgAEHkIzYCACAAQQRqEG8gAAsKACAAQTBrQQpJCzMBAX8jAEEQayICJAAgAkEIaiABEOkCIAJBCGogABEAACEAIAJBCGoQXiACQRBqJAAgAAtyAgR/AXwjAEEQayIAJAAgABDzAiAAQQhqIABBtvwAEPICIAAQXiMAQRBrIgEkACAAKAIIQcSHASgCACABQQRqEAshBCABIAEoAgQQQSECIAQQ9wEhAyACEMQBIAFBEGokACAAQQhqEF4gAEEQaiQAIAMLCQAgACgCABAfCw8AIAAgACgCACgCTBECAAsLACAAQSBBABBfGgsvACABsyAClEMAAIA/IAKTIACzlJIiAkMAAIBPXSACQwAAAABgcQRAIAKpDwtBAAuQAgIGfwF+IwBBEGsiAiQAIAEQgQEhCAJAIAEtAAgEQCAAEIIEDAELAkACfyACEPEEIAinIgZBAWoiAwRAIAIQ+wMgA0kEQBB1AAsgAhApGiACIAMQJyIFNgIAIAIgBTYCBCACECkgAyAFajYCACACQQAQ+gMgAiADEP8DCyACKAIAIQdBACAGQf8BcSIDIAEoAgQgASgCACIFa0oNABoDfyADIARGBH8gAyAHakEAOgAAIAMFIAQgB2ogBS0AADoAACAEQQFqIQQgBUEBaiEFDAELCwsiBK0gCFIEQCABELsBIAAQggQMAQsgASABKAIAIARqNgIAIAAgAigCACAGEIEECyACEIAECyACQRBqJAALKgAgAAJ/QQAgACgCFEUNABpBACAAKAIUEIMDRQ0AGiAAKAIUCzYCdEEACxwAIAAgASoCMDgCMCAAIAEqAjQ4AjQgACABEGcLFgBBAUEgIABBAWtna3QgACAAQQJPGwsNACABKAIAIAIoAgBGCxYAIAAgASgCADYCACAAIAItAAA6AAQLOAEBfyAAKAIAIQEgAEEANgIAIAEEQCAAED0iAC0ABARAIAAoAgAaCyABBEAgACgCABogARAwCwsLFAEBfyAAKAIAIQEgAEEANgIAIAELDAAgACABKAIANgIACw8AIAAgAC8BACABcjsBAAsRACAAQTAgACgCACgCDBEBAAsJACAAIAEQiwILIAAgACgCBCAAECkoAgBHBEAgACABEEsPCyAAIAEQowMLCQAgAEEANgIAC2gBAn8jAEEQayIEJAAgBEEANgIMIABBDGogBEEMaiADEEcgAQRAIAAoAhAgARCyASEFCyAAIAU2AgAgACAFIAJBAnRqIgI2AgggACACNgIEIAAQMiAFIAFBAnRqNgIAIARBEGokACAACw8AIAAoAgggACgCADYCAAtVACAFIAAgASAEEH4gBUEIaiIAIAEgAiAEEH4gBUEQaiIBIAIgAyAEEH4gBUEYaiICIAUgACAEEH4gBUEgaiIDIAAgASAEEH4gBUEoaiACIAMgBBB+CxYBAX8gABAvIQEgABCrBCAAIAEQ1wMLMQAgABD5BCAAQoCAgPiDgICAPzcCoAEgAEIANwKYASAAQezVADYCACAAQcTYADYCAAsTACAAQUBrIAEQ6gMgAEEBOgA8CxQAIABByABqIAEQ6gMgAEEBOgA9CxgAIAAQpAIEQCAAKAI4EOQDDwsgABDjAwsiAQF9IABBABAmKgIAIgEgAZQgAEEBECYqAgAiASABlJKRCxQAIAAoAggiACAAKAIAKAIIEQAACx8BAX8gAEEcaiIAEC8gAUsEfyAAIAEQLigCAAVBAAsLEQAgACABNgIEIABB/D82AgALawEDfyMAQRBrIgEkACAAQfg9NgIAIAEgAEEEaiICECo2AgggASACECs2AgADQCABQQhqIAEQLARAIAEoAggoAgAiAwRAIAMgAygCACgCBBECAAsgAUEIahAtDAELCyACED4gAUEQaiQAIAALIQAgASAAKgJ4XARAIAAgATgCeCAAIAAoAgAoAlQRAgALCzcBAX0gAUMAAEBAlCIDIAJDAABAQJQiAiABQwAAwMCUkiADQwAAgD8gApOSIACUkiAAlJIgAJQLJAEBfyMAQRBrIgEkACABQQhqIAAQQSgCACEAIAFBEGokACAAC2IBAX8jAEEQayICJAAgAEEAOgAUIAIgAEEIaiIDECo2AgggAiADECs2AgADQCACQQhqIAIQLARAIAIoAghBBGogARC0AgRAIABBAToAFAsgAkEIahC9AQwBCwsgAkEQaiQACwwAIAAQwgIaIAAQMAsJACAAIAE2AgALDAAgACABLQAAOgAACycAIAMgAygCACACIAFrIgBrIgI2AgAgAEEBTgRAIAIgASAAEGUaCwsJACAAQRxqEC8LEwAgAEGELjYCACAAQQRqEG8gAAtEAQF/AkACQAJAAkACQCABQcMAaw4DAAECBAsgACACEDU2AgQMAgsgACACEDU2AggMAQsgACACEDU2AgwLQQEhAwsgAwsMACAAIAEoAgQ2AgQLIwAgABBpIABB5CM2AgAgAEEEakG8JBCUASAAQZQkNgIAIAALIgAgABDtBCAAQgA3AnggAEGQzgA2AgAgAEG09AA2AgAgAAuoAQACQCABQYAITgRAIABEAAAAAAAA4H+iIQAgAUH/D0gEQCABQf8HayEBDAILIABEAAAAAAAA4H+iIQAgAUH9FyABQf0XSBtB/g9rIQEMAQsgAUGBeEoNACAARAAAAAAAABAAoiEAIAFBg3BKBEAgAUH+B2ohAQwBCyAARAAAAAAAABAAoiEAIAFBhmggAUGGaEobQfwPaiEBCyAAIAFB/wdqrUI0hr+iC5YuAQx/IwBBEGsiDCQAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB9AFNBEBBuMABKAIAIgVBECAAQQtqQXhxIABBC0kbIghBA3YiAnYiAUEDcQRAIAFBf3NBAXEgAmoiA0EDdCIBQejAAWooAgAiBEEIaiEAAkAgBCgCCCICIAFB4MABaiIBRgRAQbjAASAFQX4gA3dxNgIADAELIAIg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QRBrIgQkACAEQQA2AgwgAEEMaiAEQQxqIAMQRyABBEAgACgCEBogAUH/////AUsEQBBGAAsgAUEDdBAnIQULIAAgBTYCACAAIAUgAkEDdGoiAjYCCCAAIAI2AgQgABAyIAUgAUEDdGo2AgAgBEEQaiQAIAALlAEBA38jAEEQayICJAAgAiABNgIMAn8jAEEQayIDJAAgABApGiADQf////8BNgIMIANB/////wc2AgggA0EMaiADQQhqEL4BKAIAIQQgA0EQaiQAIAEgBE0LBEAgABCKASIAIARBAXZJBEAgAiAAQQF0NgIIIAJBCGogAkEMahBYKAIAIQQLIAJBEGokACAEDwsQdQALJAAgACABNgIAIAAgASgCBCIBNgIEIAAgASACQQN0ajYCCCAACywBAX8gABCXAiAAKAIABEAgABDaAyAAECkaIAAoAgAhASAAEIoBGiABEDALC2IBAn8gAEGg1wA2AgAgAEFAaxA+IABBNGoQPiAAQShqIgEQxgMgASgCAARAIAEQ2AMgARApGiABKAIAIQIgARCJARogAhAwCyAAQRxqEJwCIABBEGoQnAIgAEEEahCcAiAAC4UIAgh/A30jAEFAaiIGJAACQCAAQShqIAEQzwMiCS0AACILRQRAIABBEGoiACAJLQABQQFrEE0hASAAIAktAAEQTSEHIAYQRCIAIAcgARC2ASAEBEAgBkE4ahBEIgQgASAAIAIQbCAFIARBABAmKgIAIARBARAmKgIAIAUoAgAoAhQRBwALIAAgASAAIAMQbCAFIABBABAmKgIAIABBARAmKgIAIAUoAgAoAhgRBwAMAQsgC0EBayEHIAktAAIhDSAAQTRqIAEQLioCACEPAkACQCACQwAAAABbDQAgByANaiEMIABBHGohCCAPIAKUIQ4gByEBA0AgASAMTg0BAkAgDiAIIAEQTSIKKgIEIhBfBEAgASAHRw0BIA4gEJUgCioCAJQhAgwDCyABQQFqIQEMAQsLIAggAUEBayIMEE0qAgQhAiAKKgIEIRAgCCAMEE0qAgAgCioCACAOIAKTIBAgApOVEM4DIQIMAQsgByEBCwJ9QwAAgD8gA0MAAIA/Ww0AGiABIAsgDWpBAWsiCCABIAhKGyELIABBHGohCCAPIAOUIQ4DQCADIAEgC0YNARoCQCAOIAggARBNIgoqAgQiD18E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IAMgBCgCACgCMBELAAsgB0EIahAtDAALAAsgB0EQaiQAIAZBCGoQLQwBBSAGQRBqJAALCwshACABIAAoAjBHBEAgACABNgIwIAAgACgCACgCOBECAAsLBwAgACoCBAs0ACAAKAIAGiAAKAIAIAAQkgFBAnRqGiAAKAIAIAAQL0ECdGoaIAAoAgAgABCSAUECdGoaCxQAIABBoDg2AgAgAEEIahC4BCAACyQBAn8jAEEQayICJAAgACABELIEIQMgAkEQaiQAIAEgACADGwsJACAAQQA2AgALCwAgASACQSgQZRoLFAAgAEH0NjYCACAAQQhqELgEIAALDQAgACgCACABQShsagsOACAAKAIIQf////8HcQsZACAAQag2NgIAIABBEGoQPiAAEOIBGiAACw0AIAAoAgAgASgCAEkLLAAgACgCABogACgCACAAEJIBQQJ0ahogACgCACAAEJIBQQJ0ahogACgCABoLCQAgACABOgALCxEAIABBOCAAKAIAKAIMEQEACw0AIAAoAgAgASgCAEYLGgAgAUGlAUYEQCAAIAIQNTYCBAsgAUGlAUYLEwAgACgCACABIAAqAgQgAhC3Ags7ACAAEOQEIABCADcCDCAAQv////8PNwIEIABBsDA2AgAgAEEANgIUIABBqMMANgIAIABBGGoQOhogAAtZAQJ/IwBBEGsiAiQAIAAQgwEEQCAAKAIAIQMgABDBAhogAxAwCyAAIAEoAgg2AgggACABKQIANwIAIAFBABDFAiACQQA6AA8gASACQQ9qEOkBIAJBEGokAAsYACAAENUEIABBpC02AgAgAEGMwQA2AgALOAEBfyMAQRBrIgMkACABQYoBRgRAIAMgAhDIASAAQQRqIAMQywIgAxBvCyADQRBqJAAgAUGKAUYLKwAgABBpIABBfzYCDCAAQgA3AgQgAEGAKjYCACAAQQA2AhAgAEHsOzYCAAsMACAAEMABGiAAEDALOgAgABDtBCAAQcQJNgIAIABB6Ag2AgAgAEEANgJ4IABBiAg2AgAgAEG4xgA2AgAgAEH8AGoQOhogAAsjACAAQez3ADYCRCAAQZD3ADYCACAAQdQAahA+IAAQQxogAAtZAQF/IAAQlQEgAEIANwIwIABBqCA2AgAgAEIANwI4IABBgICA/AM2AkAgAEHEAGoQ7gQhASAAQZD3ADYCACAB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A0UNAyAAIAMoAgQgARA7IgcQLiACNgIAA0AgAygCACICRQ0EAkAgAigCBCABEDsiBCAHRg0AIAIhBSAAIAQQLigCAEUEQCAAIAQQLiADNgIAIAQhBwwBCwNAAkAgBSIGKAIARQRAQQAhBQwBCyAAEEUgAkEIaiAGKAIAQQhqEJ8BIQggBigCACEFIAgNAQsLIAMgBTYCACAGIAAgBBAuKAIAKAIANgIAIAAgBBAuKAIAIAI2AgAMAQsgAiEDDAALAAUgACACEC5BADYCACACQQFqIQIMAQsACwALIABBABB6IAAQPUEANgIACwsoACAAEIACIABBADYCWCAAQgA3AlAgAEG0ETYCACAAQfTRADYCACAACzgAIAMoAgAhAiMAQRBrIgAkACAAIAI2AgggACgCCCgCACECIAFBADYCBCABIAI2AgAgAEEQaiQACwwAIAAgASgCABCJAgsMACAAKAIAGiABEDALCQAgACABENABCwwAIAAgASoCADgCAAtOAQJ/IwBBEGsiAiQAIAJBADYCDCAAIAJBDGoQ0AEjAEEQayIBJAAgAUEANgIMIABBBGogAUEMaiABQQhqEJwDIAFBEGokACACQRBqJAALTQEBfyMAQRBrIgEkACAAEJ4DIABBCGoQ1QEgAUEANgIMIABBDGogAUEMahDQASABQYCAgPwDNgIEIABBEGogAUEEahCdAyABQRBqJAALDgAgAC8BLEECEFpBAkYLXQAgACABIAIgACgCACgCFBEHACAAIAEgA5IiAyACIAAoAgAoAhgRBwAgACADIAIgBJIiAiAAKAIAKAIYEQcAIAAgASACIAAoAgAoAhgRBwAgACAAKAIAKAIgEQIACyoBAX8CQCABQQBIDQAgAEHcAGoiABAvIAFMDQAgACABEC4oAgAhAgsgAgu4AQEHfyMAQSBrIgckACAAECkiAwJ/IAAgABAvQQFqEEohBCAAEC8hCCMAQRBrIgUkACAFQQA2AgwgB0EIaiICQQxqIAVBDGogAxBHIAQEQCACKAIQGiAEEJYDIQYLIAIgBjYCACACIAYgCEECdGoiAzYCCCACIAM2AgQgAhAyIAYgBEECdGo2AgAgBUEQaiQAIAIoAggLIAEQSCACIAIoAghBBGo2AgggACACEEwgAhBJIAdBIGokAAsPACAAQRRqEK8BIAAQrwELEQEBfyAAKAIAIQEgABAtIAELEQAgABCfAyAAQRRqEJ8DIAAL9wIBBX8jAEEQayIBJAAgAEGc5gA2AkggAEHA5QA2AgAgASAAQdwAaiIFECo2AgggASAFECs2AgADQCABQQhqIAEQLEUEQCABIABB6ABqIgMQKjYCCCABIAMQKzYCAANAIAFBCGogARAsRQRAIAEgAEH0AGoiBBAqNgIIIAEgBBArNgIAA0AgAUEIaiABECxFBEAgACgCrAEiAgRAIAIgAigCACgCBBECAAsgACgCqAEiAgRAIAIgAigCACgCBBECAAsgAEGYAWoQPiAAQYwBahA+IABBgAFqED4gBBA+IAMQPiAFED4gAEHMAGoQrAMgABBDGiABQRBqJAAgAA8LIAEoAggoAgAiAgRAIAIgAigCACgCBBECAAsgAUEIahAtDAALAAsgASgCCCgCACIEBEAgBCAEKAIAKAIEEQIACyABQQhqEC0MAAsACyABKAIIKAIAIgMgAEYgA0VyRQRAIAMgAygCACgCBBECAAsgAUEIahAtDAALAAsuACAAQbzkADYCACAAQagCahBDGiAAQegBahBDGiAAQagBahBDGiAAEIgBGiAAC0wBA38gABDaASAAQcQdNgIAIABBvOQANgIAIABBqAFqEG4hASAAQegBahBuIQIgAEGoAmoQbiEDIAAgARBkIAAgAhBkIAAgAxBkIAALOgAgABBzIABBAToAOCAAQv////8PNwIwIABB6BA2AgAgAEHk0AA2AgAgAEE8ahA6GiAAQgA3AkggAAsnACAAEJICGiAAQYCAgPgDNgKwASAAQdwbNgIAIABB1OIANgIAIAALCQAgAEEEahA+Cy4AIABBwN8ANgIAIABB7AFqED4gAEGwAWoQlQIaIABBoAFqEKwDIAAQ9gQaIAALDwAgACAALQAAIAFyOgAAC3gBAX8gAEGwAWpBCEEBEF8aIwBBEGsiASQAIAEgAEGkAWoiABAqNgIIIAEgABArNgIAA0AgAUEIaiABECwEQCABKAIIKAIAIgAQjgIEQCAAKAJIIgAEQCAAIAAoAgAoAgQRAgALCyABQQhqEC0MAQsLIAFBEGokAAuJAQAgABDwARogAEIDNwKAASAAQbDgADYCACAAQewaNgIAIABBiAFqEDoaIABBADYCnAEgAEIANwKUASAAQfwZNgIAIABBoAFqEPcDIABBwN8ANgIAIABBsAFqEHMgAEIANwLkASAAIAA2AuABIABBgNsANgKwASAAQewBahA6GiAAQQA6APgBIAALNwAgAEGo3gA2AgAgAEH8AmoQQxogAEG8AmoQQxogAEH8AWoQQxogAEG8AWoQQxogABCIARogAAt0AQR/IAAQ2gEgAEIANwKsASAAQQE6AKgBIABB5Bg2AgAgAEIANwK0ASAAQajeADYCACAAQbwBahBuIQEgAEH8AWoQbiECIABBvAJqEG4hAyAAQfwCahBuIQQgACABEGQgACACEGQgACADEGQgACAEEGQgAAsrAQF/IAAgASgCADYCACABKAIAIQMgACABNgIIIAAgAyACQQJ0ajYCBCAAC9kBAQV/IAFBCBBQBEAgAEGMAWoQLyAAIAAoAgAoAoQBEQAARwRAAkAgACAAKAIAKAKEAREAACIEIABBjAFqIgUQLyICRg0AIAIgBE4EQCAEIQMDQCACIANGBEAgBSAEELYDDAMLIAUgAxAuKAIAIgYEQCAGIAYoAgAoAgQRAgALIANBAWohAwwACwALIAUgBBC2AwNAIAIgBEYNAUHAABAnQQBBwAAQMxBuIQMgBSACEC4gAzYCACACQQFqIQIMAAsACwsgACAAKAIAKAKIARECAAsgACABEKEBCxgBAX8gABAvIQIgACABEKAEIAAgAhDXAwurAgEFfyABIAAQLyICSwRAIwBBIGsiBCQAAkAgASACayIBIAAQKSgCACAAKAIEa0ECdU0EQCMAQRBrIgIkACACIAAgARC/ASIBKAIEIQMDQCABKAIIIANHBEAgABApGiABKAIEENUBIAEgASgCBEEEaiIDNgIEDAELCyABEGggAkEQaiQADAELIAAQKSECIARBCGogACAAEC8gAWoQSiAAEC8gAhDWASICIQMjAEEQayIFJAAgBSADQQhqIAEQswMiASgCACEGA0AgASgCBCAGRwRAIAMoAhAaIAEoAgAQ1QEgASABKAIAQQRqIgY2AgAMAQsLIAEQ1wEgBUEQaiQAIAAgAhBMIAIQSQsgBEEgaiQADwsgASACSQRAIAAgACgCACABQQJ0ahC1AwsLKwAgACoCMCAAKgI0IAAoAjgoAjQgACgCOCgCMCABIAIgACgCOBC4AxCtAgsHACAAQThqC1wBAn8jAEEQayIBJAAgACgCMCAAEHAgASAAKAIwEJQCIgIQKjYCCCABIAIQKzYCAANAIAFBCGogARAsBEAgASgCCCgCACAAEHAgAUEIahAtDAEFIAFBEGokAAsLCygAIAIgAWsiAEEBTgRAIAMoAgAgASAAEGUaIAMgAygCACAAajYCAAsLxwEBBH8jAEEQayIEJAAgARApGiMAQRBrIgIkACAAQgA3AgAgAkEANgIMIABBCGogAkEMahC9AiACQRBqJAAgARAvIgIEQCAAEL4EIAJJBEAQdQALIAAgABApIAIQsgEiAzYCACAAIAM2AgQgABApIAMgAkECdGo2AgAgAEEAEMQCIAEoAgAhAyABKAIEIQUjAEEQayIBJAAgASAAIAIQvwEhAiAAECkgAyAFIAJBBGoQugMgAhBoIAFBEGokAAsgBEEQaiQAIAALsAEAIABBqAw2AgAgAEHwCzYCACAAQQRqIAFBBGoQhAUgACABKAIQNgIQIABBuOcANgIAIAAgASgCFDYCFCAAQRhqIAFBGGoQuwMaIAAgAS8BLDsBLCAAIAEpAiQ3AiQgAEGwCzYCACAAQfAKNgIAIABB4BI2AgAgACABKQIwNwIwIABBwNsANgIAIAAgASgCODYCOCAAQfQcNgIAIAAgASoCPDgCPCAAQezjADYCACAACxsAIABBCEEAEF8aIAAoAoQBIgAEQCAAEK8DCwtqAQJ/IAAoAgQgABApKAIARwRAIAAgARBLDwsjAEEgayIDJAAgABApIgIgA0EIaiAAIAAQL0EBahBKIAAQLyACENYBIgIoAgggARBIIAIgAigCCEEEajYCCCAAIAIQTCACEEkgA0EgaiQACxwAIAAQhgIgACAAKAKEAUGgAWpBABCwATYCiAELDAAgASACKgIAOAIACwcAIAAQRBoLFgAgASACLwAAOwAAIAEgAi0AAjoAAguDAQEFfyAAEJcCIAAQKSEEIAAoAgAhBSAAKAIEIQIgAUEEaiIGIQMDQCACIAVHBEAgBCADKAIAQQhrIAJBCGsiAhCWAiADIAMoAgBBCGs2AgAMAQsLIAAgBhA2IABBBGogAUEIahA2IAAQKSABEDIQNiABIAEoAgQ2AgAgACAAEE4QxwMLegECfyMAQRBrIgQkACAEQQA2AgwgAEEMaiAEQQxqIAMQRyABBEAgACgCEBogAUH/////A0sEQBBGAAsgAUECdBAnIQULIAAgBTYCACAAIAUgAkECdGoiAjYCCCAAIAI2AgQgABAyIAUgAUECdGo2AgAgBEEQaiQAIAALKwEBfyAAKAIEIQIDQCABIAJHBEAgABApGiACQQhrIQIMAQsLIAAgATYCBAs1ACAAKAIAGiAAKAIAIAAQiQFBA2xqGiAAKAIAIAAQiwFBA2xqGiAAKAIAIAAQiQFBA2xqGgssACAAKAIAGiAAKAIAIAAQigFBA3RqGiAAKAIAIAAQigFBA3RqGiAAKAIAGgtRACAAEHMgAEIANwJEIABCgICAgICAgMA/NwI8IABCgICA/AM3AjQgAEF/NgIwIABBxA82AgAgAEHgyQA2AgAgAEHMAGoQVBogAEEANgJkIAALDAAgASACKQIANwIAC2ICAX8BfSMAQRBrIgIkACACIABBABAmKgIAIAFBABAmKgIAk4s4AgwgAiAAQQEQJioCACABQQEQJioCAJOLOAIIIAJBDGogAkEIahC8AioCACEDIAJBEGokACADQwAAgD9eCywBAX8gAEHw1gA2AgAgACgCaCIBBEAgASABKAIAKAIEEQIACyAAEJ0CGiAACwsAIABBlNgANgIAC1AAIAAQzAMgAEGg1wA2AgAgAEEEahA6GiAAQRBqEDoaIABBHGoQOhogAEEoahA6GiAAQTRqEDoaIABBQGsQOhogAEEANgJMIABB0ABqEFQaCw0AIAEgAJMgApQgAJILDQAgACgCACABQQNsagtjAQF/IwBBEGsiByQAIABBKGogB0EIakEBIABBBGoiABBOQf8BcRDSAxDRAyAAIAdBCGogASACEEAQtAEgACAHQQhqIAMgBBBAELQBIAAgB0EIaiAFIAYQQBC0ASAHQRBqJAALogUBB38gACgCBCAAECkoAgBJBEAjAEEQayICJAAgAiAANgIAIAIgACgCBCIDNgIEIAIgA0EDajYCCCAAECkgAigCBCABEMIDIAIgAigCBEEDajYCBCACEGggAkEQaiQADwsjAEEgayIHJAAgABApIggCfyAHQQhqIQICfyAAEIsBQQFqIQYjAEEQayIFJAAgBSAGNgIMAn8jAEEQayIEJAAgABApGiAEQdWq1aoFNgIMIARB/////wc2AgggBEEMaiAEQQhqEL4BKAIAIQMgBEEQaiQAIAMgBk8LBEAgABCJASIEIANBAXZJBEAgBSAEQQF0NgIIIAVBCGogBUEMahBYKAIAIQMLIAVBEGokACADDAELEHUACyEFIAAQiwEhBkEAIQMjAEEQayIEJAAgBEEANgIMIAJBDGogBEEMaiAIEEcgBQRAIAIoAhAaIAVB1arVqgVLBEAQRgALIAVBA2wQJyEDCyACIAM2AgAgAiADIAZBA2xqIgY2AgggAiAGNgIEIAIQMiADIAVBA2xqNgIAIARBEGokACACKAIICyABEMIDIAIgAigCCEEDajYCCCAAEMYDIAAQKRogAkEEaiIDIgEgASgCACAAKAIEIAAoAgAiBWsiAUF9bUEDbGoiBDYCACABQQFOBEAgBCAFIAEQZRoLIAAgAxA2IABBBGogAkEIahA2IAAQKSACEDIQNiACIAIoAgQ2AgAgABCLARogACgCABogACgCACAAEIkBQQNsahogACgCACAAEIkBQQNsahogACgCABogAigCBCEAA0AgACACKAIIRwRAIAIoAhAaIAIgAigCCEEDazYCCAwBCwsgAigCAARAIAIoAhAaIAIoAgAhACACEDIoAgAgAigCAGsaIAAQMAsgB0EgaiQACxkAIABBADoAAiAAIAI6AAEgACABOgAAIAALQAEBfyMAQRBrIgMkACAAQShqIANBCGpBACAAQQRqIgAQTkH/AXEQ0gMQ0QMgACADIAEgAhBAELQBIANBEGokAAsnAQF/IwBBEGsiAyQAIABBBGogA0EIaiABIAIQQBC0ASADQRBqJAALnwEBAn8gACgCBCAAECkoAgBHBEAjAEEQayIDJAAgAyAAQQEQvwEhAiAAECkgAigCBCABEMADIAIgAigCBEEEajYCBCACEGggA0EQaiQADwsjAEEgayIDJAAgABApIgIgA0EIaiAAIAAQL0EBahBKIAAQLyACEMQDIgIoAgggARDAAyACIAIoAghBBGo2AgggACACEEwgAhBJIANBIGokAAuJCAIOfwJ9IwBBEGsiCSQAIAkgATYCDCMAQSBrIgUkAAJAAkAgAUE0aiIKEKECDQACQCACQQAQJioCACABQdAAaiIEQQAQJioCAFwNACACQQEQJioCACAEQQEQJioCAFwNACACQQIQJioCACAEQQIQJioCAFwNACACQQMQJioCACAEQQMQJioCAFwNACACQQQQJioCACAEQQQQJioCAFwNACACQQUQJioCACAEQQUQJioCAFshAwsgA0UNACABKgJMIREMAQsgASACKQIANwJQIAEgAikCEDcCYCABIAIpAgg3AlggChDZASABQRxqIgsQogIgAUEEaiINEE4hAwJAIAMgAUEQaiIMIgQQTiIGSwRAIwBBIGsiDiQAAkAgAyAGayIGIAQQKSgCACAEKAIEa0EDdU0EQCMAQRBrIggkACAIIAQgBhCbAiIDKAIEIQYDQCADKAIIIAZHBEAgBBApGiADKAIEEMEDIAMgAygCBEEIaiIGNgIEDAELCyADEGggCEEQaiQADAELIAQQKSEDIA5BCGogBCAEEE4gBmoQmgIgBBBOIAMQmQIiDyEIIwBBEGsiAyQAIAMgCCgCCDYCACAIKAIIIRAgAyAIQQhqNgIIIAMgECAGQQN0ajYCBCADKAIAIQYDQCADKAIEIAZHBEAgCCgCEBogAygCABDBAyADIAMoAgBBCGoiBjYCAAwBCwsgAxDXASADQRBqJAAgBCAPEMMDIA8QmAILIA5BIGokAAwBCyADIAZJBEAgBCgCACADQQN0aiEDIAQQTiEGIAQgAxDFAyAEIAYQ2QMLCyANEE4hBANAIAQgB0YEQCAMQQAQTSEHIAUgAUEoaiICECo2AhggBSACECs2AhBBASECA0AgBUEYaiAFQRBqECwEQAJ/IAUoAhgiBC0AAEUEQCAFIAcgDCACEE0iBxDrAzgCDCAKIAVBDGoQ1QMgBSoCDCESIAJBAWoMAQsgBCALEE4iA0EBajoAACAFIAcgB0EIaiAHQRBqIAdBGGoiB0MAAAAAQwAAAABDAACAPyALEKACOAIMIAogBUEMahDVAyAFKgIMIRIgBCALEE4gA2s6AAIgAkEDagshAiARIBKSIREgBSAFKAIYQQNqNgIYDAEFIAEgETgCTAsLBSAMIAcQTSANIAcQTSACEKoCIAdBAWohBwwBCwsLIAVBIGokACAAIBEgACoCTJI4AkwgCUEMaiECAkAgAEFAayIAKAIEIAAQKSgCAEkEQCAAIAIQSwwBCyMAQSBrIgUkACAAECkiASAFQQhqIAAgABAvQQFqEEogABAvIAEQxAMiASgCCCACEEggASABKAIIQQRqNgIIIAAgARBMIAEQSSAFQSBqJAALIAlBEGokAAsrACAAKAIAGiAAKAIAIAAQkgFBAnRqGiAAKAIAGiAAKAIAIAAQL0ECdGoaCzIBAn8gACgCACECIAAoAgQhAQNAIAEgAkcEQCAAECkaIAFBA2shAQwBCwsgACACNgIECysAIAAoAgAaIAAoAgAgABCKAUEDdGoaIAAoAgAaIAAoAgAgABBOQQN0ahoLDAAgACAAKAIAEMUDC2UBAX8gAEEANgJMIABBHGoQogIgAEEEahCiAiAAQShqIgEQiwEaIAEQ2AMgASgCABogASgCACABEIkBQQNsahogASgCABogASgCACABEIsBQQNsahogAEE0ahDZASAAQUBrENkBCyMBAX0CQCAAQwAAAABdDQBDAACAPyIBIABdDQAgACEBCyABCzcAIABB6NQANgIAIABByANqEEMaIABB6AJqEEMaIABBiAJqEEMaIABBqAFqEEMaIAAQiAEaIAALRAAgACABKgIwOAIwIAAgASoCNDgCNCAAIAEqAjg4AjggACABKgI8OAI8IAAgASoCQDgCQCAAIAEqAkQ4AkQgACABEGcLYAEEfyAAENoBIABB6BQ2AgAgAEHo1AA2AgAgAEGoAWoQqwEhASAAQYgCahCrASECIABB6AJqEKsBIQMgAEHIA2oQqwEhBCAAIAEQZCAAIAIQZCAAIAMQZCAAIAQQZCAACw4AIAAQsQEgAEEAOwE8CyUAIAAtAD1FBEAgACAAKAIAKAJIEQIAIABBAToAPQsgAEHIAGoLVAAgABCVASAAQgA3AkAgAEKAgICAgICAwD83AjggAEKAgID8AzcCMCAAQewONgIAIABBxMgANgIAIABByABqEFQaIABB4ABqEDoaIABBADYCbCAACyQAIAAtADxFBEAgACAAKAIAKAJEEQIAIABBAToAPAsgAEFAawsIACAAQdAAagtPAQF/IwBBEGsiASQAIABBQGsgAUEIaiAAKgIwIAAqAjQQQCABIAAqAlAQmQEgACoCVIyUIAAqAlAQmgEgACoCVIyUEEAQtwEgAUEQaiQACxkAIABB5NAANgIAIABBPGoQPiAAEEMaIAALCwAgACgChAFBAXELCAAgAEGwAWoLEQAgAEEDIAAoAgAoAgwRAQALMAEBfSABQQAQJioCACECIABBABAmIAI4AgAgAUEBECYqAgAhAiAAQQEQJiACOAIACzYBAX0gAUEAECYqAgAgAEEAECYqAgCTIgIgApQgAUEBECYqAgAgAEEBECYqAgCTIgIgApSSkQtMACAAQQAQJkGAgID8AzYCACAAQQEQJkEANgIAIABBAhAmQQA2AgAgAEEDECZBgICA/AM2AgAgAEEEECZBADYCACAAQQUQJkEANgIAC9gBAQh9IAFBABAmKgIAIQMgAUEBECYqAgAhBCABQQIQJioCACEFIAFBAxAmKgIAIQYgAUEEECYqAgAhByABQQUQJiEBIAMgBpQgBCAFlJMiCEMAAAAAXARAIAEqAgAhCSAAQQAQJiAGQwAAgD8gCJUiApQ4AgAgAEEBECYgAiAEjJQ4AgAgAEECECYgAiAFjJQ4AgAgAEEDECYgAyAClDgCACAAQQQQJiACIAUgCZQgBiAHlJOUOAIAIABBBRAmIAIgBCAHlCADIAmUk5Q4AgALIAhDAAAAAFwLWAAgACABQQAQJioCADgCACAAIAFBARAmKgIAOAIEIAAgAUECECYqAgA4AgggACABQQMQJioCADgCDCAAIAFBBBAmKgIAOAIQIAAgAUEFECYqAgA4AhQgAAsyACAAvEH/////B3FBgICA/AdNBH0gACAAIAGWIAG8Qf////8HcUGAgID8B0sbBSABCwuOAgEIfyAAKAIEIQAjAEEQayIEJAAgBCABNgIMIARBDGohBwJAIABBEGoiASgCBCABECkoAgBHBEAgASAHEEsMAQsjAEEgayIIJAAgARApIgUCfyABIAEQL0EBahBKIQMgARAvIQkjAEEQayIGJAAgBkEANgIMIAhBCGoiAEEMaiAGQQxqIAUQRyADBEAgACgCEBogA0H/////A0sEQBBGAAsgA0ECdBAnIQILIAAgAjYCACAAIAIgCUECdGoiBTYCCCAAIAU2AgQgABAyIAIgA0ECdGo2AgAgBkEQaiQAIAAoAggLIAcQSCAAIAAoAghBBGo2AgggASAAEEwgABBJIAhBIGokAAsgBEEQaiQACxIAIABByAAgACgCACgCDBEBAAswAQF/IAAoAgQhAiMAQRBrIgAkACAAIAE2AgwgAkHcAGogAEEMahDUASAAQRBqJAALBABBAgspACAAEJUBIABBfzYCMCAAQYTNADYCACAAQQA2AjQgAEHQ6AA2AgAgAAsaACAAEGkgAEGszAA2AgAgAEHYzAA2AgAgAAsMACAAEKwCGiAAEDALEQAgAEEAOgAAIABBBGoQOhoLnAEBAX8gABCVASAAQgA3AjAgAEHIywA2AgAgAEIANwI4IABBQGtCADcCACAAQcgAaiIBQaDMADYCACAAQcwAahD3AyAAQcDlADYCACABQZzmADYCACAAQdwAahA6GiAAQegAahA6GiAAQfQAahA6GiAAQYABahA6GiAAQYwBahA6GiAAQZgBahA6GiAAQgA3AqwBIABCADcCpAEgAAsrAQF/IAAoAgQhAgNAIAEgAkcEQCAAECkaIAJBAWshAgwBCwsgACABNgIECyYAIAAoAgAaIAAoAgAgABCOAWoaIAAoAgAgABCOAWoaIAAoAgAaCz8BAX8jAEEQayIBJAAgABApGiABQX82AgwgAUH/////BzYCCCABQQxqIAFBCGoQvgEoAgAhACABQRBqJAAgAAs0AQJ/AkAgACgCBCAAKAIAIgJrQQBMBEAgABC7AQwBCyAAIAJBAWo2AgAgAi0AACEBCyABCx4BAX8gASAAa0EETwR/IAIgACgAADYCAEEEBUEACwssACAAKAIAGiAAKAIAIAAQjgFqGiAAKAIAIAAQgAFqGiAAKAIAIAAQjgFqGgtqAQJ/IwBBEGsiAiQAIAIgADYCACACIAAoAgQiAzYCBCACIAEgA2o2AgggAiIBKAIEIQMDQCABKAIIIANHBEAgABApGiABKAIEELkBIAEgASgCBEEBaiIDNgIEDAELCyABEGggAkEQaiQACzEBAX8gABD+AyAAKAIABEAgACAAKAIAEPkDIAAQKRogACgCACEBIAAQjgEaIAEQMAsLHQEBfyMAQRBrIgMkACAAIAEgAhDfAiADQRBqJAALPQECfyMAQRBrIgEkACAAIQJBACEAA0AgAEEDRwRAIAIgAEECdGpBADYCACAAQQFqIQAMAQsLIAFBEGokAAsjACAAENACGiAAQgA3AogBIABBhA42AgAgAEHcxwA2AgAgAAsOACABIABBA3R2Qf8BcQsqAQF/IABBxMgANgIAIAAoAmwiAQRAIAEQMAsgAEHgAGoQPiAAEEMaIAALNgACQAJAAkAgAUHmAGsOAgABAgsgACACEDU2AjBBAQ8LIAAgAhA1NgI0QQEPCyAAIAEgAhBZCxQAIAAgARDhASAAQbDEADYCACAACw4AIAAQvAFBBBBaQQRGC2IBAn0gABC8AUEIEFpBCEYEQAJ9QwAAAAAgACABIAAoAgAoAjgRAQAiAUUNABogAgRAIAEQlwQhAwsgARC2AgshBCADIAQgACgCELJDAADIQpWUkg8LIAAoAhCyQwAAekSVC3IBA38jAEEQayIBJAAgAEG0wgA2AgAgASAAQRBqIgIQKjYCCCABIAIQKzYCAANAIAFBCGogARAsBEAgASgCCCgCACIDBEAgAyADKAIAKAIEEQIACyABQQhqEC0MAQsLIAIQPiAAEOwBGiABQRBqJAAgAAsOACAAELwBQRAQWkEQRgsfAQF/IABBBGoiABAvIAFLBH8gACABEC4oAgAFQQALCwkAIABBBGoQLwv8BAIKfwN9AkAgAUUNACAAKAIIIQYgASgCBCILEI0EIQwDQCAKIAxGDQEgCyAKEIwEIgchCEEAIQkjAEEQayIFJAACQCAIELwBQQEQWkEBRg0AIAUgCEEYaiIEECo2AgggBSAEECs2AgADQCAFQQhqIAUQLARAIAIgBSgCCCgCACIEKAIEQQJ0aigCACENIAMEQCAEQcQAIAQoAgAoAgwRAQANAwsgBCANIAQoAgAoAigRAQBFDQIgBUEIahAtDAELC0ECIQkgCBCIBEUNACAIIAEgCCgCACgCNBEBACIEBEAgBCoCDCEQQQEhCSAEKgIIIAggASgCBEEAEIkEIg4gBCgCABC2AiIPXQR9IA4gDyAQIA+VjpSSBSAOC10NAQtBAiEJCyAFQRBqJAACQAJAAkAgCUEBaw4CAQACCyAAIAcoAhQQkARFDQEgACAHNgIQIABBAToAIAJAIAAoAgwiA0UNACADIAAoAgRGDQAgAyADKAIAKAIEEQIACyAAIAY2AgwCQCAGRQ0AQQAhAwJ/IAZFIAcQiARFckUEQCAGKAIEEKIBIQMLIANFIAcQiwRFckULBH8gBhApIAcgBigCBEEBEIkEEJUEQQEFIAMLRQ0AIAAgARApIgMoAgA2AiQgACADKgIEOAIoCyAAIAAqAhgiDjgCHCAOQwAAAABcBEAgACAHEIsEOgAUCwJAIAAoAgwiA0UNACADKAIEEKIBRQ0AIAAoAghFDQAgARApKgIQIQ4gACgCCCIBIA4gAiABKAIAKAIIEQwACyAAQQA2AhggAEMAAAAAEI8EIABBADoAIUEBDwsgAEEBOgAhCyAKQQFqIQoMAAsAC0EAC+0BAQN/IwBBEGsiAiQAAkACQCAAKAIQIgNFDQAgACgCDEUNACADKAIMRQ0AIAJBgICA/AM2AgwgAkEANgIIIAIgACoCGCABAn0gACgCDCgCBCEEQwAAAAAhAUMAAAAAIAAoAhAiAygCDEUNABogAxC8AUECEFpBAkYEQAJAIAQQogFFDQAgBCgCFCIERQ0AIAQQtgIhAQsgASADKAIMskMAAMhClZQMAQsgAygCDLJDAAB6RJULlZI4AgQgACACQQxqIAJBCGogAkEEahC8AhCkASoCADgCGAwBCyAAQYCAgPwDNgIYCyACQRBqJAALQAEBfwJ/QQAgACgCCCICRQ0AGiACKAIECyICIAFHBEAgACABBH8gASABKAIAKAIkEQAABUEACzYCCAsgASACRwsoAQF/IwBBEGsiAiQAIAIgATYCDCAAQRxqIAJBDGoQkgQgAkEQaiQAC+ABAQd/IAAoAgQgABApKAIARwRAIAAgARBLDwsjAEEgayIHJAAgABApIgQCfyAAIAAQL0EBahBKIQMgABAvIQgjAEEQayIFJAAgBUEANgIMIAdBCGoiAkEMaiAFQQxqIAQQRyADBEAgAigCEBogA0H/////A0sEQBBGAAsgA0ECdBAnIQYLIAIgBjYCACACIAYgCEECdGoiBDYCCCACIAQ2AgQgAhAyIAYgA0ECdGo2AgAgBUEQaiQAIAIoAggLIAEQSCACIAIoAghBBGo2AgggACACEEwgAhBJIAdBIGokAAvEAQEEfyMAQRBrIgEkACAAQZjAADYCACABIABBHGoiAxAqNgIIIAEgAxArNgIAA0ACQCABQQhqIAEQLEUEQCABIABBEGoiAhAqNgIIIAEgAhArNgIAA0AgAUEIaiABECxFDQIgASgCCCgCACIEBEAgBCAEKAIAKAIEEQIACyABQQhqEC0MAAsACyABKAIIKAIAIgIEQCACIAIoAgAoAgQRAgALIAFBCGoQLQwBCwsgAxA+IAIQPiAAEMABGiABQRBqJAAgAAtCACAAEK4CGiAAQv+BgIAQNwJIIABC/4GAgBA3AkAgAEHUDDYCACAAQawNNgIAIABB0ABqEEQaIABB2ABqEEQaIAALZQICfwF9IAEgACoCBFwEQCAAIAE4AgQgACoCCCAAKgIMkyEEIAAoAgAtACgEQCAAKAIAKAIgIQILIAAoAgAoAhAhAyAAQQE2AhQgACABIAIgA2yykyIBOAIIIAAgASAEkzgCDAsLqwQDAX8EfgJ8AnwgALshBwJAIAG3Igi9IgVCAYYiBFAgBUL///////////8Ag0KAgICAgICA+P8AVnJFBEAgB70iBkI0iKdB/w9xIgJB/w9HDQELIAcgCKIiCCAIowwBCwJ+AkAgBCAGQgGGIgNUBEAgBUI0iKdB/w9xIQEgAkUEQCAGQgyGIgNCAFMEQEEAIQIMAwtBfyECA0AgA0IBhiIDQgBTDQMgAkEBayECDAALAAsgBkL/////////B4NCgICAgICAgAiEDAILIAdEAAAAAAAAAACiIAcgAyAEURsMAgsgBkEBIAJrrYYLIQMCfgJAIAFFBEAgBUIMhiIEQgBTBEBBACEBDAILQX8hAQNAIARCAYYiBEIAUw0CIAFBAWshAQwACwALIAVC/////////weDQoCAgICAgIAIhAwBCyAFQQEgAWuthgshBSABIAJIBEADQAJAIAMgBX0iBEIAUw0AIAQiA0IAUg0AIAdEAAAAAAAAAACiDAMLIANCAYYhAyACQQFrIgIgAUoNAAsgASECCwJAIAMgBX0iBEIAUw0AIAQiA0IAUg0AIAdEAAAAAAAAAACiDAELAkAgA0L/////////B1YEQCADIQQMAQsDQCACQQFrIQIgA0KAgICAgICABFQhASADQgGGIgQhAyABDQALCyAGQoCAgICAgICAgH+DIARCgICAgICAgAh9IAKtQjSGhCAEQQEgAmutiCACQQFOG4S/CwsdACAALQAoBH0gACgCILIFQwAAAAALIAAoAhCylQtxAQN/IwBBEGsiASQAIABB7D42AgAgASAAQSxqIgIQKjYCCCABIAIQKzYCAANAIAFBCGogARAsBEAgASgCCCgCACIDBEAgAyADKAIAKAIEEQIACyABQQhqEC0MAQsLIAIQPiAAEMABGiABQRBqJAAgAAsaACABQTkQUSIBRQRAQQEPCyABIAAQ8ANBAAswACAAIAEqAjA4AjAgACABKgI0OAI0IAAgASoCODgCOCAAIAEqAjw4AjwgACABEGcLIwAgASAAKAKAAUcEQCAAIAE2AoABIAAgACgCACgCXBECAAsLIQAgASAAKAIkRwRAIAAgATYCJCAAIAAoAgAoAjwRAgALCyEAIAEgACgCDEcEQCAAIAE2AgwgACAAKAIAKAIsEQIACwshACABIAAoAghHBEAgACABNgII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CBDkASABkyAFlZMhBCACQQFqIQIMAAsACyAHQwAAAABbDQAgBUPNzMw9kiEHQQAhAgNAIAUgByAFk0MAAAA/lJIiBCAGIAgQ5AEgAZMiCYshCiACQQhLDQEgBSAEIAlDAAAAAF4iAxshBSAEIAcgAxshByACQQFqIQIgCkOVv9YzXg0ACwsgBAsgACoCCCAAKgIQEOQBC0IBAX0gAUMAAEBAlCIDIAJDAABAQJQiAiABQwAAwMCUkiIBIAGSIACUIANDAACAPyACk5JDAABAQJQgAJQgAJSSkgsMACAAELACGiAAEDALZgEBfyMAQRBrIgIkACACIABBCGoiABAqNgIIIAIgABArNgIAA0ACQAJ/QQAgAkEIaiACECxFDQAaIAIoAggiACgCACABRw0BIAAQPQshACACQRBqJAAgAA8LIAJBCGoQvQEMAAsACw0AIAAqAgAgASoCAF0LVQEBfyAAKAIEIQEDQCABIAAoAghHBEAgACgCEBogACAAKAIIQShrNgIIDAELCyAAKAIABEAgACgCEBogACgCACEBIAAQMigCACAAKAIAaxogARAwCwueAQEEfyAAELcEIAAQKRogAUEEaiIDIgIgAigCACAAKAIEIAAoAgAiBGsiAkFYbUEobGoiBTYCACACQQFOBEAgBSAEIAIQZRoLIAAgAxA2IABBBGogAUEIahA2IAAQKSABEDIQNiABIAEoAgQ2AgAgABCCARogACgCABogACgCACAAEKUBQShsahogACgCACAAEKUBQShsahogACgCABoLkwEBA38jAEEQayICJAAgAiABNgIMAn8jAEEQayIDJAAgABApGiADQebMmTM2AgwgA0H/////BzYCCCADQQxqIANBCGoQvgEoAgAhBCADQRBqJAAgASAETQsEQCAAEKUBIgAgBEEBdkkEQCACIABBAXQ2AgggAkEIaiACQQxqEFgoAgAhBAsgAkEQaiQAIAQPCxB1AAtUAQJ/IwBBEGsiAyQAIAMgADYCACADIAAoAgQiAjYCBCADIAJBKGo2AgggAyECIAAQKSACKAIEIAEQvgIgAiACKAIEQShqNgIEIAIQaCADQRBqJAALNQAgACgCABogACgCACAAEKUBQShsahogACgCACAAEIIBQShsahogACgCACAAEKUBQShsahoLVQECfyAAELcEIAAoAgAEQCAAKAIAIQIgACgCBCEBA0AgASACRwRAIAAQKRogAUEoayEBDAELCyAAIAI2AgQgABApGiAAKAIAIQEgABClARogARAwCwsHACAALQAUC1wBAX8jAEEQayIDJAAgAyAAQQhqIgAQKjYCCCADIAAQKzYCAANAIANBCGogAxAsBEAgAygCCCIAQQRqIAEgACoCJCAClBDJAiADQQhqEL0BDAEFIANBEGokAAsLCwkAIAAgATgCJAsHACAAKgIMCyAAIAAgATYCACAAQQRqIAEoAggQtQIaIABBADYCJCAAC0MBAX8jAEEQayIBJAAgABApGiABQf////8DNgIMIAFB/////wc2AgggAUEMaiABQQhqEL4BKAIAIQAgAUEQaiQAIAALDQAgAC8BACABLwEARgsJACABIAIQvwQLoAEBBX8jAEEQayIDJAAgABAyGiABLwEAIQQCQAJAIAAQVSIFRQ0AIAAgBCAFEDsiBhAuKAIAIgJFDQADQCACKAIAIgJFDQEgBCACKAIERwRAIAIoAgQgBRA7IAZHDQILIAQgAigCBEcNACAAEEUgAkEIaiABEMAERQ0ACyADQQhqIAIQQSgCACECDAELIAMQkwEiAjYCCAsgA0EQaiQAIAILCQAgACABEMcCCykBAX8jAEEQayICJAAgAkEIaiAAIAEQwQQQQSgCACEAIAJBEGokACAACwoAIABB6ABqEC8L+AIBC38gAUE8EFEiAkUEQEEBDwsCfyACKAIEEPEDIgsEQCACKAIEIQIjAEEQayIFJAAgBSAANgIMIAVBDGohCQJAIAJBEGoiAygCBCADECkoAgBHBEAgAyAJEEsMAQsjAEEgayIKJAAgAxApIgYCfyADIAMQL0EBahBKIQQgAxAvIQwjAEEQayIHJAAgB0EANgIMIApBCGoiAkEMaiAHQQxqIAYQRyAEBEAgAigCEBogBEH/////A0sEQBBGAAsgBEECdBAnIQgLIAIgCDYCACACIAggDEECdGoiBjYCCCACIAY2AgQgAhAyIAggBEECdGo2AgAgB0EQaiQAIAIoAggLIAkQSCACIAIoAghBBGo2AgggAyACEEwgAhBJIApBIGokAAsgBUEQaiQAC0ECIAtFDQAaQQEgAUEBEFEiAUUNABogASgCBBDEBCECAkAgACgCBEEASA0AIAIgACgCBE0NACAAIAEoAgQgACgCBBCKAjYCCAtBAAsLBwAgAC0AKAsaACAAEMkEIABBkDM2AgAgAEGAxgA2AgAgAAshACAAEMoEIABBADYCDCAAQdAyNgIAIABBwMUANgIAIAALHgAgABBpIABBfzYCBCAAQaAyNgIAIABBiMUANgIACx4AIAAQyQQgAEEANgIIIABB5DE2AgAgAEGoMTYCAAsEAEEBCxoAIAFBmwFGBEAgACACEDU2AgQLIAFBmwFGCyAAIAFBnAFGBEAgACACEDU2AghBAQ8LIAAgASACEMwECxMAIAAgASgCCDYCCCAAIAEQ7gELGgAgABDKBCAAQewwNgIAIABBzMQANgIAIAALVgACQAJAAkACQAJAIAFBlwFrDgoAAQQEBAQEAgQDBAsgACACEDU2AgRBAQ8LIAAgAhA1NgIIQQEPCyAAIAIQNTYCDEEBDwsgACACEDU2AhBBAQ8LQQALGQAgABDMAiAAQdAvNgIAIABBgDA2AgAgAAsgACAAEMwCIABBADYCECAAQeguNgIAIABBnC82AgAgAAswACAAENUEIABBuC42AgAgAEG0wgA2AgAgAEEQahA6GiAAQQA2AiQgAEIANwIcIAALEwAgACABKgJ4OAJ4IAAgARCaBAshACAAEGkgAEGELjYCACAAQQRqQawuEJQBIABB1C02AgALIAAgABDMAiAAQQA6ABAgAEG8LDYCACAAQfAsNgIAIAALKwAgABDvARogAEGMLDYCACAAQZjAADYCACAAQRBqEDoaIABBHGoQOhogAAtHACAAEO8BGiAAQQA6ACggAEJ/NwIgIABCgICA/AM3AhggAEK8gICAwAc3AhAgAEHAKzYCACAAQew+NgIAIABBLGoQOhogAAsgACAAEM4CIABBfzYCGCAAQfwqNgIAIABBtD02AgAgAAsgACAAEM4CIABBADYCGCAAQbgqNgIAIABB8Dw2AgAgAAsgACAAIAEoAgQ2AgQgACABKAIINgIIIAAgASgCDDYCDAsTACAAIAEoAhg2AhggACABENsECyAAIAAQzgIgAEEANgIYIABBvCk2AgAgAEGsPDYCACAACycAIAAQaSAAQQA2AgQgAEGMKTYCACAAQfg6NgIAIABBCGoQOhogAAsnACAAEGkgAEEANgIEIABB3Cg2AgAgAEGEOjYCACAAQQhqEDoaIAALGgAgABCnARogAEH8JzYCACAAQawoNgIAIAALGgAgABCnARogAEGcJzYCACAAQcwnNgIAIAALMgAgABBpIABC4fXR+IOAgMA/NwIMIABCvZTc9gM3AgQgAEHgJjYCACAAQcg5NgIAIAALGgAgABCnARogAEGAJjYCACAAQbAmNgIAIAALFgAgABBpIABB1CU2AgAgAEGoJTYCAAsEAEEACygAIAAQpwEaIABBfzYCECAAQcgkNgIAIABBADYCFCAAQcgzNgIAIAALNgEBfyMAQRBrIgMkACABQTdGBEAgAyACEMgBIABBBGogAxDLAiADEG8LIANBEGokACABQTdGCzoAIAAQ8gQgAEEBOgBEIABBADYCQCAAQoCAgPwDNwI4IABBtCI2AgAgAEEANgJIIABByPoANgIAIAALEgAgACABKAIwNgIwIAAgARBnCzgBAX8gABBzIABB9OjRezYCMCAAQfAhNgIAIABBNGoQ7gQhASAAQfT5ADYCACABQbz6ADYCACAACwwAIAAQ0QIaIAAQMAssACAAENICGiAAQeQhNgJEIABBiCE2AgAgAEGY+QA2AkQgAEG8+AA2AgAgAAtOACAAEJUBIABCgICA/IOAgMA/NwI4IABCgICAgICAgMA/NwIwIABBoAo2AgAgAEGY9QA2AgAgAEFAaxBUGiAAQdgAahBUGiAAQgA3AnALHgAgAEEANgIMIABCgICA/AM3AgQgAEH8IDYCACAACzoAIAAgASoCMDgCMCAAIAEqAjQ4AjQgACABKgI4OAI4IAAgASoCPDgCPCAAIAEqAkA4AkAgACABEGcLJAAgABBzIABC/////w83AjAgAEHgHzYCACAAQcj2ADYCACAACy8BAX8jAEEQayIBJAAgAEIANwIAIAFBADYCDCAAQQhqIAFBDGoQvQIgAUEQaiQACyYAIAAQlQEgAEEBOgAuIABBnB82AgAgAEIANwIwIABBpPkANgIACxIAIAAgAS0ALjoALiAAIAEQZwshACAAEPIEIABBADYCOCAAQcgeNgIAIABB9PUANgIAIAALDAAgABCRAhogABAwCxkAIABB7Bo2AgAgAEGIAWoQPiAAEEMaIAALOgACQAJAAkAgAUH9AGsOAgABAgsgACACEDU2AqgBQQEPCyAAIAIQMbY4AqwBQQEPCyAAIAEgAhDhAgshACAAIAEoAqgBNgKoASAAIAEq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AigCACIBQQRqNgIAIAAgATMBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATAAADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATEAADcDAA8LIAIgAigCAEEHakF4cSIBQQhqNgIAIAAgASsDADkDAA8LIAAgAiADEQMACwtSAQN/AkAgACgCACwAABDBAUUEQAwBCwNAIAAoAgAiAiwAACEDIAAgAkEBajYCACABIANqQTBrIQEgAiwAARDBAUUNASABQQpsIQEMAAsACyABC9YCAQN/IwBB0AFrIgUkACAFIAI2AswBQQAhAiAFQaABakEAQSgQMxogBSAFKALMATYCyAECQEEAIAEgBUHIAWogBUHQAGogBUGgAWogAyAEEOMCQQBIDQAgACgCTEEATiECIAAoAgAhBiAALABKQQBMBEAgACAGQV9xNgIACyAGQSBxIQcCfyAAKAIwBEAgACABIAVByAFqIAVB0ABqIAVBoAFqIAMgBBDjAgwBCyAAQdAANgIwIAAgBUHQAGo2AhAgACAFNgIcIAAgBTYCFCAAKAIsIQYgACAFNgIsIAAgASAFQcgBaiAFQdAAaiAFQaABaiADIAQQ4wIgBkUNABogAEEAQQAgACgCJBEEABogAEEANgIwIAAgBjYCLCAAQQA2AhwgAEEANgIQIAAoAhQaIABBADYCFEEACxogACAAKAIAIAdyNgIAIAJFDQALIAVB0AFqJAALfwIBfwF+IAC9IgNCNIinQf8PcSICQf8PRwR8IAJFBEAgASAARAAAAAAAAAAAYQR/QQAFIABEAAAAAAAA8EOiIAEQiQUhACABKAIAQUBqCzYCACAADwsgASACQf4HazYCACADQv////////+HgH+DQoCAgICAgIDwP4S/BSAACwuVDwITfwJ8IwBBEGsiCiQAAkAgALwiEEH/////B3EiA0Han6TuBE0EQCABIAC7IhUgFUSDyMltMF/kP6JEAAAAAAAAOEOgRAAAAAAAADjDoCIVRAAAAFD7Ifm/oqAgFURjYhphtBBRvqKgOQMAIBWZRAAAAAAAAOBBYwRAIBWqIQMMAgtBgICAgHghAwwBCyADQYCAgPwHTwRAIAEgACAAk7s5AwBBACEDDAELIAogAyADQRd2QZYBayIDQRd0a767OQMIIwBBsARrIgUkACADIANBA2tBGG0iAkEAIAJB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CwsJACAAEPYCEDALIgAgAUEKa0H//wNxIgBBGk0EQEGTgIAgIAB2QQFxDwtBAAsbAQF/IAAoAjAiASAAKAJAIAEoAgAoAgwRAwALGwEBfyAAKAIwIgEgACgCPCABKAIAKAIQEQMACxsBAX8gACgCMCIBIAAqAjggASgCACgCCBEIAAtJAQF/IAAtAC4EQCABAn8gACgCSCIDBEAgAyACIAMoAgAoAgARAQAhAgsgAgsgAigCACgCJBEAACAAKAIwIAEoAgAoAhQRBQALC1AAIAAgARD7ASIBQQAgASgCACgCABEDACABIAAqAjggASgCACgCCBEIACABIAAoAjwgASgCACgCEBEDACABIAAoAkAgASgCACgCDBEDACABCwwAQQJBBCAALQBEGwsPACAAIAAoAgAoAjwRAgALCgAgAEE0axD4AgsEAEEkCzMAAkAgACABEGAiAQ0AQQEhASAAQTRqIAAQ+QJFDQAgACAAKAIAKAI8EQIAQQAhAQsgAQvZAgEIfwJ/AkACQAJAIAAoAhQiASABKAIAKAIIEQAAQQFrDgMAAgECCyABQcwAakEAIAEbDAILIAFBoAFqQQAgARshAgsgAgsiAUUEQEEBDwtBACECIwBBEGsiBCQAIAQgADYCDCAEQQxqIQcCQCABQQRqIgEoAgQgARApKAIARwRAIAEgBxBLDAELIwBBIGsiCCQAIAEQKSIFAn8gASABEC9BAWoQSiEDIAEQLyEJIwBBEGsiBiQAIAZBADYCDCAIQQhqIgBBDGogBkEMaiAFEEcgAwRAIAAoAhAaIANB/////wNLBEAQRgALIANBAnQQJyECCyAAIAI2AgAgACACIAlBAnRqIgU2AgggACAFNgIEIAAQMiACIANBAnRqNgIAIAZBEGokACAAKAIICyAHEEggACAAKAIIQQRqNgIIIAEgABBMIAAQSSAIQSBqJAALIARBEGokAEEACzgAIAAoAkwiACABQQAQJioCACABQQEQJioCACACQQAQJioCACACQQEQJioCACAAKAIAKAIcEREACwkAIAAQ0QIQMAsLACAAQcQAaxD/AQs4ACAAKAJMIgAgAUEAECYqAgAgAUEBECYqAgAgAkEAECYqAgAgAkEBECYqAgAgACgCACgCGBERAAsNACAAKgI0IAEqAjRdC6kDAgV/An0jAEEgayIDJAAgAUGA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BAsJACAAQQA6AAwLBABBLgsXACAALQAMRQRAIABBAToADCAAELECCwsZACABIAAqAgxcBEAgACABOAIMIAAQsQILCxkAIAEgAC0ADEcEQCAAIAE6AAwgABCxAgsLCQAgACgCCBA9Cx0AIAFBNRBRIgFFBEBBAQ8LIAEoAgQgABCRBEEAC0ABAX8gAUEBEFEiAQR/IAEoAgQhAiMAQRBrIgEkACABIAA2AgwgAkH0AGogAUEMahDUASABQRBqJABBAAVBAQsLzgEBA38jAEEQayICJAAgAiAAQRxqIgMQKjYCCCACIAMQKzYCAANAAkAgAkEIaiACECwiBEUNACACKAIIKAIAIgMgASADKAIAKAIcEQEAIgMNACACQQhqEC0MAQsLAkAgBEUEQCACIABBEGoiABAqNgIIIAIgABArNgIAA0AgAkEIaiACECxFBEBBACEDDAMLIAIoAggoAgAiACABIAAoAgAoAhwRAQAiAw0CIAJBCGoQLQwACwALIAJBEGokACADQf8BcQ8LIAJBEGokACADC84BAQN/IwBBEGsiAiQAIAIgAEEcaiIDECo2AgggAiADECs2AgADQAJAIAJBCGogAhAsIgRFDQAgAigCCCgCACIDIAEgAygCACgCGBEBACIDDQAgAkEIahAtDAELCwJAIARFBEAgAiAAQRBqIgAQKjYCCCACIAAQKzYCAANAIAJBCGogAhAsRQRAQQAhAwwDCyACKAIIKAIAIgAgASAAKAIAKAIYEQEAIgMNAiACQQhqEC0MAAsACyACQRBqJAAgA0H/AXEPCyACQRBqJAAgAwsJACAAEJMEEDALBwAgACgCJAsHACAAKAIgC0ABAX8gAUEBEFEiAQR/IAEoAgQhAiMAQRBrIgEkACABIAA2AgwgAkHoAGogAUEMahDUASABQRBqJABBAAVBAQsLRgECf0HgABAnQQBB4AAQMxCUBCICIgEgACgCQDYCQCABIAAoAkQ2AkQgASAAKAJINgJIIAEgACgCTDYCTCABIAAQswIgAgtqAQF/IwBBEGsiAiQAIAIgAEEsaiIAECo2AgggAiAAECs2AgADQAJAIAJBCGogAhAsRQRAQQAhAAwBCyACKAIIKAIAIgAgASAAKAIAKAIcEQEAIgANACACQQhqEC0MAQsLIAJBEGokACAAC2oBAX8jAEEQayICJAAgAiAAQSxqIgAQKjYCCCACIAAQKzYCAANAAkAgAkEIaiACECxFBEBBACEADAELIAIoAggoAgAiACABIAAoAgAoAhgRAQAiAA0AIAJBCGoQLQwBCwsgAkEQaiQAIAALCQAgABCYBBAwCwsAQQgQJyAAEIcEC2oBAX8jAEEQayICJAAgAiAAQQRqIgAQKjYCCCACIAAQKzYCAANAAkAgAkEIaiACECxFBEBBACEADAELIAIoAggoAgAiACABIAAoAgAoAhwRAQAiAA0AIAJBCGoQLQwBCwsgAkEQaiQAIAALagEBfyMAQRBrIgIkACACIABBBGoiABAqNgIIIAIgABArNgIAA0ACQCACQQhqIAIQLEUEQEEAIQAMAQsgAigCCCgCACIAIAEgACgCACgCGBEBACIADQAgAkEIahAtDAELCyACQRBqJAAgAAsJACAAEOIBEDALDgAgASACIAAoAhgQnwQLDgAgASACIAAoAhgQnwQLBwAgACoCOAsHACAAKgI0CwcAIAAqAjALSgEBfyADIAAqAhSTIAQqAhQgACoCFJOVIQMgACgCECIGBEAgBiADEK4EIQMLIAEgAiAFIAAqAhggAyAEKgIYIAAqAhiTlJIQpwQLBwAgACoCGAsQACABIAIgAyAAKgIYEKcECwcAIAAoAhALRQEBfyADIAAqAhSTIAQqAhQgACoCFJOVIQMgACgCECIGBEAgBiADEK4EIQMLIAEgAiAFIAAoAhggBCgCGCADEP8CEKkECxAAIAEgAiADIAAoAhgQqQQLtAIBCH8gAUEaEFEiAUUEQEEBDwsgACAAKAIEsiABKAIEKAIQspU4AhQgASgCCCEBIwBBEGsiBCQAIAQgADYCDCAEQQxqIQcCQCABQQhqIgEoAgQgARApKAIARwRAIAEgBxBLDAELIwBBIGsiCCQAIAEQKSIFAn8gASABEC9BAWoQSiEDIAEQLyEJIwBBEGsiBiQAIAZBADYCDCAIQQhqIgBBDGogBkEMaiAFEEcgAwRAIAAoAhAaIANB/////wNLBEAQRgALIANBAnQQJyECCyAAIAI2AgAgACACIAlBAnRqIgU2AgggACAFNgIEIAAQMiACIANBAnRqNgIAIAZBEGokACAAKAIICyAHEEggACAAKAIIQQRqNgIIIAEgABBMIAAQSSAIQSBqJAALIARBEGokAEEAC0wBAX9BASECAkAgACgCDEEBTgRAIAEgACgCDCABKAIAKAIAEQEAIgFFDQEgAUEcIAEoAgAoAgwRAQBFDQEgACABNgIQC0EAIQILIAILnwIBCH8gAUEZEFEiAUUEQEEBDwsgASgCBCEBIwBBEGsiBCQAIAQgADYCDCAEQQxqIQcCQCABQQhqIgEoAgQgARApKAIARwRAIAEgBxBLDAELIwBBIGsiCCQAIAEQKSIFAn8gASABEC9BAWoQSiEDIAEQLyEJIwBBEGsiBiQAIAZBADYCDCAIQQhqIgBBDGogBkEMaiAFEEcgAwRAIAAoAhAaIANB/////wNLBEAQRgALIANBAnQQJyECCyAAIAI2AgAgACACIAlBAnRqIgU2AgggACAFNgIEIAAQMiACIANBAnRqNgIAIAZBEGokACAAKAIICyAHEEggACAAKAIIQQRqNgIIIAEgABBMIAAQSSAIQSBqJAALIARBEGokAEEAC2oBAX8jAEEQayICJAAgAiAAQQhqIgAQKjYCCCACIAAQKzYCAANAAkAgAkEIaiACECxFBEBBACEADAELIAIoAggoAgAiACABIAAoAgAoAhwRAQAiAA0AIAJBCGoQLQwBCwsgAkEQaiQAIAALagEBfyMAQRBrIgIkACACIABBCGoiABAqNgIIIAIgABArNgIAA0ACQCACQQhqIAIQLEUEQEEAIQAMAQsgAigCCCgCACIAIAEgACgCACgCGBEBACIADQAgAkEIahAtDAELCyACQRBqJAAgAAsHACAAKgIUCwkAIAAQqgQQMAufAgEIfyABQR8QUSIBRQRAQQEPCyABKAIEIQEjAEEQayIDJAAgAyAANgIMIANBDGohBwJAIAFBLGoiASgCBCABECkoAgBHBEAgASAHEEsMAQsjAEEgayIIJAAgARApIgQCfyABIAEQL0EBahBKIQIgARAvIQkjAEEQayIFJAAgBUEANgIMIAhBCGoiAEEMaiAFQQxqIAQQRyACBEAgACgCEBogAkH/////A0sEQBBGAAsgAkECdBAnIQYLIAAgBjYCACAAIAYgCUECdGoiBDYCCCAAIAQ2AgQgABAyIAYgAkECdGo2AgAgBUEQaiQAIAAoAggLIAcQSCAAIAAoAghBBGo2AgggASAAEEwgABBJIAhBIGokAAsgA0EQaiQAQQALXgEBfyMAQRBrIgIkACACIABB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CyABQR9HBEAgACABIAIQ4QIPCyAAIAIQMbY4AqwBQQELJgAgAUECayIAQf//A3FBJE0EQEKhzoCAgAIgAK2Ip0EBcQ8LQQALBABBBwtTAQJ/QbwDECcQsgMiAiIBIAAtAKgBOgCoASABIAAqAqwBOAKsASABIAAqArABOAKwASABIAAqArQBOAK0ASABIAAqArgBOAK4ASABIAAQ9AEgAgsoACABQQJrIgBB//8DcUExTQRAQoHOgICAgoABIACtiKdBAXEPC0EACwQAQTMLFQEBf0GwARAnEJICIgEgABD4BCABCyYAIAFBAmsiAEH//wNxQSRNBEBCgY6AgIACIACtiKdBAXEPC0EACwQAQQwLIQAgAUEgRgRAIAAgAhCHAToAmAFBAQ8LIAAgASACENwCCyYAIAFBAmsiAEH//wNxQSRNBEBCgY6BgIACIACtiKdBAXEPC0EACwQAQRALLAECf0GkARAnQQBBpAEQMyIBEPoEIQIgASAALQCYAToAmAEgASAAEJQFIAILIgEBfiABIAKtIAOtQiCGhCAEIAARIAAiBUIgiKcQFiAFpwsHACAAKgJ8CwMAAAszAQF/IAAoAhQiAyABIAIgACgCECADayIBIAEgAksbIgEQZRogACAAKAIUIAFqNgIUIAILjwUCBn4BfyABIAEoAgBBD2pBcHEiAUEQajYCACAAAnwgASkDACEEIAEpAwghBSMAQSBrIgAkAAJAIAVC////////////AIMiA0KAgICAgIDAgDx9IANCgICAgICAwP/DAH1UBEAgBUIEhiAEQjyIhCEDIARC//////////8PgyIEQoGAgICAgICACFoEQCADQoGAgICAgICAwAB8IQIMAgsgA0KAgICAgICAgEB9IQIgBEKAgICAgICAgAiFQgBSDQEgAiADQgGDfCECDAELIARQIANCgICAgICAwP//AFQgA0KAgICAgIDA//8AURtFBEAgBUIEhiAEQjyIhEL/////////A4NCgICAgICAgPz/AIQhAgwBC0KAgICAgICA+P8AIQIgA0L///////+//8MAVg0AQgAhAiADQjCIpyIBQZH3AEkNACAEIQIgBUL///////8/g0KAgICAgIDAAIQiAyEGAkAgAUGB9wBrIghBwABxBEAgAiAIQUBqrYYhBkIAIQIMAQsgCEUNACAGIAitIgeGIAJBwAAgCGutiIQhBiACIAeGIQILIAAgAjcDECAAIAY3AxgCQEGB+AAgAWsiAUHAAHEEQCADIAFBQGqtiCEEQgAhAwwBCyABRQ0AIANBwAAgAWuthiAEIAGtIgKIhCEEIAMgAoghAwsgACAENwMAIAAgAzcDCCAAKQMIQgSGIAApAwAiBEI8iIQhAiAAKQMQIAApAxiEQgBSrSAEQv//////////D4OEIgRCgYCAgICAgIAIWgRAIAJCAXwhAgwBCyAEQoCAgICAgICACIVCAFINACACQgGDIAJ8IQILIABBIGokACACIAVCgICAgICAgICAf4OEvws5AwALqBcDEn8CfgF8IwBBsARrIgkkACAJQQA2AiwCfyABvSIYQn9XBEBBASESIAGaIgG9IRhB4LQBDAELQQEhEkHjtAEgBEGAEHENABpB5rQBIARBAXENABpBACESQQEhE0HhtAELIRQCQCAYQoCAgICAgID4/wCDQoCAgICAgID4/wBRBEAgAEEgIAIgEkEDaiINIARB//97cRBWIAAgFCASEE8gAEH7tAFB/7QBIAVBIHEiAxtB87QBQfe0ASADGyABIAFiG0EDEE8MAQsgCUEQaiEPAkACfwJAIAEgCUEsahCJBSIBIAGgIgFEAAAAAAAAAABiBEAgCSAJKAIsIgZBAWs2AiwgBUEgciIVQeEARw0BDAMLIAVBIHIiFUHhAEYNAiAJKAIsIQtBBiADIANBAEgbDAELIAkgBkEdayILNgIsIAFEAAAAAAAAsEGiIQFBBiADIANBAEgbCyEKIAlBMGogCUHQAmogC0EASBsiDiEIA0AgCAJ/IAFEAAAAAAAA8EFjIAFEAAAAAAAAAABmcQRAIAGrDAELQQALIgM2AgAgCEEEaiEIIAEgA7ihRAAAAABlzc1BoiIBRAAAAAAAAAAAYg0ACwJAIAtBAUgEQCALIQMgCCEGIA4hBwwBCyAOIQcgCyEDA0AgA0EdIANBHUgbIQwCQCAIQQRrIgYgB0kNACAMrSEZQgAhGANAIAYgBjUCACAZhiAYfCIYIBhCgJTr3AOAIhhCgJTr3AN+fT4CACAHIAZBBGsiBk0EQCAYQv////8PgyEYDAELCyAYpyIDRQ0AIAdBBGsiByADNgIACwNAIAcgCCIGSQRAIAZBBGsiCCgCAEUNAQsLIAkgCSgCLCAMayIDNgIsIAYhCCADQQBKDQALCyAKQRlqQQltIQggA0F/TARAIAhBAWohESAVQeYARiENA0BBCUEAIANrIANBd0gbIRYCQCAGIAdLBEBBgJTr3AMgFnYhF0F/IBZ0QX9zIRBBACEDIAchCANAIAggAyAIKAIAIgwgFnZqNgIAIAwgEHEgF2whAyAIQQRqIgggBkkNAAsgByAHQQRqIAcoAgAbIQcgA0UNASAGIAM2AgAgBkEEaiEGDAELIAcgB0EEaiAHKAIAGyEHCyAJIAkoAiwgFmoiAzYCLCAOIAcgDRsiCCARQQJ0aiAGIAYgCGtBAnUgEUobIQYgA0EASA0ACwtBACEIAkAgBiAHTQ0AIA4gB2tBAnVBCWwhCCAHKAIAIgxBCkkNAEHkACEDA0AgCEEBaiEIIAMgDEsNASADQQpsIQMMAAsACyAKQQAgCCAVQeYARhtrIBVB5wBGIApBAEdxayIDIAYgDmtBAnVBCWxBCWtIBEAgA0GAyABqIhBBCW0iDEECdCAJQTBqQQRyIAlB1AJqIAtBAEgbakGAIGshDUEKIQMCQCAQIAxBCWxrIgxBB0oNAEHkACEDA0AgDEEBaiIMQQhGDQEgA0EKbCEDDAALAAsCQCANKAIAIgwgDCADbiIRIANsayIQRUEAIA1BBGoiCyAGRhsNAEQAAAAAAADgP0QAAAAAAADwP0QAAAAAAAD4PyAGIAtGG0QAAAAAAAD4PyAQIANBAXYiC0YbIAsgEEsbIRpEAQAAAAAAQENEAAAAAAAAQEMgEUEBcRshAQJAIBMNACAULQAAQS1HDQAgGpohGiABmiEBCyANIAwgEGsiCzYCACABIBqgIAFhDQAgDSADIAtqIgM2AgAgA0GAlOvcA08EQANAIA1BADYCACAHIA1BBGsiDUsEQCAHQQRrIgdBADYCAAsgDSANKAIAQQFqIgM2AgAgA0H/k+vcA0sNAAsLIA4gB2tBAnVBCWwhCCAHKAIAIgtBCkkNAEHkACEDA0AgCEEBaiEIIAMgC0sNASADQQpsIQMMAAsACyANQQRqIgMgBiADIAZJGyEGCwNAIAYiCyAHTSIMRQRAIAtBBGsiBigCAEUNAQsLAkAgFUHnAEcEQCAEQQhxIRMMAQsgCEF/c0F/IApBASAKGyIGIAhKIAhBe0pxIgMbIAZqIQpBf0F+IAMbIAVqIQUgBEEIcSITDQBBdyEGAkAgDA0AIAtBBGsoAgAiA0UNAEEAIQYgA0EKcA0AQQAhDEHkACEGA0AgAyAGcEUEQCAMQQFqIQwgBkEKbCEGDAELCyAMQX9zIQYLIAsgDmtBAnVBCWwhAyAFQV9xQcYARgRAQQAhEyAKIAMgBmpBCWsiA0EAIANBAEobIgMgAyAKShshCgwBC0EAIRMgCiADIAhqIAZqQQlrIgNBACADQQBKGyIDIAMgCkobIQoLIAogE3IiF0EARyEQIABBICACAn8gCEEAIAhBAEobIAVBX3EiDEHGAEYNABogDyAIIAhBH3UiA2ogA3OtIA8QqAEiBmtBAUwEQANAIAZBAWsiBkEwOgAAIA8gBmtBAkgNAAsLIAZBAmsiESAFOgAAIAZBAWtBLUErIAhBAEgbOgAAIA8gEWsLIAogEmogEGpqQQFqIg0gBBBWIAAgFCASEE8gAEEwIAIgDSAEQYCABHMQVgJAAkACQCAMQcYARgRAIAlBEGpBCHIhAyAJQRBqQQlyIQggDiAHIAcgDksbIgUhBwNAIAc1AgAgCBCoASEGAkAgBSAHRwRAIAYgCUEQak0NAQNAIAZBAWsiBkEwOgAAIAYgCUEQaksNAAsMAQsgBiAIRw0AIAlBMDoAGCADIQYLIAAgBiAIIAZrEE8gB0EEaiIHIA5NDQALIBcEQCAAQYO1AUEBEE8LIApBAUggByALT3INAQNAIAc1AgAgCBCoASIGIAlBEGpLBEADQCAGQQFrIgZBMDoAACAGIAlBEGpLDQALCyAAIAYgCkEJIApBCUgbEE8gCkEJayEGIAdBBGoiByALTw0DIApBCUohAyAGIQogAw0ACwwCCwJAIApBAEgNACALIAdBBGogByALSRshBSAJQRBqQQlyIQsgCUEQakEIciEDIAchCANAIAsgCDUCACALEKgBIgZGBEAgCUEwOgAYIAMhBgsCQCAHIAhHBEAgBiAJQRBqTQ0BA0AgBkEBayIGQTA6AAAgBiAJQRBqSw0ACwwBCyAAIAZBARBPIAZBAWohBiATRUEAIApBAUgbDQAgAEGDtQFBARBPCyAAIAYgCyAGayIGIAogBiAKSBsQTyAKIAZrIQogCEEEaiIIIAVPDQEgCkF/Sg0ACwsgAEEwIApBEmpBEkEAEFYgACARIA8gEWsQTwwCCyAKIQYLIABBMCAGQQlqQQlBABBWCwwBCyAUQQlqIBQgBUEgcSILGyEKAkAgA0ELSw0AQQwgA2siBkUNAEQAAAAAAAAgQCEaA0AgGkQAAAAAAAAwQKIhGiAGQQFrIgYNAAsgCi0AAEEtRgRAIBogAZogGqGgmiEBDAELIAEgGqAgGqEhAQsgDyAJKAIsIgYgBkEfdSIGaiAGc60gDxCoASIGRgRAIAlBMDoADyAJQQ9qIQYLIBJBAnIhDiAJKAIsIQggBkECayIMIAVBD2o6AAAgBkEBa0EtQSsgCEEASBs6AAAgBEEIcSEIIAlBEGohBwNAIAciBQJ/IAGZRAAAAAAAAOBBYwRAIAGqDAELQYCAgIB4CyIGQdC0AWotAAAgC3I6AAAgBUEBaiIHIAlBEGprQQFHIAggA0EASnJFQQAgASAGt6FEAAAAAAAAMECiIgFEAAAAAAAAAABhG3JFBEAgBUEuOgABIAVBAmohBwsgAUQAAAAAAAAAAGINAAsgAEEgIAIgDiAPIAlBEGogDGprIAdqIAMgD2ogDGtBAmogA0UgByAJa0ESayADTnIbIgNqIg0gBBBWIAAgCiAOEE8gAEEwIAIgDSAEQYCABHMQViAAIAlBEGogByAJQRBqayIFEE8gAEEwIAMgBSAPIAxrIgNqa0EAQQAQViAAIAwgAxBPCyAAQSAgAiANIARBgMAAcxBWIAlBsARqJAAgAiANIAIgDUobCyYAIAFBAmsiAEH//wNxQSRNBEBChc6AgIACIACtiKdBAXEPC0EAC9QCAQd/IwBBIGsiAyQAIAMgACgCHCIENgIQIAAoAhQhBSADIAI2AhwgAyABNgIYIAMgBSAEayIBNgIUIAEgAmohBEECIQcgA0EQaiEBAn8CQAJAIAAoAjwgA0EQakECIANBDGoQDhDgAkUEQANAIAQgAygCDCIFRg0CIAVBf0wNAyABIAUgASgCBCIISyIGQQN0aiIJIAUgCEEAIAYbayIIIAkoAgBqNgIAIAFBDEEEIAYbaiIJIAkoAgAgCGs2AgAgBCAFayEEIAAoAjwgAUEIaiABIAYbIgEgByAGayIHIANBDGoQDhDgAkUNAAsLIARBf0cNAQsgACAAKAIsIgE2AhwgACABNgIUIAAgASAAKAIwajYCECACDAELIABBADYCHCAAQgA3AxAgACAAKAIAQSByNgIAQQAgB0ECRg0AGiACIAEoAgRrCyEEIANBIGokACAECwkAIAAoAjwQGAtCAQF/IwBBEGsiAyQAIAAoAjwgAacgAUIgiKcgAkH/AXEgA0EIahAVEOACIQAgAykDCCEBIANBEGokAEJ/IAEgABsLBABBBAsnAQF/IwBBEGsiASQAIAEgADYCDCABKAIMIQAQkQUgAUEQaiQAIAAL+gEBBH8jAEHwAGsiAiQAIAIgADYCbCACIAIoAmw2AgAjAEEQayIDJAAgAyACNgIMIwBBoAFrIgAkACAAQQhqQYi1AUGQARBlGiAAIAJBEGoiATYCNCAAIAE2AhwgAEF+IAFrIgRB/////wcgBEH/////B0kbIgQ2AjggACABIARqIgE2AiQgACABNgIYIABBCGpBopQBIAJB6ghB6wgQiAUgBARAIAAoAhwiASABIAAoAhhGa0EAOgAACyAAQaABaiQAIANBEGokAAJ/QQAgAkEQaiIAEPwEQQFqIgEQ8gEiA0UNABogAyAAIAEQZQshACACQfAAaiQAIAALLwEBfyMAQRBrIgMkACADIAEgAiAAKAIAEQUAIAMQkwUhACADEG8gA0EQaiQAIAALOQEBfyAAKAIEIgRBAXUgAWohASAAKAIAIQAgASACIAMgBEEBcQR/IAEoAgAgAGooAgAFIAALERQACzcBAX8gACgCBCIDQQF1IAFqIQEgACgCACEAIAEgAiADQQFxBH8gASgCACAAaigCAAUgAAsRGQALOwEBfyAAKAIEIgVBAXUgAWohASAAKAIAIQAgASACIAMgBCAFQQFxBH8gASgCACAAaigCAAUgAAsRFgALNwEBfyAAKAIEIgNBAXUgAWohASAAKAIAIQAgASACIANBAXEEfyABKAIAIABqKAIABSAACxEeAAszAQF/IAAoAgAhAiAAKAIEIgBBAXUgAWoiASAAQQFxBH8gASgCACACaigCAAUgAgsRAAALDAAgABCVBRogABAwCwsAIABBxoABEIYBC8YBAQN/IwBBEGsiAyQAIAMgAjgCCCADIAE2AgwgACgCCCEAIwBBEGsiASQAAn8CQEGYvwEtAABBAXENAEGYvwEQU0UNACMAQRBrIgQkAEEDQYSRARADIQUgBEEQaiQAQZS/ASAFNgIAQZi/ARBSC0GUvwEoAgALIABBvoABAn8jAEEQayIAJAAgACABNgIMIABBDGogA0EMaigCABB3IABBDGogA0EIaioCABBdIABBEGokACABCxAEIAFBEGokACADQRBqJAALSgEBfyMAQRBrIgUkACAFIAI4AgggBSABOAIMIAUgAzgCBCAFIAQ4AgAgAEGvgAEgBUEMaiAFQQhqIAVBBGogBRCWBSAFQRBqJAALSgEBfyMAQRBrIgUkACAFIAI4AgggBSABOAIMIAUgAzgCBCAFIAQ4AgAgAEGggAEgBUEMaiAFQQhqIAVBBGogBRCWBSAFQRBqJAALkgEBA38jAEEQayICJAAgAiABNgIMIAAoAgghASMAQRBrIgAkAAJ/AkBBiL8BLQAAQQFxDQBBiL8BEFNFDQAjAEEQayIDJABBAkHgkAEQAyEEIANBEGokAEGEvwEgBDYCAEGIvwEQUgtBhL8BKAIACyABQZaAASAAQQhqIAJBDGoQqQEQBCAAQRBqJAAgAkEQaiQAC5IBAQN/IwBBEGsiAiQAIAIgATYCDCAAKAIIIQEjAEEQayIAJAACfwJAQYC/AS0AAEEBcQ0AQYC/ARBTRQ0AIwBBEGsiAyQAQQJB2JABEAMhBCADQRBqJABB/L4BIAQ2AgBBgL8BEFILQfy+ASgCAAsgAUGSgAEgAEEIaiACQQxqEKkBEAQgAEEQaiQAIAJBEGokAAuSAQEDfyMAQRBrIgIkACACIAE2AgwgACgCCCEBIwBBEGsiACQAAn8CQEH4vgEtAABBAXENAEH4vgEQU0UNACMAQRBrIgMkAEECQdCQARADIQQgA0EQaiQAQfS+ASAENgIAQfi+ARBSC0H0vgEoAgALIAFBjYABIABBCGogAkEMahCpARAEIABBEGokACACQRBqJAALtQEBBH8jAEEQayICJAAgAiABOAIMIAAoAgghACMAQRBrIgQkAAJ/AkBB8L4BLQAAQQFxDQBB8L4BEFNFDQAjAEEQayIDJABBAkHIkAEQAyEFIANBEGokAEHsvgEgBTYCAEHwvgEQUgtB7L4BKAIACyAAQYOAAQJ/IwBBEGsiACQAIAAgBEEIaiIDNgIMIABBDGogAkEMaioCABBdIABBEGokACADCxAEIARBEGokACACQRBqJAALtQEBA38jAEEQayICJAAgAiABNgIMIAAoAgghACMAQRBrIgEkAAJ/AkBB6L4BLQAAQQFxDQBB6L4BEFNFDQAjAEEQayIDJABBAkHAkAEQAyEEIANBEGokAEHkvgEgBDYCAEHovgEQUgtB5L4BKAIACyAAQeD/AAJ/IwBBEGsiACQAIAAgAUEIaiIDNgIMIABBDGogAkEMaigCABB3IABBEGokACADCxAEIAFBEGokACACQRBqJAALkgEBA38jAEEQayICJAAgAiABNgIMIAAoAgghASMAQRBrIgAkAAJ/AkBB4L4BLQAAQQFxDQBB4L4BEFNFDQAjAEEQayIDJABBAkG4kAEQAyEEIANBEGokAEHcvgEgBDYCAEHgvgEQUgtB3L4BKAIACyABQf3/ACAAQQhqIAJBDGoQqQEQBCAAQRBqJAAgAkEQaiQACz0BAX8gACgCBCIGQQF1IAFqIQEgACgCACEAIAEgAiADIAQgBSAGQQFxBH8gASgCACAAaigCAAUgAAsREQALNwEBfyAAKAIEIgNBAXUgAWohASAAKAIAIQAgASACIANBAXEEfyABKAIAIABqKAIABSAACxEIAAu8AQEDfyMAQRBrIgMkACADIAE2AgwgACgCCCEAIwBBEGsiASQAAn8CQEHMvgEtAABBAXENAEHMvgEQU0UNACMAQRBrIgQkAEEDQdyNARADIQUgBEEQaiQAQci+ASAFNgIAQcy+ARBSC0HIvgEoAgALIABBsv0AAn8jAEEQayIAJAAgACABNgIMIABBDGogA0EMaigCABB3IABBDGogAhCbBRB3IABBEGokACABCxAEIAFBEGokACADQRBqJAALFQEBf0GoBBAnEN8DIgEgABD0ASABCyMAIAFBCmtB//8DcSIAQR5NBEBBg4CAgAcgAHZBAXEPC0EACwsAIABB2f0AEIYBC54CAQR/IwBBIGsiByQAIAcgAjgCGCAHIAE4AhwgByADOAIUIAcgBDgCECAHIAU4AgwgByAGOAIIIAAoAgghACMAQTBrIggkAAJ/AkBBxL4BLQAAQQFxDQBBxL4BEFNFDQAjAEEQayIJJABBB0HAjQEQAyEKIAlBEGokAEHAvgEgCjYCAEHEvgEQUgtBwL4BKAIACyAAQdH9AAJ/IwBBEGsiACQAIAAgCDYCDCAAQQxqIAdBHGoqAgAQXSAAQQxqIAdBGGoqAgAQXSAAQQxqIAdBFGoqAgAQXSAAQQxqIAdBEGoqAgAQXSAAQQxqIAdBDGoqAgAQXSAAQQxqIAdBCGoqAgAQXSAAQRBqJAAgCAsQBCAIQTBqJAAgB0EgaiQACzUBAX8jAEEQayIDJAAgAyACOAIIIAMgATgCDCAAQcr9ACADQQxqIANBCGoQmAUgA0EQaiQACzUBAX8jAEEQayIDJAAgAyACOAIIIAMgATgCDCAAQcP9ACADQQxqIANBCGoQmAUgA0EQaiQACx4AIAAgASABKAIAKAIkEQAAIAIgACgCACgCKBEFAAuSAQEDfyMAQRBrIgIkACACIAE2AgwgACgCCCEBIwBBEGsiACQAAn8CQEG0vgEtAABBAXENAEG0vgEQU0UNACMAQRBrIgMkAEECQaiNARADIQQgA0EQaiQAQbC+ASAENgIAQbS+ARBSC0GwvgEoAgALIAFBuv0AIABBCGogAkEMahCpARAEIABBEGokACACQRBqJAALCwAgAEGs/QAQhgELDAAgABCZBRogABAwCzkAAkACQAJAIAFB0gBrDgIAAQILIAAgAhAxtjgCUEEBDwsgACACEDG2OAJUQQEPCyAAIAEgAhCsAQtBAQF/IAAoAgQiCEEBdSABaiEBIAAoAgAhACABIAIgAyAEIAUgBiAHIAhBAXEEfyABKAIAIABqKAIABSAACxEJAAs5AQF/IAAoAgQiBEEBdSABaiEBIAAoAgAhACABIAIgAyAEQQFxBH8gASgCACAAaigCAAUgAAsRBwALkgEBA38jAEEQayICJAAgAiABNgIMIAAoAgghASMAQRBrIgAkAAJ/AkBBpL4BLQAAQQFxDQBBpL4BEFNFDQAjAEEQayIDJABBAkHoigEQAyEEIANBEGokAEGgvgEgBDYCAEGkvgEQUgtBoL4BKAIACyABQYL9ACAAQQhqIAJBDGoQqQEQBCAAQRBqJAAgAkEQaiQAC8YBAQJ/IwBBEGsiAyQAIAMgAjYCCCADIAE2AgwgACgCCCEAIwBBEGsiASQAAn8CQEGcvgEtAABBAXENAEGcvgEQU0UNACMAQRBrIgIkAEEDQdyKARADIQQgAkEQaiQAQZi+ASAENgIAQZy+ARBSC0GYvgEoAgALIABB+fwAAn8jAEEQayIAJAAgACABNgIMIABBDGogA0EMaigCABB3IABBDGogA0EIaigCABB3IABBEGokACABCxAEIAFBEGokACADQRBqJAALmwEBA38gACgCCCEAIwBBEGsiAyQAAn8CQEGUvgEtAABBAXENAEGUvgEQU0UNACMAQRBrIgIkAEECQdSKARADIQQgAkEQaiQAQZC+ASAENgIAQZS+ARBSC0GQvgEoAgALIABB7/wAAn8jAEEQayIAJAAgACADQQhqIgI2AgwgAEEMaiABEJsFEHcgAEEQaiQAIAILEAQgA0EQaiQACwsAIABB5/wAEIYBCwsAIABB4vwAEIYBCyIAIAFBCmtB//8DcSIAQRpNBEBBk4CAMCAAdkEBcQ8LQQALDAAgABCcBRogABAwCz0BAX8gACgCBCIGQQF1IAFqIQEgACgCACEAIAEgAiADIAQgBSAGQQFxBH8gASgCACAAaigCAAUgAAsRDwALBABBIwsPACABIAAoAgBqIAI4AgALDQAgASAAKAIAaioCAAsYAQF/QRAQJyIAQgA3AgAgAEIANwIIIAALBgAgABA4CwYAQYW+AQsGAEHNvwELBgBBy78BCzcBAX8gASAAKAIEIgNBAXVqIQEgACgCACEAIAEgAiADQQFxBH8gASgCACAAaigCAAUgAAsRAwALBgBByb8BCw8AIABBACAAEN8BQTpGGwsyAQJ/QdgAECdBAEHYABAzEKAFIgIiASAAKgJQOAJQIAEgACoCVDgCVCABIAAQygEgAgsPACAAQQAgABDfAUE4RhsLDwAgAEEAIAAQ3wFBO0YbCwcAIAAvAQALUQECfyMAQRBrIgIkACAAKAIAIQMgAiABIAAoAgQiAEEBdWoiASAAQQFxBH8gASgCACADaigCAAUgAwsRAAA7AQ4gAi8BDiEAIAJBEGokACAACwYAQcO/AQvNAQECfwJAAkACfwNAAkACQCABKAIQIANLBH8gASgCFCADQSxsai0AIEUNAiACIARHDQECf0EAIAEoAhQgA0EsbGooAggiAUUNABogASgCBAsFQQALDAMLIARBAWohBAsgA0EBaiEDDAALAAsiAUUNAAJAAkACQAJAIAEgASgCACgCCBEAAEE9aw4EAAMBAgQLIAAgASgCFBA9EIQFDAQLIABB3JMBEJQBDAMLIABB4pMBEJQBDAILIABB55MBEJQBDAELIABB65MBEJQBCwuYBAIFfwF+QRgQJyEDIAAoAgAhBEEAIQAgA0EAOgAEIAMgBDYCACADIAQQ6wEiATYCCCADQX8gAUECdCABIAFB/////wNxRxsQJzYCDAN/IAAgAU8EfyADIARBEGoQLyIANgIQQX9BfyAArUIsfiIGpyIBQQRqIgIgASACSxsgBkIgiKcbECciASAANgIAIAFBBGohASAABEAgASAAQSxsaiECIAEhAANAIABCADcCACAAQgA3AiQgAEEAOwEgIABCgICA/IOAgMA/NwIYIABCADcADSAAQgA3AgggAEEsaiIAIAJHDQALCyADIAE2AhRBAAVBACEBAkAgBCAAEOABIgJFDQACQAJAAkAgAiACKAIAKAIIEQAAQThrDgQBAwIAAwtBEBAnIgEgAiADELICIAFB0MEANgIAIAEgAi0AEDoADAwCC0EQECciASACIAMQsgIgAUHkwQA2AgAgASACKgIQOAIMDAELQRAQJyIBIAIgAxCyAiABQQA6AAwgAUH4wQA2AgALIAMoAgwgAEECdGogATYCACAAQQFqIQAgAygCCCEBDAELCyEAA0AgAygCECAASwRAIAMoAhQgAEEsbGohASAEQRBqIgIQLyAASwR/IAIgABAuKAIABUEACyICKAIcIgUgBSgCACgCJBEAACEFIAEgAjYCACABIAU2AgQgASACKAIgEJAEGiAAQQFqIQAMAQsLIAML0gEBBH8gAARAAkADQCAAKAIMIQIgACgCCCABTQRAIAIEQCACEDALIAAoAhQiAgRAIAJBBGsiBCgCACIBBEAgAiABQSxsaiEBA0AgAUEsayIBKAIEIgMEQCADIAMoAgAoAgQRAgALIAEoAggiAwRAIAMgAygCACgCBBECAAsgASgCDCIDBEAgAyADKAIAKAIEEQIACyABIAJHDQALCyAEEDALDAILIAIgAUECdGooAgAiAgRAIAIgAigCACgCCBECAAsgAUEBaiEBDAALAAsLIAAQMAtbAAJAAkACQAJAAkAgAUHUAGsOBAABAgMECyAAIAIQMbY4AlBBAQ8LIAAgAhAxtjgCVEEBDwsgACACEDG2OAJYQQEPCyAAIAIQMbY4AlxBAQ8LIAAgASACEKwBCwYAQb+/AQsGAEG9vwELBwAgAC0AGAsOAEEgECcgACgCABC1AgsGAEG6vwELUQECfyMAQRBrIgIkACAAKAIAIQMgAiABIAAoAgQiAEEBdWoiASAAQQFxBH8gASgCACADaigCAAUgAwsRAAA2AgwgAigCDCEAIAJBEGokACAACwYAQbe/AQsGAEG0vwELBgBBsr8BCyMA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qwEAAKwBAAAaAAAALwAAAB8AAAAwAAAApgEAQdQtCyadAQAArQEAAK4BAACvAQAArAEAABoAAAAvAAAAHwAAADAAAACmAQBBhC4LJp0BAACwAQAArgEAAK8BAACsAQAAGgAAAC8AAAAfAAAAMAAAAKYBAEG4LgsmnQEAALEBAACyAQAAswEAAKwBAAC0AQAALwAAAB8AAAAwAAAApgEAQeguCyqdAQAAtQEAALYBAAC3AQAAuAEAALkBAACjAQAApAEAAKUBAACmAQAAugEAQZwvCyqdAQAAuwEAALYBAAC3AQAAuAEAALkBAACjAQAApAEAAKUBAACmAQAAugEAQdAvCyadAQAAvAEAAL0BAAC+AQAArAEAAL8BAACjAQAApAEAAKUBAACmAQBBgDALJp0BAADAAQAAvQEAAL4BAACsAQAAvwEAAKMBAACkAQAApQEAAKYBAEGwMAsyMQAAAMEBAADCAQAAwwEAAMQBAADFAQAALwAAAB8AAAAwAAAAxgEAAMcBAADIAQAAyQEAQewwCzIxAAAAygEAAMsBAADMAQAAzQEAAM4BAADPAQAA0AEAANEBAADSAQAA0wEAANQBAADVAQBBqDELMjEAAADWAQAA1wEAANgBAADNAQAAGgAAAM8BAADQAQAA0QEAANIBAADTAQAA1AEAANUBAEHkMQsyMQAAANkBAADXAQAA2AEAAM0BAAAaAAAAzwEAANABAADRAQAA0gEAANMBAADUAQAA1QEAQaAyCyYxAAAA2gEAANsBAADcAQAA3QEAABoAAAAvAAAAHwAAADAAAADSAQBB0DILNjEAAADeAQAA3wEAAOABAADhAQAA4gEAAM8BAADQAQAA0QEAANIBAADTAQAA1AEAANUBAADjAQBBkDMLLjEAAADkAQAA5QEAAOYBAADdAQAA5wEAAM8BAADQAQAA0QEAANIBAADTAQAA1AEAQcgzCyo7AQAA6AEAAD0BAAA+AQAAPwEAAEABAABBAQAAQgEAAEMBAADpAQAARQEAQfwzCxLqAQAA6wEAAOwBAADtAQAA7gEAQZg0CyYxAAAA7wEAAPABAADxAQAA8gEAABoAAAAvAAAAHwAAAPMBAAD0AQBByDQLKjEAAAD1AQAA9gEAAPcBAAD4AQAAGgAAAPkBAAD6AQAA8wEAAPQBAAD7AQBB/DQLbzEAAAD8AQAA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AgAAAAAAAAACAAAAAgAAAAIAAAD/////AwAAAAMAAAACAEHc7wALFQIAAAD///////////////8CAAAAAgBBhPAACw3/////AAAAAP////8BAEGc8AALAQIAQbDwAAsNAgAAAAIAAAACAAAAAgBBzPAAC1UCAAAA//////////////////////////////////////////8CAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAADAAAAAgAAAAIAAAACAEG08QALFQIAAAACAAAAAgAAAAIAAAACAAAAAgBB1PEACxUCAAAAAgAAAAIAAAACAAAAAgAAAAIAQfzxAAsUAgAAAAIAAAACAAAAAAAAAP////8AQaDyAAsRAgAAAAIAAAAAAAAAAgAAAAIAQbzyAAuFAf//////////////////////////////////////////AQAAAP////8CAAAAAAAAAP////////////////////////////////////8AAAAA/////wAAAAAAAAAA//////////8AAAAAAAAAAAIAAAAAAAAA/////wAAAAACAAAAAgAAAAIAQczzAAsBAgBB2PMACyj//////////wAAAAAAAIC/AACAvwAAAAAAAIC/AACAPwAAgL8AAIC/AEGO9AALf4A/AAAAAAAAgL8AAIA/AAAAAAAAgD8AAIA/AACAPwAAAAAAAAAAAQAAAC8DAACdAgAAngIAAJ8CAAC5AAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAAKMAAACkAAAApQAAAKYAQZj1AAtRAQAAADADAAAdAAAAHgAAABkAAAAaAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAUAEH09QALSewAAAAxAwAA7gAAAO8AAADwAAAA8QAAAAcAAADyAAAACQAAAAoAAAALAAAAIAAAAA0AAAAhAAAA8wAAADIDAAAzAwAANAMAAPUAQcj2AAs+AQAAADUDAAD7AAAA/AAAAP0AAAD+AAAANgMAAB8AAAAJAAAACgAAAAsAAAAgAAAADQAAACEAAAA3AwAAOAMAQZD3AAujAQsBAAA6AwAAAgEAAAMBAAAEAQAABQEAABABAAAfAAAACQAAAAoAAAALAAAAEQEAAA0AAAASAQAAEwEAABQBAAAVAQAAFgEAABcBAAAYAQAAGQEAALz///8AAAAAGgEAAGFsbG9jYXRvcjxUPjo6YWxsb2NhdGUoc2l6ZV90IG4pICduJyBleGNlZWRzIG1heGltdW0gc3VwcG9ydGVkIHNpemUAQbz4AAteCwEAADsDAAANAQAADgEAAAQBAAAPAQAAEAEAAB8AAAAJAAAACgAAAAsAAAARAQAADQAAABIBAAATAQAAFAEAABUBAAAWAQAAFwEAABgBAAA8AwAAvP///wAAAAAaAQBBpPkAC0XsAAAAPQMAAPcAAAD4AAAA+QAAABoAAAAHAAAA8gAAAAkAAAAKAAAACwAAACAAAAANAAAAIQAAAPMAAAD0AAAAFAAAABQAQfT5AAtKAQAAAD4DAAAcAQAAHQEAAB4BAAAfAQAAPwMAAB8AAAAJAAAACgAAAAsAAAAgAAAADQAAACEAAABAAwAAQQMAAMz///8AAAAAQgMAQcj6AAtW7AAAAEMDAAAiAQAAIwEAACQBAAAlAQAABwAAAPIAAAAJAAAACgAAAAsAAAAgAAAADQAAACEAAADzAAAARAMAAEUDAABGAwAARwMAAEgDAABJAwAAKQEAQaj7AAteSgMAAEsDAAArAQAALAEAAC0BAAAuAQAABwAAAEwDAAAJAAAACgAAAAsAAAAgAAAADQAAACEAAABNAwAATgMAAE8DAABQAwAAUQMAAFIDAADA////AAAAAFMDAABUAwBBkPwAC+IMFAAAABQAAAByZW5kZXJGYWN0b3J5AG1ha2VSZW5kZXJQYWludABtYWtlUmVuZGVyUGF0aABieXRlTGVuZ3RoAHNldABsb2FkAFJlbmRlcmVyAHNhdmUAcmVzdG9yZQB0cmFuc2Zvcm0AZHJhd1BhdGgAY2xpcFBhdGgAYWxpZ24AUmVuZGVyZXJXcmFwcGVyAFJlbmRlclBhdGgAcmVzZXQAYWRkUGF0aABmaWxsUnVsZQBtb3ZlVG8AbGluZVRvAGN1YmljVG8AY2xvc2UAUmVuZGVyUGF0aFdyYXBwZXIAUmVuZGVyUGFpbnRTdHlsZQBmaWxsAHN0cm9rZQBGaWxsUnVsZQBub25aZXJvAGV2ZW5PZGQAU3Ryb2tlQ2FwAGJ1dHQAcm91bmQAc3F1YXJlAFN0cm9rZUpvaW4AbWl0ZXIAYmV2ZWwAQmxlbmRNb2RlAHNyY092ZXIAc2NyZWVuAG92ZXJsYXkAZGFya2VuAGxpZ2h0ZW4AY29sb3JEb2RnZQBjb2xvckJ1cm4AaGFyZExpZ2h0AHNvZnRMaWdodABkaWZmZXJlbmNlAGV4Y2x1c2lvbgBtdWx0aXBseQBodWUAc2F0dXJhdGlvbgBjb2xvcgBsdW1pbm9zaXR5AFJlbmRlclBhaW50AHN0eWxlAHRoaWNrbmVzcwBqb2luAGNhcABibGVuZE1vZGUAbGluZWFyR3JhZGllbnQAcmFkaWFsR3JhZGllbnQAYWRkU3RvcABjb21wbGV0ZUdyYWRpZW50AFJlbmRlclBhaW50V3JhcHBlcgBNYXQyRAB4eAB4eQB5eAB5eQB0eAB0eQBGaWxlAGRlZmF1bHRBcnRib2FyZABhcnRib2FyZEJ5TmFtZQBhcnRib2FyZEJ5SW5kZXgAYXJ0Ym9hcmRDb3VudABBcnRib2FyZABuYW1lAGFkdmFuY2UAZHJhdwB0cmFuc2Zvcm1Db21wb25lbnQAbm9kZQBib25lAHJvb3RCb25lAGFuaW1hdGlvbkJ5SW5kZXgAYW5pbWF0aW9uQnlOYW1lAGFuaW1hdGlvbkNvdW50AHN0YXRlTWFjaGluZUJ5SW5kZXgAc3RhdGVNYWNoaW5lQnlOYW1lAHN0YXRlTWFjaGluZUNvdW50AGJvdW5kcwBUcmFuc2Zvcm1Db21wb25lbnQAc2NhbGVYAHNjYWxlWQByb3RhdGlvbgBOb2RlAHgAeQBCb25lAGxlbmd0aABSb290Qm9uZQBBbmltYXRpb24ATGluZWFyQW5pbWF0aW9uAGR1cmF0aW9uAGZwcwB3b3JrU3RhcnQAd29ya0VuZABlbmFibGVXb3JrQXJlYQBsb29wVmFsdWUAc3BlZWQAYXBwbHkATGluZWFyQW5pbWF0aW9uSW5zdGFuY2UAdGltZQBkaWRMb29wAFN0YXRlTWFjaGluZQBTdGF0ZU1hY2hpbmVJbnN0YW5jZQBpbnB1dENvdW50AGlucHV0AHN0YXRlQ2hhbmdlZENvdW50AHN0YXRlQ2hhbmdlZE5hbWVCeUluZGV4AFNNSUlucHV0AHR5cGUAYm9vbAA7AG51bWJlcgAA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AKFfAADGXwAAw18AAMdfAADDXwAAyF8AAMNfAAD8XgAAyF8AAGkAJXAAdm9pZABib29sAGNoYXIAc2lnbmVkIGNoYXIAdW5zaWduZWQgY2hhcgBzaG9ydAB1bnNpZ25lZCBzaG9ydABpbnQAdW5zaWduZWQgaW50AGxvbmcAdW5zaWduZWQgbG9uZwBmbG9hdABkb3VibGUAc3RkOjpzdHJpbmcAc3RkOjpiYXNpY19zdHJpbmc8dW5zaWduZWQgY2hhcj4Ac3RkOjp3c3RyaW5nAHN0ZDo6dTE2c3RyaW5nAHN0ZDo6dTMyc3RyaW5nAGVtc2NyaXB0ZW46OnZhbABlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxzaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8bG9uZz4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgbG9uZz4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGZsb2F0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxkb3VibGU+AAAAAAAAAwAAAAQAAAAEAAAABgAAAIP5ogBETm4A/CkVANFXJwDdNPUAYtvAADyZlQBBkEMAY1H+ALveqwC3YcUAOm4k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APz0VQABWU0A4HGAAEGjsAELUUD7Ifk/AAAAAC1EdD4AAACAmEb4PAAAAGBRzHg7AAAAgIMb8DkAAABAICV6OAAAAIAiguM2AAAAAB3zaTUgXQAALSsgICAwWDB4AChudWxsKQBBgLEBC0ERAAoAERERAAAAAAUAAAAAAAAJAAAAAAsAAAAAAAAAABEADwoREREDCgcAAQAJCwsAAAkGCwAACwAGEQAAABEREQBB0bEBCyELAAAAAAAAAAARAAoKERERAAoAAAIACQsAAAAJAAsAAAsAQYuyAQsBDABBl7IBCxUMAAAAAAwAAAAACQwAAAAAAAwAAAwAQcWyAQsBDgBB0bIBCxUNAAAABA0AAAAACQ4AAAAAAA4AAA4AQf+yAQsBEABBi7MBCx4PAAAAAA8AAAAACRAAAAAAABAAABAAABIAAAASEhIAQcKzAQsOEgAAABISEgAAAAAAAAkAQfOzAQsBCwBB/7MBCxUKAAAAAAoAAAAACQsAAAAAAAsAAAsAQa20AQsBDABBubQBC0sMAAAAAAwAAAAACQwAAAAAAAwAAAwAADAxMjM0NTY3ODlBQkNERUYtMFgrMFggMFgtMHgrMHggMHgAaW5mAElORgBuYW4ATkFOAC4AQay1AQsCbAQAQdO1AQsF//////8AQZi2AQsTYmFzaWNfc3RyaW5nAHZlY3RvcgBBtLYBC+UDAgAAAAMAAAAFAAAABwAAAAsAAAANAAAAEQAAABMAAAAXAAAAHQAAAB8AAAAlAAAAKQAAACsAAAAvAAAANQAAADsAAAA9AAAAQwAAAEcAAABJAAAATwAAAFMAAABZAAAAYQAAAGUAAABnAAAAawAAAG0AAABxAAAAfwAAAIMAAACJAAAAiwAAAJUAAACXAAAAnQAAAKMAAACnAAAArQAAALMAAAC1AAAAvwAAAMEAAADFAAAAxwAAANMAAAABAAAACwAAAA0AAAARAAAAEwAAABcAAAAdAAAAHwAAACUAAAApAAAAKwAAAC8AAAA1AAAAOwAAAD0AAABDAAAARwAAAEkAAABPAAAAUwAAAFkAAABhAAAAZQAAAGcAAABrAAAAbQAAAHEAAAB5AAAAfwAAAIMAAACJAAAAiwAAAI8AAACVAAAAlwAAAJ0AAACjAAAApwAAAKkAAACtAAAAswAAALUAAAC7AAAAvwAAAMEAAADFAAAAxwAAANEAAABfX25leHRfcHJpbWUgb3ZlcmZsb3cAX19jeGFfZ3VhcmRfYWNxdWlyZSBkZXRlY3RlZCByZWN1cnNpdmUgaW5pdGlhbGl6YXRpb24AUHVyZSB2aXJ0dWFsIGZ1bmN0aW9uIGNhbGxlZCEAQaC6AQsBBQBBrLoBCwJnBABBxLoBCwpoBAAAaQQAAO1fAEHcugELAQIAQeu6AQsF//////8AQdy8AQsCHGAAQZS9AQsDMGJQ";

if (!isDataURI(wasmBinaryFile)) {
 wasmBinaryFile = locateFile(wasmBinaryFile);
}

function getBinary(file) {
 try {
  if (file == wasmBinaryFile && wasmBinary) {
   return new Uint8Array(wasmBinary);
  }
  var binary = tryParseAsDataURI(file);
  if (binary) {
   return binary;
  }
  if (readBinary) {
   return readBinary(file);
  } else {
   throw "both async and sync fetching of the wasm failed";
  }
 } catch (err) {
  abort(err);
 }
}

function getBinaryPromise() {
 if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
  if (typeof fetch === "function" && !isFileURI(wasmBinaryFile)) {
   return fetch(wasmBinaryFile, {
    credentials: "same-origin"
   }).then(function(response) {
    if (!response["ok"]) {
     throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
    }
    return response["arrayBuffer"]();
   }).catch(function() {
    return getBinary(wasmBinaryFile);
   });
  } else {
   if (readAsync) {
    return new Promise(function(resolve, reject) {
     readAsync(wasmBinaryFile, function(response) {
      resolve(new Uint8Array(response));
     }, reject);
    });
   }
  }
 }
 return Promise.resolve().then(function() {
  return getBinary(wasmBinaryFile);
 });
}

function createWasm() {
 var info = {
  "a": asmLibraryArg
 };
 function receiveInstance(instance, module) {
  var exports = instance.exports;
  Module["asm"] = exports;
  wasmMemory = Module["asm"]["M"];
  updateGlobalBufferAndViews(wasmMemory.buffer);
  wasmTable = Module["asm"]["O"];
  addOnInit(Module["asm"]["N"]);
  removeRunDependency("wasm-instantiate");
 }
 addRunDependency("wasm-instantiate");
 function receiveInstantiatedSource(output) {
  receiveInstance(output["instance"]);
 }
 function instantiateArrayBuffer(receiver) {
  return getBinaryPromise().then(function(binary) {
   var result = WebAssembly.instantiate(binary, info);
   return result;
  }).then(receiver, function(reason) {
   err("failed to asynchronously prepare wasm: " + reason);
   abort(reason);
  });
 }
 function instantiateAsync() {
  if (!wasmBinary && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && typeof fetch === "function") {
   return fetch(wasmBinaryFile, {
    credentials: "same-origin"
   }).then(function(response) {
    var result = WebAssembly.instantiateStreaming(response, info);
    return result.then(receiveInstantiatedSource, function(reason) {
     err("wasm streaming compile failed: " + reason);
     err("falling back to ArrayBuffer instantiation");
     return instantiateArrayBuffer(receiveInstantiatedSource);
    });
   });
  } else {
   return instantiateArrayBuffer(receiveInstantiatedSource);
  }
 }
 if (Module["instantiateWasm"]) {
  try {
   var exports = Module["instantiateWasm"](info, receiveInstance);
   return exports;
  } catch (e) {
   err("Module.instantiateWasm callback failed with error: " + e);
   return false;
  }
 }
 instantiateAsync().catch(readyPromiseReject);
 return {};
}

function callRuntimeCallbacks(callbacks) {
 while (callbacks.length > 0) {
  var callback = callbacks.shift();
  if (typeof callback == "function") {
   callback(Module);
   continue;
  }
  var func = callback.func;
  if (typeof func === "number") {
   if (callback.arg === undefined) {
    wasmTable.get(func)();
   } else {
    wasmTable.get(func)(callback.arg);
   }
  } else {
   func(callback.arg === undefined ? null : callback.arg);
  }
 }
}

var char_0 = 48;

var char_9 = 57;

function makeLegalFunctionName(name) {
 if (undefined === name) {
  return "_unknown";
 }
 name = name.replace(/[^a-zA-Z0-9_]/g, "$");
 var f = name.charCodeAt(0);
 if (f >= char_0 && f <= char_9) {
  return "_" + name;
 } else {
  return name;
 }
}

function createNamedFunction(name, body) {
 name = makeLegalFunctionName(name);
 return new Function("body", "return function " + name + "() {\n" + '    "use strict";' + "    return body.apply(this, arguments);\n" + "};\n")(body);
}

var emval_free_list = [];

var emval_handle_array = [ {}, {
 value: undefined
}, {
 value: null
}, {
 value: true
}, {
 value: false
} ];

function count_emval_handles() {
 var count = 0;
 for (var i = 5; i < emval_handle_array.length; ++i) {
  if (emval_handle_array[i] !== undefined) {
   ++count;
  }
 }
 return count;
}

function get_first_emval() {
 for (var i = 5; i < emval_handle_array.length; ++i) {
  if (emval_handle_array[i] !== undefined) {
   return emval_handle_array[i];
  }
 }
 return null;
}

function init_emval() {
 Module["count_emval_handles"] = count_emval_handles;
 Module["get_first_emval"] = get_first_emval;
}

function __emval_register(value) {
 switch (value) {
 case undefined:
  {
   return 1;
  }

 case null:
  {
   return 2;
  }

 case true:
  {
   return 3;
  }

 case false:
  {
   return 4;
  }

 default:
  {
   var handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;
   emval_handle_array[handle] = {
    refcount: 1,
    value: value
   };
   return handle;
  }
 }
}

function extendError(baseErrorType, errorName) {
 var errorClass = createNamedFunction(errorName, function(message) {
  this.name = errorName;
  this.message = message;
  var stack = new Error(message).stack;
  if (stack !== undefined) {
   this.stack = this.toString() + "\n" + stack.replace(/^Error(:[^\n]*)?\n/, "");
  }
 });
 errorClass.prototype = Object.create(baseErrorType.prototype);
 errorClass.prototype.constructor = errorClass;
 errorClass.prototype.toString = function() {
  if (this.message === undefined) {
   return this.name;
  } else {
   return this.name + ": " + this.message;
  }
 };
 return errorClass;
}

var PureVirtualError = undefined;

function embind_init_charCodes() {
 var codes = new Array(256);
 for (var i = 0; i < 256; ++i) {
  codes[i] = String.fromCharCode(i);
 }
 embind_charCodes = codes;
}

var embind_charCodes = undefined;

function readLatin1String(ptr) {
 var ret = "";
 var c = ptr;
 while (HEAPU8[c]) {
  ret += embind_charCodes[HEAPU8[c++]];
 }
 return ret;
}

function getInheritedInstanceCount() {
 return Object.keys(registeredInstances).length;
}

function getLiveInheritedInstances() {
 var rv = [];
 for (var k in registeredInstances) {
  if (registeredInstances.hasOwnProperty(k)) {
   rv.push(registeredInstances[k]);
  }
 }
 return rv;
}

var deletionQueue = [];

function flushPendingDeletes() {
 while (deletionQueue.length) {
  var obj = deletionQueue.pop();
  obj.$$.deleteScheduled = false;
  obj["delete"]();
 }
}

var delayFunction = undefined;

function setDelayFunction(fn) {
 delayFunction = fn;
 if (deletionQueue.length && delayFunction) {
  delayFunction(flushPendingDeletes);
 }
}

function init_embind() {
 Module["getInheritedInstanceCount"] = getInheritedInstanceCount;
 Module["getLiveInheritedInstances"] = getLiveInheritedInstances;
 Module["flushPendingDeletes"] = flushPendingDeletes;
 Module["setDelayFunction"] = setDelayFunction;
}

var registeredInstances = {};

var BindingError = undefined;

function throwBindingError(message) {
 throw new BindingError(message);
}

function getBasestPointer(class_, ptr) {
 if (ptr === undefined) {
  throwBindingError("ptr should not be undefined");
 }
 while (class_.baseClass) {
  ptr = class_.upcast(ptr);
  class_ = class_.baseClass;
 }
 return ptr;
}

function registerInheritedInstance(class_, ptr, instance) {
 ptr = getBasestPointer(class_, ptr);
 if (registeredInstances.hasOwnProperty(ptr)) {
  throwBindingError("Tried to register registered instance: " + ptr);
 } else {
  registeredInstances[ptr] = instance;
 }
}

function requireHandle(handle) {
 if (!handle) {
  throwBindingError("Cannot use deleted val. handle = " + handle);
 }
 return emval_handle_array[handle].value;
}

var registeredTypes = {};

function getTypeName(type) {
 var ptr = ___getTypeName(type);
 var rv = readLatin1String(ptr);
 _free(ptr);
 return rv;
}

function requireRegisteredType(rawType, humanName) {
 var impl = registeredTypes[rawType];
 if (undefined === impl) {
  throwBindingError(humanName + " has unknown type " + getTypeName(rawType));
 }
 return impl;
}

function unregisterInheritedInstance(class_, ptr) {
 ptr = getBasestPointer(class_, ptr);
 if (registeredInstances.hasOwnProperty(ptr)) {
  delete registeredInstances[ptr];
 } else {
  throwBindingError("Tried to unregister unregistered instance: " + ptr);
 }
}

function detachFinalizer(handle) {}

var finalizationGroup = false;

function runDestructor($$) {
 if ($$.smartPtr) {
  $$.smartPtrType.rawDestructor($$.smartPtr);
 } else {
  $$.ptrType.registeredClass.rawDestructor($$.ptr);
 }
}

function releaseClassHandle($$) {
 $$.count.value -= 1;
 var toDelete = 0 === $$.count.value;
 if (toDelete) {
  runDestructor($$);
 }
}

function attachFinalizer(handle) {
 if ("undefined" === typeof FinalizationGroup) {
  attachFinalizer = function(handle) {
   return handle;
  };
  return handle;
 }
 finalizationGroup = new FinalizationGroup(function(iter) {
  for (var result = iter.next(); !result.done; result = iter.next()) {
   var $$ = result.value;
   if (!$$.ptr) {
    console.warn("object already deleted: " + $$.ptr);
   } else {
    releaseClassHandle($$);
   }
  }
 });
 attachFinalizer = function(handle) {
  finalizationGroup.register(handle, handle.$$, handle.$$);
  return handle;
 };
 detachFinalizer = function(handle) {
  finalizationGroup.unregister(handle.$$);
 };
 return attachFinalizer(handle);
}

function __embind_create_inheriting_constructor(constructorName, wrapperType, properties) {
 constructorName = readLatin1String(constructorName);
 wrapperType = requireRegisteredType(wrapperType, "wrapper");
 properties = requireHandle(properties);
 var arraySlice = [].slice;
 var registeredClass = wrapperType.registeredClass;
 var wrapperPrototype = registeredClass.instancePrototype;
 var baseClass = registeredClass.baseClass;
 var baseClassPrototype = baseClass.instancePrototype;
 var baseConstructor = registeredClass.baseClass.constructor;
 var ctor = createNamedFunction(constructorName, function() {
  registeredClass.baseClass.pureVirtualFunctions.forEach(function(name) {
   if (this[name] === baseClassPrototype[name]) {
    throw new PureVirtualError("Pure virtual function " + name + " must be implemented in JavaScript");
   }
  }.bind(this));
  Object.defineProperty(this, "__parent", {
   value: wrapperPrototype
  });
  this["__construct"].apply(this, arraySlice.call(arguments));
 });
 wrapperPrototype["__construct"] = function __construct() {
  if (this === wrapperPrototype) {
   throwBindingError("Pass correct 'this' to __construct");
  }
  var inner = baseConstructor["implement"].apply(undefined, [ this ].concat(arraySlice.call(arguments)));
  detachFinalizer(inner);
  var $$ = inner.$$;
  inner["notifyOnDestruction"]();
  $$.preservePointerOnDelete = true;
  Object.defineProperties(this, {
   $$: {
    value: $$
   }
  });
  attachFinalizer(this);
  registerInheritedInstance(registeredClass, $$.ptr, this);
 };
 wrapperPrototype["__destruct"] = function __destruct() {
  if (this === wrapperPrototype) {
   throwBindingError("Pass correct 'this' to __destruct");
  }
  detachFinalizer(this);
  unregisterInheritedInstance(registeredClass, this.$$.ptr);
 };
 ctor.prototype = Object.create(wrapperPrototype);
 for (var p in properties) {
  ctor.prototype[p] = properties[p];
 }
 return __emval_register(ctor);
}

var structRegistrations = {};

function runDestructors(destructors) {
 while (destructors.length) {
  var ptr = destructors.pop();
  var del = destructors.pop();
  del(ptr);
 }
}

function simpleReadValueFromPointer(pointer) {
 return this["fromWireType"](HEAPU32[pointer >> 2]);
}

var awaitingDependencies = {};

var typeDependencies = {};

var InternalError = undefined;

function throwInternalError(message) {
 throw new InternalError(message);
}

function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {
 myTypes.forEach(function(type) {
  typeDependencies[type] = dependentTypes;
 });
 function onComplete(typeConverters) {
  var myTypeConverters = getTypeConverters(typeConverters);
  if (myTypeConverters.length !== myTypes.length) {
   throwInternalError("Mismatched type converter count");
  }
  for (var i = 0; i < myTypes.length; ++i) {
   registerType(myTypes[i], myTypeConverters[i]);
  }
 }
 var typeConverters = new Array(dependentTypes.length);
 var unregisteredTypes = [];
 var registered = 0;
 dependentTypes.forEach(function(dt, i) {
  if (registeredTypes.hasOwnProperty(dt)) {
   typeConverters[i] = registeredTypes[dt];
  } else {
   unregisteredTypes.push(dt);
   if (!awaitingDependencies.hasOwnProperty(dt)) {
    awaitingDependencies[dt] = [];
   }
   awaitingDependencies[dt].push(function() {
    typeConverters[i] = registeredTypes[dt];
    ++registered;
    if (registered === unregisteredTypes.length) {
     onComplete(typeConverters);
    }
   });
  }
 });
 if (0 === unregisteredTypes.length) {
  onComplete(typeConverters);
 }
}

function __embind_finalize_value_object(structType) {
 var reg = structRegistrations[structType];
 delete structRegistrations[structType];
 var rawConstructor = reg.rawConstructor;
 var rawDestructor = reg.rawDestructor;
 var fieldRecords = reg.fields;
 var fieldTypes = fieldRecords.map(function(field) {
  return field.getterReturnType;
 }).concat(fieldRecords.map(function(field) {
  return field.setterArgumentType;
 }));
 whenDependentTypesAreResolved([ structType ], fieldTypes, function(fieldTypes) {
  var fields = {};
  fieldRecords.forEach(function(field, i) {
   var fieldName = field.fieldName;
   var getterReturnType = fieldTypes[i];
   var getter = field.getter;
   var getterContext = field.getterContext;
   var setterArgumentType = fieldTypes[i + fieldRecords.length];
   var setter = field.setter;
   var setterContext = field.setterContext;
   fields[fieldName] = {
    read: function(ptr) {
     return getterReturnType["fromWireType"](getter(getterContext, ptr));
    },
    write: function(ptr, o) {
     var destructors = [];
     setter(setterContext, ptr, setterArgumentType["toWireType"](destructors, o));
     runDestructors(destructors);
    }
   };
  });
  return [ {
   name: reg.name,
   "fromWireType": function(ptr) {
    var rv = {};
    for (var i in fields) {
     rv[i] = fields[i].read(ptr);
    }
    rawDestructor(ptr);
    return rv;
   },
   "toWireType": function(destructors, o) {
    for (var fieldName in fields) {
     if (!(fieldName in o)) {
      throw new TypeError('Missing field:  "' + fieldName + '"');
     }
    }
    var ptr = rawConstructor();
    for (fieldName in fields) {
     fields[fieldName].write(ptr, o[fieldName]);
    }
    if (destructors !== null) {
     destructors.push(rawDestructor, ptr);
    }
    return ptr;
   },
   "argPackAdvance": 8,
   "readValueFromPointer": simpleReadValueFromPointer,
   destructorFunction: rawDestructor
  } ];
 });
}

function getShiftFromSize(size) {
 switch (size) {
 case 1:
  return 0;

 case 2:
  return 1;

 case 4:
  return 2;

 case 8:
  return 3;

 default:
  throw new TypeError("Unknown type size: " + size);
 }
}

function registerType(rawType, registeredInstance, options) {
 options = options || {};
 if (!("argPackAdvance" in registeredInstance)) {
  throw new TypeError("registerType registeredInstance requires argPackAdvance");
 }
 var name = registeredInstance.name;
 if (!rawType) {
  throwBindingError('type "' + name + '" must have a positive integer typeid pointer');
 }
 if (registeredTypes.hasOwnProperty(rawType)) {
  if (options.ignoreDuplicateRegistrations) {
   return;
  } else {
   throwBindingError("Cannot register type '" + name + "' twice");
  }
 }
 registeredTypes[rawType] = registeredInstance;
 delete typeDependencies[rawType];
 if (awaitingDependencies.hasOwnProperty(rawType)) {
  var callbacks = awaitingDependencies[rawType];
  delete awaitingDependencies[rawType];
  callbacks.forEach(function(cb) {
   cb();
  });
 }
}

function __embind_register_bool(rawType, name, size, trueValue, falseValue) {
 var shift = getShiftFromSize(size);
 name = readLatin1String(name);
 registerType(rawType, {
  name: name,
  "fromWireType": function(wt) {
   return !!wt;
  },
  "toWireType": function(destructors, o) {
   return o ? trueValue : falseValue;
  },
  "argPackAdvance": 8,
  "readValueFromPointer": function(pointer) {
   var heap;
   if (size === 1) {
    heap = HEAP8;
   } else if (size === 2) {
    heap = HEAP16;
   } else if (size === 4) {
    heap = HEAP32;
   } else {
    throw new TypeError("Unknown boolean type size: " + name);
   }
   return this["fromWireType"](heap[pointer >> shift]);
  },
  destructorFunction: null
 });
}

function ClassHandle_isAliasOf(other) {
 if (!(this instanceof ClassHandle)) {
  return false;
 }
 if (!(other instanceof ClassHandle)) {
  return false;
 }
 var leftClass = this.$$.ptrType.registeredClass;
 var left = this.$$.ptr;
 var rightClass = other.$$.ptrType.registeredClass;
 var right = other.$$.ptr;
 while (leftClass.baseClass) {
  left = leftClass.upcast(left);
  leftClass = leftClass.baseClass;
 }
 while (rightClass.baseClass) {
  right = rightClass.upcast(right);
  rightClass = rightClass.baseClass;
 }
 return leftClass === rightClass && left === right;
}

function shallowCopyInternalPointer(o) {
 return {
  count: o.count,
  deleteScheduled: o.deleteScheduled,
  preservePointerOnDelete: o.preservePointerOnDelete,
  ptr: o.ptr,
  ptrType: o.ptrType,
  smartPtr: o.smartPtr,
  smartPtrType: o.smartPtrType
 };
}

function throwInstanceAlreadyDeleted(obj) {
 function getInstanceTypeName(handle) {
  return handle.$$.ptrType.registeredClass.name;
 }
 throwBindingError(getInstanceTypeName(obj) + " instance already deleted");
}

function ClassHandle_clone() {
 if (!this.$$.ptr) {
  throwInstanceAlreadyDeleted(this);
 }
 if (this.$$.preservePointerOnDelete) {
  this.$$.count.value += 1;
  return this;
 } else {
  var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {
   $$: {
    value: shallowCopyInternalPointer(this.$$)
   }
  }));
  clone.$$.count.value += 1;
  clone.$$.deleteScheduled = false;
  return clone;
 }
}

function ClassHandle_delete() {
 if (!this.$$.ptr) {
  throwInstanceAlreadyDeleted(this);
 }
 if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
  throwBindingError("Object already scheduled for deletion");
 }
 detachFinalizer(this);
 releaseClassHandle(this.$$);
 if (!this.$$.preservePointerOnDelete) {
  this.$$.smartPtr = undefined;
  this.$$.ptr = undefined;
 }
}

function ClassHandle_isDeleted() {
 return !this.$$.ptr;
}

function ClassHandle_deleteLater() {
 if (!this.$$.ptr) {
  throwInstanceAlreadyDeleted(this);
 }
 if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
  throwBindingError("Object already scheduled for deletion");
 }
 deletionQueue.push(this);
 if (deletionQueue.length === 1 && delayFunction) {
  delayFunction(flushPendingDeletes);
 }
 this.$$.deleteScheduled = true;
 return this;
}

function init_ClassHandle() {
 ClassHandle.prototype["isAliasOf"] = ClassHandle_isAliasOf;
 ClassHandle.prototype["clone"] = ClassHandle_clone;
 ClassHandle.prototype["delete"] = ClassHandle_delete;
 ClassHandle.prototype["isDeleted"] = ClassHandle_isDeleted;
 ClassHandle.prototype["deleteLater"] = ClassHandle_deleteLater;
}

function ClassHandle() {}

var registeredPointers = {};

function ensureOverloadTable(proto, methodName, humanName) {
 if (undefined === proto[methodName].overloadTable) {
  var prevFunc = proto[methodName];
  proto[methodName] = function() {
   if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
    throwBindingError("Function '" + humanName + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + proto[methodName].overloadTable + ")!");
   }
   return proto[methodName].overloadTable[arguments.length].apply(this, arguments);
  };
  proto[methodName].overloadTable = [];
  proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
 }
}

function exposePublicSymbol(name, value, numArguments) {
 if (Module.hasOwnProperty(name)) {
  if (undefined === numArguments || undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments]) {
   throwBindingError("Cannot register public name '" + name + "' twice");
  }
  ensureOverloadTable(Module, name, name);
  if (Module.hasOwnProperty(numArguments)) {
   throwBindingError("Cannot register multiple overloads of a function with the same number of arguments (" + numArguments + ")!");
  }
  Module[name].overloadTable[numArguments] = value;
 } else {
  Module[name] = value;
  if (undefined !== numArguments) {
   Module[name].numArguments = numArguments;
  }
 }
}

function RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {
 this.name = name;
 this.constructor = constructor;
 this.instancePrototype = instancePrototype;
 this.rawDestructor = rawDestructor;
 this.baseClass = baseClass;
 this.getActualType = getActualType;
 this.upcast = upcast;
 this.downcast = downcast;
 this.pureVirtualFunctions = [];
}

function upcastPointer(ptr, ptrClass, desiredClass) {
 while (ptrClass !== desiredClass) {
  if (!ptrClass.upcast) {
   throwBindingError("Expected null or instance of " + desiredClass.name + ", got an instance of " + ptrClass.name);
  }
  ptr = ptrClass.upcast(ptr);
  ptrClass = ptrClass.baseClass;
 }
 return ptr;
}

function constNoSmartPtrRawPointerToWireType(destructors, handle) {
 if (handle === null) {
  if (this.isReference) {
   throwBindingError("null is not a valid " + this.name);
  }
  return 0;
 }
 if (!handle.$$) {
  throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
 }
 if (!handle.$$.ptr) {
  throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
 }
 var handleClass = handle.$$.ptrType.registeredClass;
 var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
 return ptr;
}

function genericPointerToWireType(destructors, handle) {
 var ptr;
 if (handle === null) {
  if (this.isReference) {
   throwBindingError("null is not a valid " + this.name);
  }
  if (this.isSmartPointer) {
   ptr = this.rawConstructor();
   if (destructors !== null) {
    destructors.push(this.rawDestructor, ptr);
   }
   return ptr;
  } else {
   return 0;
  }
 }
 if (!handle.$$) {
  throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
 }
 if (!handle.$$.ptr) {
  throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
 }
 if (!this.isConst && handle.$$.ptrType.isConst) {
  throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
 }
 var handleClass = handle.$$.ptrType.registeredClass;
 ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
 if (this.isSmartPointer) {
  if (undefined === handle.$$.smartPtr) {
   throwBindingError("Passing raw pointer to smart pointer is illegal");
  }
  switch (this.sharingPolicy) {
  case 0:
   if (handle.$$.smartPtrType === this) {
    ptr = handle.$$.smartPtr;
   } else {
    throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
   }
   break;

  case 1:
   ptr = handle.$$.smartPtr;
   break;

  case 2:
   if (handle.$$.smartPtrType === this) {
    ptr = handle.$$.smartPtr;
   } else {
    var clonedHandle = handle["clone"]();
    ptr = this.rawShare(ptr, __emval_register(function() {
     clonedHandle["delete"]();
    }));
    if (destructors !== null) {
     destructors.push(this.rawDestructor, ptr);
    }
   }
   break;

  default:
   throwBindingError("Unsupporting sharing policy");
  }
 }
 return ptr;
}

function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
 if (handle === null) {
  if (this.isReference) {
   throwBindingError("null is not a valid " + this.name);
  }
  return 0;
 }
 if (!handle.$$) {
  throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
 }
 if (!handle.$$.ptr) {
  throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
 }
 if (handle.$$.ptrType.isConst) {
  throwBindingError("Cannot convert argument of type " + handle.$$.ptrType.name + " to parameter type " + this.name);
 }
 var handleClass = handle.$$.ptrType.registeredClass;
 var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
 return ptr;
}

function RegisteredPointer_getPointee(ptr) {
 if (this.rawGetPointee) {
  ptr = this.rawGetPointee(ptr);
 }
 return ptr;
}

function RegisteredPointer_destructor(ptr) {
 if (this.rawDestructor) {
  this.rawDestructor(ptr);
 }
}

function RegisteredPointer_deleteObject(handle) {
 if (handle !== null) {
  handle["delete"]();
 }
}

function downcastPointer(ptr, ptrClass, desiredClass) {
 if (ptrClass === desiredClass) {
  return ptr;
 }
 if (undefined === desiredClass.baseClass) {
  return null;
 }
 var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);
 if (rv === null) {
  return null;
 }
 return desiredClass.downcast(rv);
}

function getInheritedInstance(class_, ptr) {
 ptr = getBasestPointer(class_, ptr);
 return registeredInstances[ptr];
}

function makeClassHandle(prototype, record) {
 if (!record.ptrType || !record.ptr) {
  throwInternalError("makeClassHandle requires ptr and ptrType");
 }
 var hasSmartPtrType = !!record.smartPtrType;
 var hasSmartPtr = !!record.smartPtr;
 if (hasSmartPtrType !== hasSmartPtr) {
  throwInternalError("Both smartPtrType and smartPtr must be specified");
 }
 record.count = {
  value: 1
 };
 return attachFinalizer(Object.create(prototype, {
  $$: {
   value: record
  }
 }));
}

function RegisteredPointer_fromWireType(ptr) {
 var rawPointer = this.getPointee(ptr);
 if (!rawPointer) {
  this.destructor(ptr);
  return null;
 }
 var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
 if (undefined !== registeredInstance) {
  if (0 === registeredInstance.$$.count.value) {
   registeredInstance.$$.ptr = rawPointer;
   registeredInstance.$$.smartPtr = ptr;
   return registeredInstance["clone"]();
  } else {
   var rv = registeredInstance["clone"]();
   this.destructor(ptr);
   return rv;
  }
 }
 function makeDefaultHandle() {
  if (this.isSmartPointer) {
   return makeClassHandle(this.registeredClass.instancePrototype, {
    ptrType: this.pointeeType,
    ptr: rawPointer,
    smartPtrType: this,
    smartPtr: ptr
   });
  } else {
   return makeClassHandle(this.registeredClass.instancePrototype, {
    ptrType: this,
    ptr: ptr
   });
  }
 }
 var actualType = this.registeredClass.getActualType(rawPointer);
 var registeredPointerRecord = registeredPointers[actualType];
 if (!registeredPointerRecord) {
  return makeDefaultHandle.call(this);
 }
 var toType;
 if (this.isConst) {
  toType = registeredPointerRecord.constPointerType;
 } else {
  toType = registeredPointerRecord.pointerType;
 }
 var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);
 if (dp === null) {
  return makeDefaultHandle.call(this);
 }
 if (this.isSmartPointer) {
  return makeClassHandle(toType.registeredClass.instancePrototype, {
   ptrType: toType,
   ptr: dp,
   smartPtrType: this,
   smartPtr: ptr
  });
 } else {
  return makeClassHandle(toType.registeredClass.instancePrototype, {
   ptrType: toType,
   ptr: dp
  });
 }
}

function init_RegisteredPointer() {
 RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;
 RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;
 RegisteredPointer.prototype["argPackAdvance"] = 8;
 RegisteredPointer.prototype["readValueFromPointer"] = simpleReadValueFromPointer;
 RegisteredPointer.prototype["deleteObject"] = RegisteredPointer_deleteObject;
 RegisteredPointer.prototype["fromWireType"] = RegisteredPointer_fromWireType;
}

function RegisteredPointer(name, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {
 this.name = name;
 this.registeredClass = registeredClass;
 this.isReference = isReference;
 this.isConst = isConst;
 this.isSmartPointer = isSmartPointer;
 this.pointeeType = pointeeType;
 this.sharingPolicy = sharingPolicy;
 this.rawGetPointee = rawGetPointee;
 this.rawConstructor = rawConstructor;
 this.rawShare = rawShare;
 this.rawDestructor = rawDestructor;
 if (!isSmartPointer && registeredClass.baseClass === undefined) {
  if (isConst) {
   this["toWireType"] = constNoSmartPtrRawPointerToWireType;
   this.destructorFunction = null;
  } else {
   this["toWireType"] = nonConstNoSmartPtrRawPointerToWireType;
   this.destructorFunction = null;
  }
 } else {
  this["toWireType"] = genericPointerToWireType;
 }
}

function replacePublicSymbol(name, value, numArguments) {
 if (!Module.hasOwnProperty(name)) {
  throwInternalError("Replacing nonexistant public symbol");
 }
 if (undefined !== Module[name].overloadTable && undefined !== numArguments) {
  Module[name].overloadTable[numArguments] = value;
 } else {
  Module[name] = value;
  Module[name].argCount = numArguments;
 }
}

function dynCallLegacy(sig, ptr, args) {
 var f = Module["dynCall_" + sig];
 return args && args.length ? f.apply(null, [ ptr ].concat(args)) : f.call(null, ptr);
}

function dynCall(sig, ptr, args) {
 if (sig.indexOf("j") != -1) {
  return dynCallLegacy(sig, ptr, args);
 }
 return wasmTable.get(ptr).apply(null, args);
}

function getDynCaller(sig, ptr) {
 var argCache = [];
 return function() {
  argCache.length = arguments.length;
  for (var i = 0; i < arguments.length; i++) {
   argCache[i] = arguments[i];
  }
  return dynCall(sig, ptr, argCache);
 };
}

function embind__requireFunction(signature, rawFunction) {
 signature = readLatin1String(signature);
 function makeDynCaller() {
  if (signature.indexOf("j") != -1) {
   return getDynCaller(signature, rawFunction);
  }
  return wasmTable.get(rawFunction);
 }
 var fp = makeDynCaller();
 if (typeof fp !== "function") {
  throwBindingError("unknown function pointer with signature " + signature + ": " + rawFunction);
 }
 return fp;
}

var UnboundTypeError = undefined;

function throwUnboundTypeError(message, types) {
 var unboundTypes = [];
 var seen = {};
 function visit(type) {
  if (seen[type]) {
   return;
  }
  if (registeredTypes[type]) {
   return;
  }
  if (typeDependencies[type]) {
   typeDependencies[type].forEach(visit);
   return;
  }
  unboundTypes.push(type);
  seen[type] = true;
 }
 types.forEach(visit);
 throw new UnboundTypeError(message + ": " + unboundTypes.map(getTypeName).join([ ", " ]));
}

function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name, destructorSignature, rawDestructor) {
 name = readLatin1String(name);
 getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
 if (upcast) {
  upcast = embind__requireFunction(upcastSignature, upcast);
 }
 if (downcast) {
  downcast = embind__requireFunction(downcastSignature, downcast);
 }
 rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
 var legalFunctionName = makeLegalFunctionName(name);
 exposePublicSymbol(legalFunctionName, function() {
  throwUnboundTypeError("Cannot construct " + name + " due to unbound types", [ baseClassRawType ]);
 });
 whenDependentTypesAreResolved([ rawType, rawPointerType, rawConstPointerType ], baseClassRawType ? [ baseClassRawType ] : [], function(base) {
  base = base[0];
  var baseClass;
  var basePrototype;
  if (baseClassRawType) {
   baseClass = base.registeredClass;
   basePrototype = baseClass.instancePrototype;
  } else {
   basePrototype = ClassHandle.prototype;
  }
  var constructor = createNamedFunction(legalFunctionName, function() {
   if (Object.getPrototypeOf(this) !== instancePrototype) {
    throw new BindingError("Use 'new' to construct " + name);
   }
   if (undefined === registeredClass.constructor_body) {
    throw new BindingError(name + " has no accessible constructor");
   }
   var body = registeredClass.constructor_body[arguments.length];
   if (undefined === body) {
    throw new BindingError("Tried to invoke ctor of " + name + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(registeredClass.constructor_body).toString() + ") parameters instead!");
   }
   return body.apply(this, arguments);
  });
  var instancePrototype = Object.create(basePrototype, {
   constructor: {
    value: constructor
   }
  });
  constructor.prototype = instancePrototype;
  var registeredClass = new RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);
  var referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false);
  var pointerConverter = new RegisteredPointer(name + "*", registeredClass, false, false, false);
  var constPointerConverter = new RegisteredPointer(name + " const*", registeredClass, false, true, false);
  registeredPointers[rawType] = {
   pointerType: pointerConverter,
   constPointerType: constPointerConverter
  };
  replacePublicSymbol(legalFunctionName, constructor);
  return [ referenceConverter, pointerConverter, constPointerConverter ];
 });
}

function new_(constructor, argumentList) {
 if (!(constructor instanceof Function)) {
  throw new TypeError("new_ called with constructor type " + typeof constructor + " which is not a function");
 }
 var dummy = createNamedFunction(constructor.name || "unknownFunctionName", function() {});
 dummy.prototype = constructor.prototype;
 var obj = new dummy();
 var r = constructor.apply(obj, argumentList);
 return r instanceof Object ? r : obj;
}

function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {
 var argCount = argTypes.length;
 if (argCount < 2) {
  throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
 }
 var isClassMethodFunc = argTypes[1] !== null && classType !== null;
 var needsDestructorStack = false;
 for (var i = 1; i < argTypes.length; ++i) {
  if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {
   needsDestructorStack = true;
   break;
  }
 }
 var returns = argTypes[0].name !== "void";
 var argsList = "";
 var argsListWired = "";
 for (var i = 0; i < argCount - 2; ++i) {
  argsList += (i !== 0 ? ", " : "") + "arg" + i;
  argsListWired += (i !== 0 ? ", " : "") + "arg" + i + "Wired";
 }
 var invokerFnBody = "return function " + makeLegalFunctionName(humanName) + "(" + argsList + ") {\n" + "if (arguments.length !== " + (argCount - 2) + ") {\n" + "throwBindingError('function " + humanName + " called with ' + arguments.length + ' arguments, expected " + (argCount - 2) + " args!');\n" + "}\n";
 if (needsDestructorStack) {
  invokerFnBody += "var destructors = [];\n";
 }
 var dtorStack = needsDestructorStack ? "destructors" : "null";
 var args1 = [ "throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam" ];
 var args2 = [ throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1] ];
 if (isClassMethodFunc) {
  invokerFnBody += "var thisWired = classParam.toWireType(" + dtorStack + ", this);\n";
 }
 for (var i = 0; i < argCount - 2; ++i) {
  invokerFnBody += "var arg" + i + "Wired = argType" + i + ".toWireType(" + dtorStack + ", arg" + i + "); // " + argTypes[i + 2].name + "\n";
  args1.push("argType" + i);
  args2.push(argTypes[i + 2]);
 }
 if (isClassMethodFunc) {
  argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
 }
 invokerFnBody += (returns ? "var rv = " : "") + "invoker(fn" + (argsListWired.length > 0 ? ", " : "") + argsListWired + ");\n";
 if (needsDestructorStack) {
  invokerFnBody += "runDestructors(destructors);\n";
 } else {
  for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {
   var paramName = i === 1 ? "thisWired" : "arg" + (i - 2) + "Wired";
   if (argTypes[i].destructorFunction !== null) {
    invokerFnBody += paramName + "_dtor(" + paramName + "); // " + argTypes[i].name + "\n";
    args1.push(paramName + "_dtor");
    args2.push(argTypes[i].destructorFunction);
   }
  }
 }
 if (returns) {
  invokerFnBody += "var ret = retType.fromWireType(rv);\n" + "return ret;\n";
 } else {}
 invokerFnBody += "}\n";
 args1.push(invokerFnBody);
 var invokerFunction = new_(Function, args1).apply(null, args2);
 return invokerFunction;
}

function heap32VectorToArray(count, firstElement) {
 var array = [];
 for (var i = 0; i < count; i++) {
  array.push(HEAP32[(firstElement >> 2) + i]);
 }
 return array;
}

function __embind_register_class_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, fn) {
 var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
 methodName = readLatin1String(methodName);
 rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
 whenDependentTypesAreResolved([], [ rawClassType ], function(classType) {
  classType = classType[0];
  var humanName = classType.name + "." + methodName;
  function unboundTypesHandler() {
   throwUnboundTypeError("Cannot call " + humanName + " due to unbound types", rawArgTypes);
  }
  var proto = classType.registeredClass.constructor;
  if (undefined === proto[methodName]) {
   unboundTypesHandler.argCount = argCount - 1;
   proto[methodName] = unboundTypesHandler;
  } else {
   ensureOverloadTable(proto, methodName, humanName);
   proto[methodName].overloadTable[argCount - 1] = unboundTypesHandler;
  }
  whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
   var invokerArgsArray = [ argTypes[0], null ].concat(argTypes.slice(1));
   var func = craftInvokerFunction(humanName, invokerArgsArray, null, rawInvoker, fn);
   if (undefined === proto[methodName].overloadTable) {
    func.argCount = argCount - 1;
    proto[methodName] = func;
   } else {
    proto[methodName].overloadTable[argCount - 1] = func;
   }
   return [];
  });
  return [];
 });
}

function validateThis(this_, classType, humanName) {
 if (!(this_ instanceof Object)) {
  throwBindingError(humanName + ' with invalid "this": ' + this_);
 }
 if (!(this_ instanceof classType.registeredClass.constructor)) {
  throwBindingError(humanName + ' incompatible with "this" of type ' + this_.constructor.name);
 }
 if (!this_.$$.ptr) {
  throwBindingError("cannot call emscripten binding method " + humanName + " on deleted object");
 }
 return upcastPointer(this_.$$.ptr, this_.$$.ptrType.registeredClass, classType.registeredClass);
}

function __embind_register_class_class_property(rawClassType, fieldName, rawFieldType, rawFieldPtr, getterSignature, getter, setterSignature, setter) {
 fieldName = readLatin1String(fieldName);
 getter = embind__requireFunction(getterSignature, getter);
 whenDependentTypesAreResolved([], [ rawClassType ], function(classType) {
  classType = classType[0];
  var humanName = classType.name + "." + fieldName;
  var desc = {
   get: function() {
    throwUnboundTypeError("Cannot access " + humanName + " due to unbound types", [ rawFieldType ]);
   },
   enumerable: true,
   configurable: true
  };
  if (setter) {
   desc.set = function() {
    throwUnboundTypeError("Cannot access " + humanName + " due to unbound types", [ rawFieldType ]);
   };
  } else {
   desc.set = function(v) {
    throwBindingError(humanName + " is a read-only property");
   };
  }
  Object.defineProperty(classType.registeredClass.constructor, fieldName, desc);
  whenDependentTypesAreResolved([], [ rawFieldType ], function(fieldType) {
   fieldType = fieldType[0];
   var desc = {
    get: function() {
     return fieldType["fromWireType"](getter(rawFieldPtr));
    },
    enumerable: true
   };
   if (setter) {
    setter = embind__requireFunction(setterSignature, setter);
    desc.set = function(v) {
     var destructors = [];
     setter(rawFieldPtr, fieldType["toWireType"](destructors, v));
     runDestructors(destructors);
    };
   }
   Object.defineProperty(classType.registeredClass.constructor, fieldName, desc);
   return [];
  });
  return [];
 });
}

function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {
 assert(argCount > 0);
 var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
 invoker = embind__requireFunction(invokerSignature, invoker);
 var args = [ rawConstructor ];
 var destructors = [];
 whenDependentTypesAreResolved([], [ rawClassType ], function(classType) {
  classType = classType[0];
  var humanName = "constructor " + classType.name;
  if (undefined === classType.registeredClass.constructor_body) {
   classType.registeredClass.constructor_body = [];
  }
  if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {
   throw new BindingError("Cannot register multiple constructors with identical number of parameters (" + (argCount - 1) + ") for class '" + classType.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
  }
  classType.registeredClass.constructor_body[argCount - 1] = function unboundTypeHandler() {
   throwUnboundTypeError("Cannot construct " + classType.name + " due to unbound types", rawArgTypes);
  };
  whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
   classType.registeredClass.constructor_body[argCount - 1] = function constructor_body() {
    if (arguments.length !== argCount - 1) {
     throwBindingError(humanName + " called with " + arguments.length + " arguments, expected " + (argCount - 1));
    }
    destructors.length = 0;
    args.length = argCount;
    for (var i = 1; i < argCount; ++i) {
     args[i] = argTypes[i]["toWireType"](destructors, arguments[i - 1]);
    }
    var ptr = invoker.apply(null, args);
    runDestructors(destructors);
    return argTypes[0]["fromWireType"](ptr);
   };
   return [];
  });
  return [];
 });
}

function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual) {
 var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
 methodName = readLatin1String(methodName);
 rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
 whenDependentTypesAreResolved([], [ rawClassType ], function(classType) {
  classType = classType[0];
  var humanName = classType.name + "." + methodName;
  if (isPureVirtual) {
   classType.registeredClass.pureVirtualFunctions.push(methodName);
  }
  function unboundTypesHandler() {
   throwUnboundTypeError("Cannot call " + humanName + " due to unbound types", rawArgTypes);
  }
  var proto = classType.registeredClass.instancePrototype;
  var method = proto[methodName];
  if (undefined === method || undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {
   unboundTypesHandler.argCount = argCount - 2;
   unboundTypesHandler.className = classType.name;
   proto[methodName] = unboundTypesHandler;
  } else {
   ensureOverloadTable(proto, methodName, humanName);
   proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
  }
  whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
   var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);
   if (undefined === proto[methodName].overloadTable) {
    memberFunction.argCount = argCount - 2;
    proto[methodName] = memberFunction;
   } else {
    proto[methodName].overloadTable[argCount - 2] = memberFunction;
   }
   return [];
  });
  return [];
 });
}

function __embind_register_class_property(classType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
 fieldName = readLatin1String(fieldName);
 getter = embind__requireFunction(getterSignature, getter);
 whenDependentTypesAreResolved([], [ classType ], function(classType) {
  classType = classType[0];
  var humanName = classType.name + "." + fieldName;
  var desc = {
   get: function() {
    throwUnboundTypeError("Cannot access " + humanName + " due to unbound types", [ getterReturnType, setterArgumentType ]);
   },
   enumerable: true,
   configurable: true
  };
  if (setter) {
   desc.set = function() {
    throwUnboundTypeError("Cannot access " + humanName + " due to unbound types", [ getterReturnType, setterArgumentType ]);
   };
  } else {
   desc.set = function(v) {
    throwBindingError(humanName + " is a read-only property");
   };
  }
  Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);
  whenDependentTypesAreResolved([], setter ? [ getterReturnType, setterArgumentType ] : [ getterReturnType ], function(types) {
   var getterReturnType = types[0];
   var desc = {
    get: function() {
     var ptr = validateThis(this, classType, humanName + " getter");
     return getterReturnType["fromWireType"](getter(getterContext, ptr));
    },
    enumerable: true
   };
   if (setter) {
    setter = embind__requireFunction(setterSignature, setter);
    var setterArgumentType = types[1];
    desc.set = function(v) {
     var ptr = validateThis(this, classType, humanName + " setter");
     var destructors = [];
     setter(setterContext, ptr, setterArgumentType["toWireType"](destructors, v));
     runDestructors(destructors);
    };
   }
   Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);
   return [];
  });
  return [];
 });
}

function __emval_decref(handle) {
 if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {
  emval_handle_array[handle] = undefined;
  emval_free_list.push(handle);
 }
}

function __embind_register_emval(rawType, name) {
 name = readLatin1String(name);
 registerType(rawType, {
  name: name,
  "fromWireType": function(handle) {
   var rv = emval_handle_array[handle].value;
   __emval_decref(handle);
   return rv;
  },
  "toWireType": function(destructors, value) {
   return __emval_register(value);
  },
  "argPackAdvance": 8,
  "readValueFromPointer": simpleReadValueFromPointer,
  destructorFunction: null
 });
}

function enumReadValueFromPointer(name, shift, signed) {
 switch (shift) {
 case 0:
  return function(pointer) {
   var heap = signed ? HEAP8 : HEAPU8;
   return this["fromWireType"](heap[pointer]);
  };

 case 1:
  return function(pointer) {
   var heap = signed ? HEAP16 : HEAPU16;
   return this["fromWireType"](heap[pointer >> 1]);
  };

 case 2:
  return function(pointer) {
   var heap = signed ? HEAP32 : HEAPU32;
   return this["fromWireType"](heap[pointer >> 2]);
  };

 default:
  throw new TypeError("Unknown integer type: " + name);
 }
}

function __embind_register_enum(rawType, name, size, isSigned) {
 var shift = getShiftFromSize(size);
 name = readLatin1String(name);
 function ctor() {}
 ctor.values = {};
 registerType(rawType, {
  name: name,
  constructor: ctor,
  "fromWireType": function(c) {
   return this.constructor.values[c];
  },
  "toWireType": function(destructors, c) {
   return c.value;
  },
  "argPackAdvance": 8,
  "readValueFromPointer": enumReadValueFromPointer(name, shift, isSigned),
  destructorFunction: null
 });
 exposePublicSymbol(name, ctor);
}

function __embind_register_enum_value(rawEnumType, name, enumValue) {
 var enumType = requireRegisteredType(rawEnumType, "enum");
 name = readLatin1String(name);
 var Enum = enumType.constructor;
 var Value = Object.create(enumType.constructor.prototype, {
  value: {
   value: enumValue
  },
  constructor: {
   value: createNamedFunction(enumType.name + "_" + name, function() {})
  }
 });
 Enum.values[enumValue] = Value;
 Enum[name] = Value;
}

function _embind_repr(v) {
 if (v === null) {
  return "null";
 }
 var t = typeof v;
 if (t === "object" || t === "array" || t === "function") {
  return v.toString();
 } else {
  return "" + v;
 }
}

function floatReadValueFromPointer(name, shift) {
 switch (shift) {
 case 2:
  return function(pointer) {
   return this["fromWireType"](HEAPF32[pointer >> 2]);
  };

 case 3:
  return function(pointer) {
   return this["fromWireType"](HEAPF64[pointer >> 3]);
  };

 default:
  throw new TypeError("Unknown float type: " + name);
 }
}

function __embind_register_float(rawType, name, size) {
 var shift = getShiftFromSize(size);
 name = readLatin1String(name);
 registerType(rawType, {
  name: name,
  "fromWireType": function(value) {
   return value;
  },
  "toWireType": function(destructors, value) {
   if (typeof value !== "number" && typeof value !== "boolean") {
    throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
   }
   return value;
  },
  "argPackAdvance": 8,
  "readValueFromPointer": floatReadValueFromPointer(name, shift),
  destructorFunction: null
 });
}

function __embind_register_function(name, argCount, rawArgTypesAddr, signature, rawInvoker, fn) {
 var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
 name = readLatin1String(name);
 rawInvoker = embind__requireFunction(signature, rawInvoker);
 exposePublicSymbol(name, function() {
  throwUnboundTypeError("Cannot call " + name + " due to unbound types", argTypes);
 }, argCount - 1);
 whenDependentTypesAreResolved([], argTypes, function(argTypes) {
  var invokerArgsArray = [ argTypes[0], null ].concat(argTypes.slice(1));
  replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null, rawInvoker, fn), argCount - 1);
  return [];
 });
}

function integerReadValueFromPointer(name, shift, signed) {
 switch (shift) {
 case 0:
  return signed ? function readS8FromPointer(pointer) {
   return HEAP8[pointer];
  } : function readU8FromPointer(pointer) {
   return HEAPU8[pointer];
  };

 case 1:
  return signed ? function readS16FromPointer(pointer) {
   return HEAP16[pointer >> 1];
  } : function readU16FromPointer(pointer) {
   return HEAPU16[pointer >> 1];
  };

 case 2:
  return signed ? function readS32FromPointer(pointer) {
   return HEAP32[pointer >> 2];
  } : function readU32FromPointer(pointer) {
   return HEAPU32[pointer >> 2];
  };

 default:
  throw new TypeError("Unknown integer type: " + name);
 }
}

function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {
 name = readLatin1String(name);
 if (maxRange === -1) {
  maxRange = 4294967295;
 }
 var shift = getShiftFromSize(size);
 var fromWireType = function(value) {
  return value;
 };
 if (minRange === 0) {
  var bitshift = 32 - 8 * size;
  fromWireType = function(value) {
   return value << bitshift >>> bitshift;
  };
 }
 var isUnsignedType = name.indexOf("unsigned") != -1;
 registerType(primitiveType, {
  name: name,
  "fromWireType": fromWireType,
  "toWireType": function(destructors, value) {
   if (typeof value !== "number" && typeof value !== "boolean") {
    throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
   }
   if (value < minRange || value > maxRange) {
    throw new TypeError('Passing a number "' + _embind_repr(value) + '" from JS side to C/C++ side to an argument of type "' + name + '", which is outside the valid range [' + minRange + ", " + maxRange + "]!");
   }
   return isUnsignedType ? value >>> 0 : value | 0;
  },
  "argPackAdvance": 8,
  "readValueFromPointer": integerReadValueFromPointer(name, shift, minRange !== 0),
  destructorFunction: null
 });
}

function __embind_register_memory_view(rawType, dataTypeIndex, name) {
 var typeMapping = [ Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array ];
 var TA = typeMapping[dataTypeIndex];
 function decodeMemoryView(handle) {
  handle = handle >> 2;
  var heap = HEAPU32;
  var size = heap[handle];
  var data = heap[handle + 1];
  return new TA(buffer, data, size);
 }
 name = readLatin1String(name);
 registerType(rawType, {
  name: name,
  "fromWireType": decodeMemoryView,
  "argPackAdvance": 8,
  "readValueFromPointer": decodeMemoryView
 }, {
  ignoreDuplicateRegistrations: true
 });
}

function __embind_register_std_string(rawType, name) {
 name = readLatin1String(name);
 var stdStringIsUTF8 = name === "std::string";
 registerType(rawType, {
  name: name,
  "fromWireType": function(value) {
   var length = HEAPU32[value >> 2];
   var str;
   if (stdStringIsUTF8) {
    var decodeStartPtr = value + 4;
    for (var i = 0; i <= length; ++i) {
     var currentBytePtr = value + 4 + i;
     if (i == length || HEAPU8[currentBytePtr] == 0) {
      var maxRead = currentBytePtr - decodeStartPtr;
      var stringSegment = UTF8ToString(decodeStartPtr, maxRead);
      if (str === undefined) {
       str = stringSegment;
      } else {
       str += String.fromCharCode(0);
       str += stringSegment;
      }
      decodeStartPtr = currentBytePtr + 1;
     }
    }
   } else {
    var a = new Array(length);
    for (var i = 0; i < length; ++i) {
     a[i] = String.fromCharCode(HEAPU8[value + 4 + i]);
    }
    str = a.join("");
   }
   _free(value);
   return str;
  },
  "toWireType": function(destructors, value) {
   if (value instanceof ArrayBuffer) {
    value = new Uint8Array(value);
   }
   var getLength;
   var valueIsOfTypeString = typeof value === "string";
   if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
    throwBindingError("Cannot pass non-string to std::string");
   }
   if (stdStringIsUTF8 && valueIsOfTypeString) {
    getLength = function() {
     return lengthBytesUTF8(value);
    };
   } else {
    getLength = function() {
     return value.length;
    };
   }
   var length = getLength();
   var ptr = _malloc(4 + length + 1);
   HEAPU32[ptr >> 2] = length;
   if (stdStringIsUTF8 && valueIsOfTypeString) {
    stringToUTF8(value, ptr + 4, length + 1);
   } else {
    if (valueIsOfTypeString) {
     for (var i = 0; i < length; ++i) {
      var charCode = value.charCodeAt(i);
      if (charCode > 255) {
       _free(ptr);
       throwBindingError("String has UTF-16 code units that do not fit in 8 bits");
      }
      HEAPU8[ptr + 4 + i] = charCode;
     }
    } else {
     for (var i = 0; i < length; ++i) {
      HEAPU8[ptr + 4 + i] = value[i];
     }
    }
   }
   if (destructors !== null) {
    destructors.push(_free, ptr);
   }
   return ptr;
  },
  "argPackAdvance": 8,
  "readValueFromPointer": simpleReadValueFromPointer,
  destructorFunction: function(ptr) {
   _free(ptr);
  }
 });
}

function __embind_register_std_wstring(rawType, charSize, name) {
 name = readLatin1String(name);
 var decodeString, encodeString, getHeap, lengthBytesUTF, shift;
 if (charSize === 2) {
  decodeString = UTF16ToString;
  encodeString = stringToUTF16;
  lengthBytesUTF = lengthBytesUTF16;
  getHeap = function() {
   return HEAPU16;
  };
  shift = 1;
 } else if (charSize === 4) {
  decodeString = UTF32ToString;
  encodeString = stringToUTF32;
  lengthBytesUTF = lengthBytesUTF32;
  getHeap = function() {
   return HEAPU32;
  };
  shift = 2;
 }
 registerType(rawType, {
  name: name,
  "fromWireType": function(value) {
   var length = HEAPU32[value >> 2];
   var HEAP = getHeap();
   var str;
   var decodeStartPtr = value + 4;
   for (var i = 0; i <= length; ++i) {
    var currentBytePtr = value + 4 + i * charSize;
    if (i == length || HEAP[currentBytePtr >> shift] == 0) {
     var maxReadBytes = currentBytePtr - decodeStartPtr;
     var stringSegment = decodeString(decodeStartPtr, maxReadBytes);
     if (str === undefined) {
      str = stringSegment;
     } else {
      str += String.fromCharCode(0);
      str += stringSegment;
     }
     decodeStartPtr = currentBytePtr + charSize;
    }
   }
   _free(value);
   return str;
  },
  "toWireType": function(destructors, value) {
   if (!(typeof value === "string")) {
    throwBindingError("Cannot pass non-string to C++ string type " + name);
   }
   var length = lengthBytesUTF(value);
   var ptr = _malloc(4 + length + charSize);
   HEAPU32[ptr >> 2] = length >> shift;
   encodeString(value, ptr + 4, length + charSize);
   if (destructors !== null) {
    destructors.push(_free, ptr);
   }
   return ptr;
  },
  "argPackAdvance": 8,
  "readValueFromPointer": simpleReadValueFromPointer,
  destructorFunction: function(ptr) {
   _free(ptr);
  }
 });
}

function __embind_register_value_object(rawType, name, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {
 structRegistrations[rawType] = {
  name: readLatin1String(name),
  rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),
  rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),
  fields: []
 };
}

function __embind_register_value_object_field(structType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
 structRegistrations[structType].fields.push({
  fieldName: readLatin1String(fieldName),
  getterReturnType: getterReturnType,
  getter: embind__requireFunction(getterSignature, getter),
  getterContext: getterContext,
  setterArgumentType: setterArgumentType,
  setter: embind__requireFunction(setterSignature, setter),
  setterContext: setterContext
 });
}

function __embind_register_void(rawType, name) {
 name = readLatin1String(name);
 registerType(rawType, {
  isVoid: true,
  name: name,
  "argPackAdvance": 0,
  "fromWireType": function() {
   return undefined;
  },
  "toWireType": function(destructors, o) {
   return undefined;
  }
 });
}

function __emval_as(handle, returnType, destructorsRef) {
 handle = requireHandle(handle);
 returnType = requireRegisteredType(returnType, "emval::as");
 var destructors = [];
 var rd = __emval_register(destructors);
 HEAP32[destructorsRef >> 2] = rd;
 return returnType["toWireType"](destructors, handle);
}

function __emval_allocateDestructors(destructorsRef) {
 var destructors = [];
 HEAP32[destructorsRef >> 2] = __emval_register(destructors);
 return destructors;
}

var emval_symbols = {};

function getStringOrSymbol(address) {
 var symbol = emval_symbols[address];
 if (symbol === undefined) {
  return readLatin1String(address);
 } else {
  return symbol;
 }
}

var emval_methodCallers = [];

function __emval_call_method(caller, handle, methodName, destructorsRef, args) {
 caller = emval_methodCallers[caller];
 handle = requireHandle(handle);
 methodName = getStringOrSymbol(methodName);
 return caller(handle, methodName, __emval_allocateDestructors(destructorsRef), args);
}

function __emval_call_void_method(caller, handle, methodName, args) {
 caller = emval_methodCallers[caller];
 handle = requireHandle(handle);
 methodName = getStringOrSymbol(methodName);
 caller(handle, methodName, null, args);
}

function __emval_addMethodCaller(caller) {
 var id = emval_methodCallers.length;
 emval_methodCallers.push(caller);
 return id;
}

function __emval_lookupTypes(argCount, argTypes) {
 var a = new Array(argCount);
 for (var i = 0; i < argCount; ++i) {
  a[i] = requireRegisteredType(HEAP32[(argTypes >> 2) + i], "parameter " + i);
 }
 return a;
}

function __emval_get_method_caller(argCount, argTypes) {
 var types = __emval_lookupTypes(argCount, argTypes);
 var retType = types[0];
 var signatureName = retType.name + "_$" + types.slice(1).map(function(t) {
  return t.name;
 }).join("_") + "$";
 var params = [ "retType" ];
 var args = [ retType ];
 var argsList = "";
 for (var i = 0; i < argCount - 1; ++i) {
  argsList += (i !== 0 ? ", " : "") + "arg" + i;
  params.push("argType" + i);
  args.push(types[1 + i]);
 }
 var functionName = makeLegalFunctionName("methodCaller_" + signatureName);
 var functionBody = "return function " + functionName + "(handle, name, destructors, args) {\n";
 var offset = 0;
 for (var i = 0; i < argCount - 1; ++i) {
  functionBody += "    var arg" + i + " = argType" + i + ".readValueFromPointer(args" + (offset ? "+" + offset : "") + ");\n";
  offset += types[i + 1]["argPackAdvance"];
 }
 functionBody += "    var rv = handle[name](" + argsList + ");\n";
 for (var i = 0; i < argCount - 1; ++i) {
  if (types[i + 1]["deleteObject"]) {
   functionBody += "    argType" + i + ".deleteObject(arg" + i + ");\n";
  }
 }
 if (!retType.isVoid) {
  functionBody += "    return retType.toWireType(destructors, rv);\n";
 }
 functionBody += "};\n";
 params.push(functionBody);
 var invokerFunction = new_(Function, params).apply(null, args);
 return __emval_addMethodCaller(invokerFunction);
}

function __emval_get_module_property(name) {
 name = getStringOrSymbol(name);
 return __emval_register(Module[name]);
}

function __emval_get_property(handle, key) {
 handle = requireHandle(handle);
 key = requireHandle(key);
 return __emval_register(handle[key]);
}

function __emval_incref(handle) {
 if (handle > 4) {
  emval_handle_array[handle].refcount += 1;
 }
}

function __emval_new_cstring(v) {
 return __emval_register(getStringOrSymbol(v));
}

function __emval_run_destructors(handle) {
 var destructors = emval_handle_array[handle].value;
 runDestructors(destructors);
 __emval_decref(handle);
}

function __emval_take_value(type, argv) {
 type = requireRegisteredType(type, "_emval_take_value");
 var v = type["readValueFromPointer"](argv);
 return __emval_register(v);
}

function _abort() {
 abort();
}

function emscripten_realloc_buffer(size) {
 try {
  wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);
  updateGlobalBufferAndViews(wasmMemory.buffer);
  return 1;
 } catch (e) {}
}

function _emscripten_resize_heap(requestedSize) {
 var oldSize = HEAPU8.length;
 requestedSize = requestedSize >>> 0;
 var maxHeapSize = 2147483648;
 if (requestedSize > maxHeapSize) {
  return false;
 }
 for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
  var overGrownHeapSize = oldSize * (1 + .2 / cutDown);
  overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
  var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
  var replacement = emscripten_realloc_buffer(newSize);
  if (replacement) {
   return true;
  }
 }
 return false;
}

var SYSCALLS = {
 mappings: {},
 buffers: [ null, [], [] ],
 printChar: function(stream, curr) {
  var buffer = SYSCALLS.buffers[stream];
  if (curr === 0 || curr === 10) {
   (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));
   buffer.length = 0;
  } else {
   buffer.push(curr);
  }
 },
 varargs: undefined,
 get: function() {
  SYSCALLS.varargs += 4;
  var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
  return ret;
 },
 getStr: function(ptr) {
  var ret = UTF8ToString(ptr);
  return ret;
 },
 get64: function(low, high) {
  return low;
 }
};

function _fd_close(fd) {
 return 0;
}

function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {}

function _fd_write(fd, iov, iovcnt, pnum) {
 var num = 0;
 for (var i = 0; i < iovcnt; i++) {
  var ptr = HEAP32[iov + i * 8 >> 2];
  var len = HEAP32[iov + (i * 8 + 4) >> 2];
  for (var j = 0; j < len; j++) {
   SYSCALLS.printChar(fd, HEAPU8[ptr + j]);
  }
  num += len;
 }
 HEAP32[pnum >> 2] = num;
 return 0;
}

function _setTempRet0($i) {
 setTempRet0($i | 0);
}

init_emval();

PureVirtualError = Module["PureVirtualError"] = extendError(Error, "PureVirtualError");

embind_init_charCodes();

init_embind();

BindingError = Module["BindingError"] = extendError(Error, "BindingError");

InternalError = Module["InternalError"] = extendError(Error, "InternalError");

init_ClassHandle();

init_RegisteredPointer();

UnboundTypeError = Module["UnboundTypeError"] = extendError(Error, "UnboundTypeError");

var ASSERTIONS = false;

function intArrayToString(array) {
 var ret = [];
 for (var i = 0; i < array.length; i++) {
  var chr = array[i];
  if (chr > 255) {
   if (ASSERTIONS) {
    assert(false, "Character code " + chr + " (" + String.fromCharCode(chr) + ")  at offset " + i + " not in 0x00-0xFF.");
   }
   chr &= 255;
  }
  ret.push(String.fromCharCode(chr));
 }
 return ret.join("");
}

var decodeBase64 = typeof atob === "function" ? atob : function(input) {
 var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
 var output = "";
 var chr1, chr2, chr3;
 var enc1, enc2, enc3, enc4;
 var i = 0;
 input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
 do {
  enc1 = keyStr.indexOf(input.charAt(i++));
  enc2 = keyStr.indexOf(input.charAt(i++));
  enc3 = keyStr.indexOf(input.charAt(i++));
  enc4 = keyStr.indexOf(input.charAt(i++));
  chr1 = enc1 << 2 | enc2 >> 4;
  chr2 = (enc2 & 15) << 4 | enc3 >> 2;
  chr3 = (enc3 & 3) << 6 | enc4;
  output = output + String.fromCharCode(chr1);
  if (enc3 !== 64) {
   output = output + String.fromCharCode(chr2);
  }
  if (enc4 !== 64) {
   output = output + String.fromCharCode(chr3);
  }
 } while (i < input.length);
 return output;
};

function intArrayFromBase64(s) {
 if (typeof ENVIRONMENT_IS_NODE === "boolean" && ENVIRONMENT_IS_NODE) {
  var buf;
  try {
   buf = Buffer.from(s, "base64");
  } catch (_) {
   buf = new Buffer(s, "base64");
  }
  return new Uint8Array(buf["buffer"], buf["byteOffset"], buf["byteLength"]);
 }
 try {
  var decoded = decodeBase64(s);
  var bytes = new Uint8Array(decoded.length);
  for (var i = 0; i < decoded.length; ++i) {
   bytes[i] = decoded.charCodeAt(i);
  }
  return bytes;
 } catch (_) {
  throw new Error("Converting base64 string to bytes failed.");
 }
}

function tryParseAsDataURI(filename) {
 if (!isDataURI(filename)) {
  return;
 }
 return intArrayFromBase64(filename.slice(dataURIPrefix.length));
}

var asmLibraryArg = {
 "n": __embind_create_inheriting_constructor,
 "H": __embind_finalize_value_object,
 "A": __embind_register_bool,
 "c": __embind_register_class,
 "i": __embind_register_class_class_function,
 "f": __embind_register_class_class_property,
 "r": __embind_register_class_constructor,
 "a": __embind_register_class_function,
 "b": __embind_register_class_property,
 "z": __embind_register_emval,
 "k": __embind_register_enum,
 "j": __embind_register_enum_value,
 "p": __embind_register_float,
 "K": __embind_register_function,
 "h": __embind_register_integer,
 "g": __embind_register_memory_view,
 "q": __embind_register_std_string,
 "m": __embind_register_std_wstring,
 "J": __embind_register_value_object,
 "I": __embind_register_value_object_field,
 "B": __embind_register_void,
 "l": __emval_as,
 "G": __emval_call_method,
 "e": __emval_call_void_method,
 "D": __emval_decref,
 "d": __emval_get_method_caller,
 "L": __emval_get_module_property,
 "u": __emval_get_property,
 "C": __emval_incref,
 "E": __emval_new_cstring,
 "F": __emval_run_destructors,
 "t": __emval_take_value,
 "s": _abort,
 "x": _emscripten_resize_heap,
 "y": _fd_close,
 "v": _fd_seek,
 "o": _fd_write,
 "w": _setTempRet0
};

var asm = createWasm();

var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
 return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["N"]).apply(null, arguments);
};

var _malloc = Module["_malloc"] = function() {
 return (_malloc = Module["_malloc"] = Module["asm"]["P"]).apply(null, arguments);
};

var ___getTypeName = Module["___getTypeName"] = function() {
 return (___getTypeName = Module["___getTypeName"] = Module["asm"]["Q"]).apply(null, arguments);
};

var ___embind_register_native_and_builtin_types = Module["___embind_register_native_and_builtin_types"] = function() {
 return (___embind_register_native_and_builtin_types = Module["___embind_register_native_and_builtin_types"] = Module["asm"]["R"]).apply(null, arguments);
};

var _free = Module["_free"] = function() {
 return (_free = Module["_free"] = Module["asm"]["S"]).apply(null, arguments);
};

var dynCall_jiji = Module["dynCall_jiji"] = function() {
 return (dynCall_jiji = Module["dynCall_jiji"] = Module["asm"]["T"]).apply(null, arguments);
};

var calledRun;

function ExitStatus(status) {
 this.name = "ExitStatus";
 this.message = "Program terminated with exit(" + status + ")";
 this.status = status;
}

dependenciesFulfilled = function runCaller() {
 if (!calledRun) run();
 if (!calledRun) dependenciesFulfilled = runCaller;
};

function run(args) {
 args = args || arguments_;
 if (runDependencies > 0) {
  return;
 }
 preRun();
 if (runDependencies > 0) {
  return;
 }
 function doRun() {
  if (calledRun) return;
  calledRun = true;
  Module["calledRun"] = true;
  if (ABORT) return;
  initRuntime();
  preMain();
  readyPromiseResolve(Module);
  if (Module["onRuntimeInitialized"]) Module["onRuntimeInitialized"]();
  postRun();
 }
 if (Module["setStatus"]) {
  Module["setStatus"]("Running...");
  setTimeout(function() {
   setTimeout(function() {
    Module["setStatus"]("");
   }, 1);
   doRun();
  }, 1);
 } else {
  doRun();
 }
}

Module["run"] = run;

if (Module["preInit"]) {
 if (typeof Module["preInit"] == "function") Module["preInit"] = [ Module["preInit"] ];
 while (Module["preInit"].length > 0) {
  Module["preInit"].pop()();
 }
}

run();

function makeMatrix(m2d) {
    const m = new DOMMatrix();
    m.a = m2d.xx;
    m.b = m2d.xy;
    m.c = m2d.yx;
    m.d = m2d.yy;
    m.e = m2d.tx;
    m.f = m2d.ty;
    return m;
}

Module.onRuntimeInitialized = function () {
    const {
        RenderPaintStyle,
        FillRule,
        RenderPath,
        RenderPaint,
        Renderer,
        StrokeCap,
        StrokeJoin,
        BlendMode
    } = Module;

    const {
        fill,
        stroke
    } = RenderPaintStyle;

    const {
        evenOdd,
        nonZero
    } = FillRule;

    var CanvasRenderPath = RenderPath.extend("CanvasRenderPath", {
        __construct: function () {
            this.__parent.__construct.call(this);
            this._path2D = new Path2D();
        },
        reset: function () {
            this._path2D = new Path2D();
        },
        addPath: function (path, m2d) {
            this._path2D.addPath(path._path2D, makeMatrix(m2d));
        },
        fillRule: function(fillRule) {
            this._fillRule = fillRule;
        },
        moveTo: function (x, y) {
            this._path2D.moveTo(x, y);
        },
        lineTo: function (x, y) {
            this._path2D.lineTo(x, y);
        },
        cubicTo: function (ox, oy, ix, iy, x, y) {
            this._path2D.bezierCurveTo(ox, oy, ix, iy, x, y);
        },
        close: function () {
            this._path2D.closePath();
        }
    });

    function _colorStyle(value) {
        return 'rgba(' + ((0x00ff0000 & value) >>>
                16) + ',' + ((0x0000ff00 &
                value) >>> 8) + ',' + ((0x000000ff & value) >>> 0) + ',' +
            (((0xff000000 & value) >>> 24) / 0xFF) + ')'
    }
    var CanvasRenderPaint = RenderPaint.extend("CanvasRenderPaint", {
        color: function (value) {
            this._value = _colorStyle(value);
        },
        thickness: function (value) {
            this._thickness = value;
        },
        join: function (value) {
            switch (value) {
                case StrokeJoin.miter:
                    this._join = 'miter';
                    break;
                case StrokeJoin.round:
                    this._join = 'round';
                    break;
                case StrokeJoin.bevel:
                    this._join = 'bevel';
                    break;
            }
        },
        cap: function (value) {
            switch (value) {
                case StrokeCap.butt:
                    this._cap = 'butt';
                    break;
                case StrokeCap.round:
                    this._cap = 'round';
                    break;
                case StrokeCap.square:
                    this._cap = 'square';
                    break;
            }
        },
        style: function (value) {
            this._style = value;
        },
        blendMode: function (value) {
            switch (value) {
                case BlendMode.srcOver:
                    this._blend = 'source-over';
                    break;
                case BlendMode.screen:
                    this._blend = 'screen';
                    break;
                case BlendMode.overlay:
                    this._blend = 'overlay';
                    break;
                case BlendMode.darken:
                    this._blend = 'darken';
                    break;
                case BlendMode.lighten:
                    this._blend = 'lighten';
                    break;
                case BlendMode.colorDodge:
                    this._blend = 'color-dodge';
                    break;
                case BlendMode.colorBurn:
                    this._blend = 'color-burn';
                    break;
                case BlendMode.hardLight:
                    this._blend = 'hard-light';
                    break;
                case BlendMode.softLight:
                    this._blend = 'soft-light';
                    break;
                case BlendMode.difference:
                    this._blend = 'difference';
                    break;
                case BlendMode.exclusion:
                    this._blend = 'exclusion';
                    break;
                case BlendMode.multiply:
                    this._blend = 'multiply';
                    break;
                case BlendMode.hue:
                    this._blend = 'hue';
                    break;
                case BlendMode.saturation:
                    this._blend = 'saturation';
                    break;
                case BlendMode.color:
                    this._blend = 'color';
                    break;
                case BlendMode.luminosity:
                    this._blend = 'luminosity';
                    break;
            }
        },
        linearGradient: function (sx, sy, ex, ey) {
            this._gradient = {
                sx,
                sy,
                ex,
                ey,
                stops: []
            };
        },
        radialGradient: function (sx, sy, ex, ey) {
            this._gradient = {
                sx,
                sy,
                ex,
                ey,
                stops: [],
                isRadial: true
            };
        },
        addStop: function (color, stop) {
            this._gradient.stops.push({
                color,
                stop
            });
        },

        completeGradient: function () {

        },

        draw: function (ctx, path) {
            let {
                _style,
                _value,
                _gradient,
                _blend
            } = this;

            ctx.globalCompositeOperation = _blend;

            if (_gradient != null) {
                const {
                    sx,
                    sy,
                    ex,
                    ey,
                    stops,
                    isRadial
                } = _gradient;

                if (isRadial) {
                    var dx = ex - sx;
                    var dy = ey - sy;
                    var radius = Math.sqrt(dx * dx + dy * dy);
                    _value = ctx.createRadialGradient(sx, sy, 0, sx, sy, radius);
                } else {
                    _value = ctx.createLinearGradient(sx, sy, ex, ey);
                }

                for (const {
                        stop,
                        color
                    } of stops) {
                    _value.addColorStop(stop, _colorStyle(color));
                }
                this._value = _value;
                this._gradient = null;
            }
            switch (_style) {
                case stroke:
                    ctx.strokeStyle = _value;
                    ctx.lineWidth = this._thickness;
                    ctx.lineCap = this._cap;
                    ctx.lineJoin = this._join;
                    ctx.stroke(path._path2D);
                    break;
                case fill:
                    ctx.fillStyle = _value;
                    ctx.fill(path._path2D, path._fillRule === evenOdd ? 'evenodd' : 'nonzero');
                    break;
            }
        }
    });

    Module.CanvasRenderer = Renderer.extend("Renderer", {
        __construct: function (ctx) {
            this.__parent.__construct.call(this);
            this._ctx = ctx;
        },
        save: function () {
            this._ctx.save();
        },
        restore: function () {
            this._ctx.restore();
        },
        transform: function (matrix) {
            this._ctx.transform(matrix.xx, matrix.xy, matrix.yx, matrix.yy, matrix.tx,
                matrix.ty);
        },
        drawPath: function (path, paint) {
            paint.draw(this._ctx, path);
        },
        clipPath: function (path) {
            this._ctx.clip(path._path2D, path._fillRule === evenOdd ? 'evenodd' : 'nonzero');
        }
    });

    Module.renderFactory = {
        makeRenderPaint: function () {
            return new CanvasRenderPaint();
        },
        makeRenderPath: function () {
            return new CanvasRenderPath();
        }
    };
};


  return Rive.ready
}
);
})();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Rive);


/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Fit": () => (/* binding */ Fit),
/* harmony export */   "Alignment": () => (/* binding */ Alignment),
/* harmony export */   "Layout": () => (/* binding */ Layout),
/* harmony export */   "RuntimeLoader": () => (/* binding */ RuntimeLoader),
/* harmony export */   "StateMachineInputType": () => (/* binding */ StateMachineInputType),
/* harmony export */   "StateMachineInput": () => (/* binding */ StateMachineInput),
/* harmony export */   "EventType": () => (/* binding */ EventType),
/* harmony export */   "LoopType": () => (/* binding */ LoopType),
/* harmony export */   "Rive": () => (/* binding */ Rive),
/* harmony export */   "Testing": () => (/* binding */ Testing)
/* harmony export */ });
/* harmony import */ var rive_canvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};

// Tracks playback states; numbers map to the runtime's numerical values
// i.e. play: 0, pause: 1, stop: 2
var PlaybackState;
(function (PlaybackState) {
    PlaybackState[PlaybackState["Play"] = 0] = "Play";
    PlaybackState[PlaybackState["Pause"] = 1] = "Pause";
    PlaybackState[PlaybackState["Stop"] = 2] = "Stop";
})(PlaybackState || (PlaybackState = {}));
// #region layout
// Fit options for the canvas
var Fit;
(function (Fit) {
    Fit["Cover"] = "cover";
    Fit["Contain"] = "contain";
    Fit["Fill"] = "fill";
    Fit["FitWidth"] = "fitWidth";
    Fit["FitHeight"] = "fitHeight";
    Fit["None"] = "none";
    Fit["ScaleDown"] = "scaleDown";
})(Fit || (Fit = {}));
// Alignment options for the canvas
var Alignment;
(function (Alignment) {
    Alignment["Center"] = "center";
    Alignment["TopLeft"] = "topLeft";
    Alignment["TopCenter"] = "topCenter";
    Alignment["TopRight"] = "topRight";
    Alignment["CenterLeft"] = "centerLeft";
    Alignment["CenterRight"] = "centerRight";
    Alignment["BottomLeft"] = "bottomLeft";
    Alignment["BottomCenter"] = "bottomCenter";
    Alignment["BottomRight"] = "bottomRight";
})(Alignment || (Alignment = {}));
// Alignment options for Rive animations in a HTML canvas
var Layout = /** @class */ (function () {
    function Layout(params) {
        var _a, _b, _c, _d, _e, _f;
        this.fit = (_a = params === null || params === void 0 ? void 0 : params.fit) !== null && _a !== void 0 ? _a : Fit.Contain;
        this.alignment = (_b = params === null || params === void 0 ? void 0 : params.alignment) !== null && _b !== void 0 ? _b : Alignment.Center;
        this.minX = (_c = params === null || params === void 0 ? void 0 : params.minX) !== null && _c !== void 0 ? _c : 0;
        this.minY = (_d = params === null || params === void 0 ? void 0 : params.minY) !== null && _d !== void 0 ? _d : 0;
        this.maxX = (_e = params === null || params === void 0 ? void 0 : params.maxX) !== null && _e !== void 0 ? _e : 0;
        this.maxY = (_f = params === null || params === void 0 ? void 0 : params.maxY) !== null && _f !== void 0 ? _f : 0;
    }
    // Alternative constructor to build a Layout from an interface/object
    Layout.new = function (_a) {
        var fit = _a.fit, alignment = _a.alignment, minX = _a.minX, minY = _a.minY, maxX = _a.maxX, maxY = _a.maxY;
        console.warn('This function is deprecated: please use `new Layout({})` instead');
        return new Layout({ fit: fit, alignment: alignment, minX: minX, minY: minY, maxX: maxX, maxY: maxY });
    };
    /**
     * Makes a copy of the layout, replacing any specified parameters
     */
    Layout.prototype.copyWith = function (_a) {
        var fit = _a.fit, alignment = _a.alignment, minX = _a.minX, minY = _a.minY, maxX = _a.maxX, maxY = _a.maxY;
        return new Layout({
            fit: fit !== null && fit !== void 0 ? fit : this.fit,
            alignment: alignment !== null && alignment !== void 0 ? alignment : this.alignment,
            minX: minX !== null && minX !== void 0 ? minX : this.minX,
            minY: minY !== null && minY !== void 0 ? minY : this.minY,
            maxX: maxX !== null && maxX !== void 0 ? maxX : this.maxX,
            maxY: maxY !== null && maxY !== void 0 ? maxY : this.maxY
        });
    };
    // Returns fit for the Wasm runtime format
    Layout.prototype.runtimeFit = function (rive) {
        if (this.cachedRuntimeFit)
            return this.cachedRuntimeFit;
        var fit;
        if (this.fit === Fit.Cover)
            fit = rive.Fit.cover;
        else if (this.fit === Fit.Contain)
            fit = rive.Fit.contain;
        else if (this.fit === Fit.Fill)
            fit = rive.Fit.fill;
        else if (this.fit === Fit.FitWidth)
            fit = rive.Fit.fitWidth;
        else if (this.fit === Fit.FitHeight)
            fit = rive.Fit.fitHeight;
        else if (this.fit === Fit.ScaleDown)
            fit = rive.Fit.scaleDown;
        else
            fit = rive.Fit.none;
        this.cachedRuntimeFit = fit;
        return fit;
    };
    // Returns alignment for the Wasm runtime format
    Layout.prototype.runtimeAlignment = function (rive) {
        if (this.cachedRuntimeAlignment)
            return this.cachedRuntimeAlignment;
        var alignment;
        if (this.alignment === Alignment.TopLeft)
            alignment = rive.Alignment.topLeft;
        else if (this.alignment === Alignment.TopCenter)
            alignment = rive.Alignment.topCenter;
        else if (this.alignment === Alignment.TopRight)
            alignment = rive.Alignment.topRight;
        else if (this.alignment === Alignment.CenterLeft)
            alignment = rive.Alignment.centerLeft;
        else if (this.alignment === Alignment.CenterRight)
            alignment = rive.Alignment.centerRight;
        else if (this.alignment === Alignment.BottomLeft)
            alignment = rive.Alignment.bottomLeft;
        else if (this.alignment === Alignment.BottomCenter)
            alignment = rive.Alignment.bottomCenter;
        else if (this.alignment === Alignment.BottomRight)
            alignment = rive.Alignment.bottomRight;
        else
            alignment = rive.Alignment.center;
        this.cachedRuntimeAlignment = alignment;
        return alignment;
    };
    return Layout;
}());

// Runtime singleton; use getInstance to provide a callback that returns the
// Rive runtime
var RuntimeLoader = /** @class */ (function () {
    // Class is never instantiated
    function RuntimeLoader() {
    }
    // Loads the runtime
    RuntimeLoader.loadRuntime = function () {
        rive_canvas__WEBPACK_IMPORTED_MODULE_0__.default({
            // Loads Wasm bundle
            locateFile: function (_) { return RuntimeLoader.wasmURL; }
        }).then(function (rive) {
            var _a;
            RuntimeLoader.runtime = rive;
            // Fire all the callbacks
            while (RuntimeLoader.callBackQueue.length > 0) {
                (_a = RuntimeLoader.callBackQueue.shift()) === null || _a === void 0 ? void 0 : _a(RuntimeLoader.runtime);
            }
        });
    };
    // Provides a runtime instance via a callback
    RuntimeLoader.getInstance = function (callback) {
        // If it's not loading, start loading runtime
        if (!RuntimeLoader.isLoading) {
            RuntimeLoader.isLoading = true;
            RuntimeLoader.loadRuntime();
        }
        if (!RuntimeLoader.runtime) {
            RuntimeLoader.callBackQueue.push(callback);
        }
        else {
            callback(RuntimeLoader.runtime);
        }
    };
    // Provides a runtime instance via a promise
    RuntimeLoader.awaitInstance = function () {
        return new Promise(function (resolve, reject) {
            return RuntimeLoader.getInstance(function (rive) { return resolve(rive); });
        });
    };
    // Manually sets the wasm url
    RuntimeLoader.setWasmUrl = function (url) {
        RuntimeLoader.wasmURL = url;
    };
    // Flag to indicate that loading has started/completed
    RuntimeLoader.isLoading = false;
    // List of callbacks for the runtime that come in while loading
    RuntimeLoader.callBackQueue = [];
    // Path to the Wasm file; default path works for testing only;
    // if embedded wasm is used then this is never used.
    RuntimeLoader.wasmURL = 'dist/rive.wasm';
    return RuntimeLoader;
}());

// #endregion
// #region animations
// Wraps animations and instances from the runtime and keeps track of playback
// state
var Animation = /** @class */ (function () {
    /**
     * Constructs a new animation
     * @constructor
     * @param {any} animation: runtime animation object
     * @param {any} instance: runtime animation instance object
     */
    function Animation(animation, runtime, playing) {
        this.animation = animation;
        this.playing = playing;
        this.loopCount = 0;
        // Time to which the animation should move to on the next render
        this.scrubTo = null;
        this.instance = new runtime.LinearAnimationInstance(animation);
    }
    Object.defineProperty(Animation.prototype, "name", {
        // Returns the animation's name
        get: function () {
            return this.animation.name;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Animation.prototype, "time", {
        // Returns the animation's current time
        get: function () {
            return this.instance.time;
        },
        // Sets the animation's current time
        set: function (value) {
            this.instance.time = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Animation.prototype, "loopValue", {
        // Returns the animation's loop type
        get: function () {
            return this.animation.loopValue;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Advances the animation by the give time. If the animation needs scrubbing,
     * time is ignored and the stored scrub value is used.
     * @param time the time to advance the animation by if no scrubbing required
     */
    Animation.prototype.advance = function (time) {
        if (this.scrubTo === null) {
            this.instance.advance(time);
        }
        else {
            this.instance.time = 0;
            this.instance.advance(this.scrubTo);
            this.scrubTo = null;
        }
    };
    Object.defineProperty(Animation.prototype, "needsScrub", {
        get: function () {
            return this.scrubTo !== null;
        },
        enumerable: false,
        configurable: true
    });
    return Animation;
}());
// #endregion
// #region state machines
var StateMachineInputType;
(function (StateMachineInputType) {
    StateMachineInputType[StateMachineInputType["Number"] = 56] = "Number";
    StateMachineInputType[StateMachineInputType["Trigger"] = 58] = "Trigger";
    StateMachineInputType[StateMachineInputType["Boolean"] = 59] = "Boolean";
})(StateMachineInputType || (StateMachineInputType = {}));
/**
 * An input for a state machine
 */
var StateMachineInput = /** @class */ (function () {
    function StateMachineInput(type, runtimeInput) {
        this.type = type;
        this.runtimeInput = runtimeInput;
    }
    Object.defineProperty(StateMachineInput.prototype, "name", {
        /**
         * Returns the name of the input
         */
        get: function () {
            return this.runtimeInput.name;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StateMachineInput.prototype, "value", {
        /**
         * Returns the current value of the input
         */
        get: function () {
            return this.runtimeInput.value;
        },
        /**
         * Sets the value of the input
         */
        set: function (value) {
            this.runtimeInput.value = value;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Fires a trigger; does nothing on Number or Boolean input types
     */
    StateMachineInput.prototype.fire = function () {
        if (this.type === StateMachineInputType.Trigger) {
            this.runtimeInput.fire();
        }
    };
    return StateMachineInput;
}());

var StateMachine = /** @class */ (function () {
    /**
     * @constructor
     * @param stateMachine runtime state machine object
     * @param instance runtime state machine instance object
     */
    function StateMachine(stateMachine, runtime, playing) {
        this.stateMachine = stateMachine;
        this.playing = playing;
        /**
         * Caches the inputs from the runtime
         */
        this.inputs = [];
        this.instance = new runtime.StateMachineInstance(stateMachine);
        this.initInputs(runtime);
    }
    Object.defineProperty(StateMachine.prototype, "name", {
        get: function () {
            return this.stateMachine.name;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StateMachine.prototype, "statesChanged", {
        /**
         * Returns a list of state names that have changed on this frame
         */
        get: function () {
            var names = [];
            for (var i = 0; i < this.instance.stateChangedCount(); i++) {
                names.push(this.instance.stateChangedNameByIndex(i));
            }
            return names;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Fetches references to the state machine's inputs and caches them
     * @param runtime an instance of the runtime; needed for the SMIInput types
     */
    StateMachine.prototype.initInputs = function (runtime) {
        // Fetch the inputs from the runtime if we don't have them
        for (var i = 0; i < this.instance.inputCount(); i++) {
            var input = this.instance.input(i);
            this.inputs.push(this.mapRuntimeInput(input, runtime));
        }
    };
    /**
     * Maps a runtime input to it's appropriate type
     * @param input
     */
    StateMachine.prototype.mapRuntimeInput = function (input, runtime) {
        if (input.type === runtime.SMIInput.bool) {
            return new StateMachineInput(StateMachineInputType.Boolean, input.asBool());
        }
        else if (input.type === runtime.SMIInput.number) {
            return new StateMachineInput(StateMachineInputType.Number, input.asNumber());
        }
        else if (input.type === runtime.SMIInput.trigger) {
            return new StateMachineInput(StateMachineInputType.Trigger, input.asTrigger());
        }
    };
    return StateMachine;
}());
// #endregion
// #region animator
/**
 * Manages animation
 */
var Animator = /** @class */ (function () {
    /**
     * Constructs a new animator
     * @constructor
     * @param runtime Rive runtime; needed to instance animations & state machines
     * @param artboard the artboard that holds all animations and state machines
     * @param animations optional list of animations
     * @param stateMachines optional list of state machines
     */
    function Animator(runtime, artboard, eventManager, animations, stateMachines) {
        if (animations === void 0) { animations = []; }
        if (stateMachines === void 0) { stateMachines = []; }
        this.runtime = runtime;
        this.artboard = artboard;
        this.eventManager = eventManager;
        this.animations = animations;
        this.stateMachines = stateMachines;
    }
    /**
     * Adds animations and state machines by their names. If names are shared
     * between animations & state machines, then the first one found will be
     * created. Best not to use the same names for these in your Rive file.
     * @param animatable the name(s) of animations and state machines to add
     * @returns a list of names of the playing animations and state machines
     */
    Animator.prototype.add = function (animatables, playing, fireEvent) {
        if (fireEvent === void 0) { fireEvent = true; }
        animatables = mapToStringArray(animatables);
        // If animatables is empty, play or pause everything
        if (animatables.length === 0) {
            this.animations.forEach(function (a) { return a.playing = playing; });
            this.stateMachines.forEach(function (m) { return m.playing = playing; });
        }
        else {
            // Play/pause already instanced items, or create new instances
            var instancedAnimationNames = this.animations.map(function (a) { return a.name; });
            var instancedMachineNames = this.stateMachines.map(function (m) { return m.name; });
            for (var i in animatables) {
                var aIndex = instancedAnimationNames.indexOf(animatables[i]);
                var mIndex = instancedMachineNames.indexOf(animatables[i]);
                if (aIndex >= 0 || mIndex >= 0) {
                    if (aIndex >= 0) {
                        // Animation is instanced, play/pause it
                        this.animations[aIndex].playing = playing;
                    }
                    else {
                        // State machine is instanced, play/pause it
                        this.stateMachines[mIndex].playing = playing;
                    }
                }
                else {
                    // Try to create a new animation instance
                    var anim = this.artboard.animationByName(animatables[i]);
                    if (anim) {
                        this.animations.push(new Animation(anim, this.runtime, playing));
                    }
                    else {
                        // Try to create a new state machine instance
                        var sm = this.artboard.stateMachineByName(animatables[i]);
                        if (sm) {
                            this.stateMachines.push(new StateMachine(sm, this.runtime, playing));
                        }
                    }
                }
            }
        }
        // Fire play/paused events for animations
        if (fireEvent) {
            if (playing) {
                this.eventManager.fire({
                    type: EventType.Play,
                    data: this.playing,
                });
            }
            else {
                this.eventManager.fire({
                    type: EventType.Pause,
                    data: this.paused,
                });
            }
        }
        return playing ? this.playing : this.paused;
    };
    /**
     * Play the named animations/state machines
     * @param animatables the names of the animations/machines to play; plays all if empty
     * @returns a list of the playing items
     */
    Animator.prototype.play = function (animatables) {
        return this.add(animatables, true);
    };
    /**
   * Pauses named animations and state machines, or everything if nothing is
   * specified
   * @param animatables names of the animations and state machines to pause
   * @returns a list of names of the animations and state machines paused
   */
    Animator.prototype.pause = function (animatables) {
        return this.add(animatables, false);
    };
    /**
     * Set time of named animations
     * @param animations names of the animations to scrub
     * @param value time scrub value, a floating point number to which the playhead is jumped
     * @returns a list of names of the animations that were scrubbed
     */
    Animator.prototype.scrub = function (animatables, value) {
        var forScrubbing = this.animations.filter(function (a) { return animatables.includes(a.name); });
        forScrubbing.forEach(function (a) { return a.scrubTo = value; });
        return forScrubbing.map(function (a) { return a.name; });
    };
    Object.defineProperty(Animator.prototype, "playing", {
        /**
         * Returns a list of names of all animations and state machines currently
         * playing
         */
        get: function () {
            return this.animations.filter(function (a) { return a.playing; }).map(function (a) { return a.name; }).concat(this.stateMachines.filter(function (m) { return m.playing; }).map(function (m) { return m.name; }));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Animator.prototype, "paused", {
        /**
         * Returns a list of names of all animations and state machines currently
         * paused
         */
        get: function () {
            return this.animations.filter(function (a) { return !a.playing; }).map(function (a) { return a.name; }).concat(this.stateMachines.filter(function (m) { return !m.playing; }).map(function (m) { return m.name; }));
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Stops and removes all named animations and state machines
     * @param animatables animations and state machines to remove
     * @returns a list of names of removed items
     */
    Animator.prototype.stop = function (animatables) {
        var _this = this;
        animatables = mapToStringArray(animatables);
        // If nothing's specified, wipe them out, all of them
        var removedNames = [];
        if (animatables.length === 0) {
            removedNames = this.animations.map(function (a) { return a.name; }).concat(this.stateMachines.map(function (m) { return m.name; }));
            this.animations.splice(0, this.animations.length);
            this.stateMachines.splice(0, this.stateMachines.length);
        }
        else {
            // Remove only the named animations/state machines
            var animationsToRemove = this.animations.filter(function (a) { return animatables.includes(a.name); });
            animationsToRemove.forEach(function (a) {
                return _this.animations.splice(_this.animations.indexOf(a), 1);
            });
            var machinesToRemove = this.stateMachines.filter(function (m) { return animatables.includes(m.name); });
            machinesToRemove.forEach(function (m) {
                return _this.stateMachines.splice(_this.stateMachines.indexOf(m), 1);
            });
            removedNames = animationsToRemove.map(function (a) { return a.name; }).concat(machinesToRemove.map(function (m) { return m.name; }));
        }
        this.eventManager.fire({
            type: EventType.Stop,
            data: removedNames,
        });
        // Return the list of animations removed
        return removedNames;
    };
    Object.defineProperty(Animator.prototype, "isPlaying", {
        /**
         * Returns true if at least one animation is active
         */
        get: function () {
            return this.animations.reduce(function (acc, curr) { return acc || curr.playing; }, false)
                || this.stateMachines.reduce(function (acc, curr) { return acc || curr.playing; }, false);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Animator.prototype, "isPaused", {
        /**
         * Returns true if all animations are paused and there's at least one animation
         */
        get: function () {
            return !this.isPlaying &&
                (this.animations.length > 0 || this.stateMachines.length > 0);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Animator.prototype, "isStopped", {
        /**
         * Returns true if there are no playing or paused animations/state machines
         */
        get: function () {
            return this.animations.length === 0 && this.stateMachines.length === 0;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * If there are no animations or state machines, add the first one found
     * @returns the name of the animation or state machine instanced
     */
    Animator.prototype.atLeastOne = function (playing, fireEvent) {
        if (fireEvent === void 0) { fireEvent = true; }
        var instancedName;
        if (this.animations.length === 0 && this.stateMachines.length === 0) {
            if (this.artboard.animationCount() > 0) {
                // Add the first animation
                this.add([instancedName = this.artboard.animationByIndex(0).name], playing, fireEvent);
            }
            else if (this.artboard.stateMachineCount() > 0) {
                // Add the first state machine
                this.add([instancedName = this.artboard.stateMachineByIndex(0).name], playing, fireEvent);
            }
        }
        return instancedName;
    };
    /**
     * Checks if any animations have looped and if so, fire the appropriate event
     */
    Animator.prototype.handleLooping = function () {
        for (var _i = 0, _a = this.animations.filter(function (a) { return a.playing; }); _i < _a.length; _i++) {
            var animation = _a[_i];
            // Emit if the animation looped
            if (animation.loopValue === 0 && animation.loopCount) {
                animation.loopCount = 0;
                // This is a one-shot; if it has ended, delete the instance
                this.stop(animation.name);
            }
            else if (animation.loopValue === 1 && animation.loopCount) {
                this.eventManager.fire({
                    type: EventType.Loop,
                    data: { animation: animation.name, type: LoopType.Loop }
                });
                animation.loopCount = 0;
            }
            // Wasm indicates a loop at each time the animation
            // changes direction, so a full loop/lap occurs every
            // two loop counts
            else if (animation.loopValue === 2 && animation.loopCount > 1) {
                this.eventManager.fire({
                    type: EventType.Loop,
                    data: { animation: animation.name, type: LoopType.PingPong }
                });
                animation.loopCount = 0;
            }
        }
    };
    /**
     * Checks if states have changed in state machines and fires a statechange
     * event
     */
    Animator.prototype.handleStateChanges = function () {
        var statesChanged = [];
        for (var _i = 0, _a = this.stateMachines.filter(function (sm) { return sm.playing; }); _i < _a.length; _i++) {
            var stateMachine = _a[_i];
            statesChanged.push.apply(statesChanged, stateMachine.statesChanged);
        }
        if (statesChanged.length > 0) {
            this.eventManager.fire({
                type: EventType.StateChange,
                data: statesChanged,
            });
        }
    };
    return Animator;
}());
// #endregion
// #region events
/**
 * Supported event types triggered in Rive
 */
var EventType;
(function (EventType) {
    EventType["Load"] = "load";
    EventType["LoadError"] = "loaderror";
    EventType["Play"] = "play";
    EventType["Pause"] = "pause";
    EventType["Stop"] = "stop";
    EventType["Loop"] = "loop";
    EventType["Draw"] = "draw";
    EventType["StateChange"] = "statechange";
})(EventType || (EventType = {}));
/**
 * Looping types: one-shot, loop, and ping-pong
 */
var LoopType;
(function (LoopType) {
    LoopType["OneShot"] = "oneshot";
    LoopType["Loop"] = "loop";
    LoopType["PingPong"] = "pingpong"; // has value 2 in runtime
})(LoopType || (LoopType = {}));
// Manages Rive events and listeners
var EventManager = /** @class */ (function () {
    function EventManager(listeners) {
        if (listeners === void 0) { listeners = []; }
        this.listeners = listeners;
    }
    // Gets listeners of specified type
    EventManager.prototype.getListeners = function (type) {
        return this.listeners.filter(function (e) { return e.type === type; });
    };
    // Adds a listener
    EventManager.prototype.add = function (listener) {
        if (!this.listeners.includes(listener)) {
            this.listeners.push(listener);
        }
    };
    /**
     * Removes a listener
     * @param listener the listener with the callback to be removed
     */
    EventManager.prototype.remove = function (listener) {
        // We can't simply look for the listener as it'll be a different instance to
        // one originally subscribed. Find all the listeners of the right type and
        // then check their callbacks which should match.
        for (var i = 0; i < this.listeners.length; i++) {
            var currentListener = this.listeners[i];
            if (currentListener.type === listener.type) {
                if (currentListener.callback === listener.callback) {
                    this.listeners.splice(i, 1);
                    break;
                }
            }
        }
    };
    /**
     * Clears all listeners of specified type, or every listener if no type is
     * specified
     * @param type the type of listeners to clear, or all listeners if not
     * specified
     */
    EventManager.prototype.removeAll = function (type) {
        var _this = this;
        if (!type) {
            this.listeners.splice(0, this.listeners.length);
        }
        else {
            this.listeners
                .filter(function (l) { return l.type === type; })
                .forEach(function (l) { return _this.remove(l); });
        }
    };
    // Fires an event
    EventManager.prototype.fire = function (event) {
        var eventListeners = this.getListeners(event.type);
        eventListeners.forEach(function (listener) { return listener.callback(event); });
    };
    return EventManager;
}());
// Manages a queue of tasks
var TaskQueueManager = /** @class */ (function () {
    function TaskQueueManager(eventManager) {
        this.eventManager = eventManager;
        this.queue = [];
    }
    // Adds a task top the queue
    TaskQueueManager.prototype.add = function (task) {
        this.queue.push(task);
    };
    // Processes all tasks in the queue
    TaskQueueManager.prototype.process = function () {
        while (this.queue.length > 0) {
            var task = this.queue.shift();
            task === null || task === void 0 ? void 0 : task.action();
            if (task === null || task === void 0 ? void 0 : task.event) {
                this.eventManager.fire(task.event);
            }
        }
    };
    return TaskQueueManager;
}());
var Rive = /** @class */ (function () {
    function Rive(params) {
        var _a;
        // Flag to indicate if the layout has changed; used by the renderer to know
        // when to align
        this._updateLayout = true;
        /**
         * Flag to active/deactivate renderer
         */
        this.isRendererActive = true;
        // Tracks if a Rive file is loaded
        this.loaded = false;
        /**
         * Tracks if a Rive file is loaded; we need this in addition to loaded as some
         * commands (e.g. contents) can be called as soon as the file is loaded.
         * However, playback commands need to be queued and run in order once initial
         * animations and autoplay has been sorted out. This applies to play, pause,
         * and start.
         */
        this.readyForPlaying = false;
        // Runtime artboard
        this.artboard = null;
        /**
         * Used be draw to track when a second of active rendering time has passed. Used for debugging purposes
         */
        this.renderSecondTimer = 0;
        this.canvas = params.canvas;
        this.src = params.src;
        this.buffer = params.buffer;
        this.layout = (_a = params.layout) !== null && _a !== void 0 ? _a : new Layout();
        this._updateLayout = true;
        // Fetch the 2d context from the canvas
        this.ctx = this.canvas.getContext('2d');
        // New event management system
        this.eventManager = new EventManager();
        if (params.onload)
            this.on(EventType.Load, params.onload);
        if (params.onloaderror)
            this.on(EventType.LoadError, params.onloaderror);
        if (params.onplay)
            this.on(EventType.Play, params.onplay);
        if (params.onpause)
            this.on(EventType.Pause, params.onpause);
        if (params.onstop)
            this.on(EventType.Stop, params.onstop);
        if (params.onloop)
            this.on(EventType.Loop, params.onloop);
        if (params.onstatechange)
            this.on(EventType.StateChange, params.onstatechange);
        // Hook up the task queue
        this.taskQueue = new TaskQueueManager(this.eventManager);
        this.init({
            src: this.src,
            buffer: this.buffer,
            autoplay: params.autoplay,
            animations: params.animations,
            stateMachines: params.stateMachines,
            artboard: params.artboard
        });
    }
    // Alternative constructor to build a Rive instance from an interface/object
    Rive.new = function (params) {
        console.warn('This function is deprecated: please use `new Rive({})` instead');
        return new Rive(params);
    };
    // Initializes the Rive object either from constructor or load()
    Rive.prototype.init = function (_a) {
        var _this = this;
        var src = _a.src, buffer = _a.buffer, animations = _a.animations, stateMachines = _a.stateMachines, artboard = _a.artboard, _b = _a.autoplay, autoplay = _b === void 0 ? false : _b;
        this.src = src;
        this.buffer = buffer;
        // If no source file url specified, it's a bust
        if (!this.src && !this.buffer) {
            throw new Error(Rive.missingErrorMessage);
        }
        // List of animations that should be initialized.
        var startingAnimationNames = mapToStringArray(animations);
        // List of state machines that should be initialized
        var startingStateMachineNames = mapToStringArray(stateMachines);
        // Ensure loaded is marked as false if loading new file
        this.loaded = false;
        this.readyForPlaying = false;
        // Ensure the runtime is loaded
        RuntimeLoader.awaitInstance().then(function (runtime) {
            _this.runtime = runtime;
            // Load Rive data from a source uri or a data buffer
            _this.initData(artboard, startingAnimationNames, startingStateMachineNames, autoplay).catch(function (e) {
                console.error(e);
            });
        }).catch(function (e) {
            console.error(e);
        });
    };
    // Initializes runtime with Rive data and preps for playing
    Rive.prototype.initData = function (artboardName, animationNames, stateMachineNames, autoplay) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var _b, _c, msg;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (!this.src) return [3 /*break*/, 2];
                        _b = this;
                        return [4 /*yield*/, loadRiveFile(this.src)];
                    case 1:
                        _b.buffer = _d.sent();
                        _d.label = 2;
                    case 2:
                        // Load the Rive file
                        _c = this;
                        return [4 /*yield*/, this.runtime.load(new Uint8Array(this.buffer))];
                    case 3:
                        // Load the Rive file
                        _c.file = _d.sent();
                        if (this.file) {
                            // Initialize and draw frame
                            this.initArtboard(artboardName, animationNames, stateMachineNames, autoplay);
                            // Everything's set up, emit a load event
                            this.loaded = true;
                            this.eventManager.fire({
                                type: EventType.Load,
                                data: (_a = this.src) !== null && _a !== void 0 ? _a : 'buffer'
                            });
                            // Flag ready for playback commands and clear the task queue; this order
                            // is important or it may infinitely recurse
                            this.readyForPlaying = true;
                            this.taskQueue.process();
                            this.drawFrame();
                            return [2 /*return*/, Promise.resolve()];
                        }
                        else {
                            msg = 'Problem loading file; may be corrupt!';
                            console.warn(msg);
                            this.eventManager.fire({ type: EventType.LoadError, data: msg });
                            return [2 /*return*/, Promise.reject(msg)];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    // Initialize for playback
    Rive.prototype.initArtboard = function (artboardName, animationNames, stateMachineNames, autoplay) {
        this.artboard = artboardName ?
            this.file.artboardByName(artboardName) :
            this.file.defaultArtboard();
        if (!this.artboard) {
            var msg = 'Invalid artboard name or no default artboard';
            console.warn(msg);
            this.eventManager.fire({ type: EventType.LoadError, data: msg });
            return;
        }
        // Check that the artboard has at least 1 animation
        if (this.artboard.animationCount() < 1) {
            var msg = 'Artboard has no animations';
            this.eventManager.fire({ type: EventType.LoadError, data: msg });
            throw msg;
        }
        // Initialize the animator
        this.animator = new Animator(this.runtime, this.artboard, this.eventManager);
        // Get the canvas where you want to render the animation and create a renderer
        this.renderer = new this.runtime.CanvasRenderer(this.ctx);
        // Initialize the animations; as loaded hasn't happened yet, we need to
        // suppress firing the play/pause events until the load event has fired. To
        // do this we tell the animator to suppress firing events, and add event
        // firing to the task queue.
        var instanceNames;
        if (animationNames.length > 0 || stateMachineNames.length > 0) {
            instanceNames = animationNames.concat(stateMachineNames);
            this.animator.add(instanceNames, autoplay, false);
        }
        else {
            instanceNames = [this.animator.atLeastOne(autoplay, false)];
        }
        // Queue up firing the playback events
        this.taskQueue.add({
            action: function () { },
            event: {
                type: autoplay ? EventType.Play : EventType.Pause,
                data: instanceNames,
            }
        });
    };
    // Draws the current artboard frame
    Rive.prototype.drawFrame = function () {
        this.startRendering();
    };
    /**
     * Draw rendering loop; renders animation frames at the correct time interval.
     * @param time the time at which to render a frame
     */
    Rive.prototype.draw = function (time, onSecond) {
        // Clear the frameRequestId, as we're now rendering a fresh frame
        this.frameRequestId = null;
        // On the first pass, make sure lastTime has a valid value
        if (!this.lastRenderTime) {
            this.lastRenderTime = time;
        }
        // Handle the onSecond callback
        this.renderSecondTimer += (time - this.lastRenderTime);
        if (this.renderSecondTimer > 5000) {
            this.renderSecondTimer = 0;
            onSecond === null || onSecond === void 0 ? void 0 : onSecond();
        }
        // Calculate the elapsed time between frames in seconds
        var elapsedTime = (time - this.lastRenderTime) / 1000;
        this.lastRenderTime = time;
        // Advance non-paused animations by the elapsed number of seconds
        // Also advance any animations that require scrubbing
        var activeAnimations = this.animator.animations.filter(function (a) { return a.playing || a.needsScrub; })
            // The scrubbed animations must be applied first to prevent weird artifacts
            // if the playing animations conflict with the scrubbed animating attribuates.
            .sort(function (first, second) { return first.needsScrub ? -1 : 1; });
        for (var _i = 0, activeAnimations_1 = activeAnimations; _i < activeAnimations_1.length; _i++) {
            var animation = activeAnimations_1[_i];
            animation.advance(elapsedTime);
            if (animation.instance.didLoop) {
                animation.loopCount += 1;
            }
            animation.instance.apply(this.artboard, 1.0);
        }
        // Advance non-paused state machines by the elapsed number of seconds
        var activeStateMachines = this.animator.stateMachines.filter(function (a) { return a.playing; });
        for (var _a = 0, activeStateMachines_1 = activeStateMachines; _a < activeStateMachines_1.length; _a++) {
            var stateMachine = activeStateMachines_1[_a];
            stateMachine.instance.advance(this.artboard, elapsedTime);
            // stateMachine.instance.apply(this.artboard);
        }
        // Once the animations have been applied to the artboard, advance it
        // by the elapsed time.
        this.artboard.advance(elapsedTime);
        // Update the renderer alignment if necessary
        this.alignRenderer();
        var bounds = this.artboard.bounds;
        this.ctx.clearRect(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
        this.artboard.draw(this.renderer);
        // Check for any animations that looped
        this.animator.handleLooping();
        // Check for any state machines that had a state change
        this.animator.handleStateChanges();
        // Calling requestAnimationFrame will rerun draw() at the correct rate:
        // https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Basic_animations
        if (this.animator.isPlaying) {
            // Request a new rendering frame
            this.startRendering();
        }
        else if (this.animator.isPaused) {
            // Reset the end time so on playback it starts at the correct frame
            this.lastRenderTime = 0;
        }
        else if (this.animator.isStopped) {
            // Reset animation instances, artboard and time
            // TODO: implement this properly when we have instancing
            // this.initArtboard();
            // this.drawFrame();
            this.lastRenderTime = 0;
        }
    };
    /**
     * Align the renderer
     */
    Rive.prototype.alignRenderer = function () {
        // Update the renderer alignment if necessary
        if (this._updateLayout) {
            // Restore from previous save in case a previous align occurred
            this.ctx.restore();
            // Canvas must be wiped to prevent artifacts
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            // Now save so that future changes to align can restore
            this.ctx.save();
            // Align things up safe in the knowledge we can restore if changed
            this.renderer.align(this._layout.runtimeFit(this.runtime), this._layout.runtimeAlignment(this.runtime), {
                minX: this._layout.minX,
                minY: this._layout.minY,
                maxX: this._layout.maxX,
                maxY: this._layout.maxY
            }, this.artboard.bounds);
            this._updateLayout = false;
        }
    };
    // Plays specified animations; if none specified, it unpauses everything.
    Rive.prototype.play = function (animationNames, autoplay) {
        var _this = this;
        animationNames = mapToStringArray(animationNames);
        // If the file's not loaded, queue up the play
        if (!this.readyForPlaying) {
            this.taskQueue.add({
                action: function () { return _this.play(animationNames, autoplay); },
            });
            return;
        }
        this.animator.play(animationNames);
        this.startRendering();
    };
    // Pauses specified animations; if none specified, pauses all.
    Rive.prototype.pause = function (animationNames) {
        var _this = this;
        animationNames = mapToStringArray(animationNames);
        // If the file's not loaded, early out, nothing to pause
        if (!this.readyForPlaying) {
            this.taskQueue.add({
                action: function () { return _this.pause(animationNames); },
            });
            return;
        }
        this.animator.pause(animationNames);
    };
    Rive.prototype.scrub = function (animationNames, value) {
        var _this = this;
        animationNames = mapToStringArray(animationNames);
        // If the file's not loaded, early out, nothing to pause
        if (!this.readyForPlaying) {
            this.taskQueue.add({
                action: function () { return _this.scrub(animationNames, value); },
            });
            return;
        }
        // Scrub the animation time; we draw a single frame here so that if
        // nothing's currently playing, the scrubbed animation is still rendered/
        this.animator.scrub(animationNames, value || 0);
        this.drawFrame();
    };
    // Stops specified animations; if none specifies, stops them all.
    Rive.prototype.stop = function (animationNames) {
        var _this = this;
        animationNames = mapToStringArray(animationNames);
        // If the file's not loaded, early out, nothing to pause
        if (!this.readyForPlaying) {
            this.taskQueue.add({
                action: function () { return _this.stop(animationNames); },
            });
            return;
        }
        this.animator.stop(animationNames);
    };
    // Loads a new Rive file, keeping listeners in place
    Rive.prototype.load = function (params) {
        // Stop all animations
        this.stop();
        // Update the layout to account for new renderer
        this._updateLayout = true;
        // Reinitialize
        this.init(params);
    };
    Object.defineProperty(Rive.prototype, "layout", {
        /**
         * Returns the current layout. Note that layout should be treated as
         * immutable. If you want to change the layout, create a new one use the
         * layout setter
         */
        get: function () {
            return this._layout;
        },
        // Sets a new layout
        set: function (layout) {
            this._layout = layout;
            this._updateLayout = true;
            // If the maxX or maxY are 0, then set them to the canvas width and height
            if (!layout.maxX || !layout.maxY) {
                this.resizeToCanvas();
            }
            if (this.loaded && !this.animator.isPlaying) {
                this.drawFrame();
            }
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Sets the layout bounds to the current canvas size; this is typically called
     * when the canvas is resized
     */
    Rive.prototype.resizeToCanvas = function () {
        this._layout = this.layout.copyWith({
            minX: 0,
            minY: 0,
            maxX: this.canvas.width,
            maxY: this.canvas.height
        });
        this._updateLayout = true;
    };
    Object.defineProperty(Rive.prototype, "source", {
        // Returns the animation source, which may be undefined
        get: function () {
            return this.src;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Rive.prototype, "animationNames", {
        // Returns a list of animation names on the chosen artboard
        get: function () {
            // If the file's not loaded, we got nothing to return
            if (!this.loaded) {
                return [];
            }
            var animationNames = [];
            for (var i = 0; i < this.artboard.animationCount(); i++) {
                animationNames.push(this.artboard.animationByIndex(i).name);
            }
            return animationNames;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Rive.prototype, "stateMachineNames", {
        /**
         * Returns a list of state machine names from the current artboard
         */
        get: function () {
            // If the file's not loaded, we got nothing to return
            if (!this.loaded) {
                return [];
            }
            var stateMachineNames = [];
            for (var i = 0; i < this.artboard.stateMachineCount(); i++) {
                stateMachineNames.push(this.artboard.stateMachineByIndex(i).name);
            }
            return stateMachineNames;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Returns the inputs for the specified instanced state machine, or an empty
     * list if the name is invalid or the state machine is not instanced
     * @param name the state machine name
     * @returns the inputs for the named state machine
     */
    Rive.prototype.stateMachineInputs = function (name) {
        // If the file's not loaded, early out, nothing to pause
        if (!this.loaded) {
            return;
        }
        var stateMachine = this.animator.stateMachines.find(function (m) { return m.name === name; });
        return stateMachine === null || stateMachine === void 0 ? void 0 : stateMachine.inputs;
    };
    Object.defineProperty(Rive.prototype, "playingStateMachineNames", {
        // Returns a list of playing machine names
        get: function () {
            // If the file's not loaded, we got nothing to return
            if (!this.loaded) {
                return [];
            }
            return this.animator.stateMachines
                .filter(function (m) { return m.playing; })
                .map(function (m) { return m.name; });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Rive.prototype, "playingAnimationNames", {
        // Returns a list of playing animation names
        get: function () {
            // If the file's not loaded, we got nothing to return
            if (!this.loaded) {
                return [];
            }
            return this.animator.animations
                .filter(function (a) { return a.playing; })
                .map(function (a) { return a.name; });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Rive.prototype, "pausedAnimationNames", {
        // Returns a list of paused animation names
        get: function () {
            // If the file's not loaded, we got nothing to return
            if (!this.loaded) {
                return [];
            }
            return this.animator.animations
                .filter(function (a) { return !a.playing; })
                .map(function (a) { return a.name; });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Rive.prototype, "pausedStateMachineNames", {
        /**
         *  Returns a list of paused machine names
         * @returns a list of state machine names that are paused
         */
        get: function () {
            // If the file's not loaded, we got nothing to return
            if (!this.loaded) {
                return [];
            }
            return this.animator.stateMachines
                .filter(function (m) { return !m.playing; })
                .map(function (m) { return m.name; });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Rive.prototype, "isPlaying", {
        /**
         * @returns true if any animation is playing
         */
        get: function () {
            return this.animator.isPlaying;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Rive.prototype, "isPaused", {
        /**
         * @returns true if all instanced animations are paused
         */
        get: function () {
            return this.animator.isPaused;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Rive.prototype, "isStopped", {
        /**
         * @returns true if no animations are playing or paused
         */
        get: function () {
            return this.animator.isStopped;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Rive.prototype, "bounds", {
        /**
         * @returns the bounds of the current artboard, or undefined if the artboard
         * isn't loaded yet.
         */
        get: function () {
            return this.artboard ? this.artboard.bounds : undefined;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Subscribe to Rive-generated events
     * @param type the type of event to subscribe to
     * @param callback callback to fire when the event occurs
     */
    Rive.prototype.on = function (type, callback) {
        this.eventManager.add({
            type: type,
            callback: callback,
        });
    };
    /**
     * Unsubscribes from a Rive-generated event
     * @param callback the callback to unsubscribe from
     */
    Rive.prototype.unsubscribe = function (type, callback) {
        this.eventManager.remove({
            type: type,
            callback: callback,
        });
    };
    /**
     * Unsubscribes all listeners from an event type, or everything if no type is
     * given
     * @param type the type of event to unsubscribe from, or all types if
     * undefined
     */
    Rive.prototype.unsubscribeAll = function (type) {
        this.eventManager.removeAll(type);
    };
    /**
     * Stops the rendering loop; this is different from pausing in that it doesn't
     * change the state of any animation. It stops rendering from occurring. This
     * is designed for situations such as when Rive isn't visible.
     *
     * The only way to start rendering again is to call `startRendering`.
     * Animations that are marked as playing will start from the position that
     * they would have been at if rendering had not been stopped.
     */
    Rive.prototype.stopRendering = function () {
        if (this.loaded && this.frameRequestId) {
            cancelAnimationFrame(this.frameRequestId);
            this.frameRequestId = null;
        }
    };
    /**
     * Starts the rendering loop if it has been previously stopped. If the
     * renderer is already active, then this will have zero effect.
     */
    Rive.prototype.startRendering = function () {
        if (this.loaded && !this.frameRequestId) {
            this.frameRequestId = requestAnimationFrame(this.draw.bind(this));
        }
    };
    Object.defineProperty(Rive.prototype, "contents", {
        /**
         * Returns the contents of a Rive file: the artboards, animations, and state machines
         */
        get: function () {
            if (!this.loaded) {
                return undefined;
            }
            var riveContents = {
                artboards: [],
            };
            for (var i = 0; i < this.file.artboardCount(); i++) {
                var artboard = this.file.artboardByIndex(i);
                var artboardContents = {
                    name: artboard.name,
                    animations: [],
                    stateMachines: [],
                };
                for (var j = 0; j < artboard.animationCount(); j++) {
                    var animation = artboard.animationByIndex(j);
                    artboardContents.animations.push(animation.name);
                }
                for (var k = 0; k < artboard.stateMachineCount(); k++) {
                    var stateMachine = artboard.stateMachineByIndex(k);
                    var name_1 = stateMachine.name;
                    var instance = new this.runtime.StateMachineInstance(stateMachine);
                    var inputContents = [];
                    for (var l = 0; l < instance.inputCount(); l++) {
                        var input = instance.input(l);
                        inputContents.push({ name: input.name, type: input.type });
                    }
                    artboardContents.stateMachines.push({ name: name_1, inputs: inputContents });
                }
                riveContents.artboards.push(artboardContents);
            }
            return riveContents;
        },
        enumerable: false,
        configurable: true
    });
    // Error message for missing source or buffer
    Rive.missingErrorMessage = 'Rive source file or data buffer required';
    return Rive;
}());

// Loads Rive data from a URI via fetch.
var loadRiveFile = function (src) { return __awaiter(void 0, void 0, void 0, function () {
    var req, res, buffer;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                req = new Request(src);
                return [4 /*yield*/, fetch(req)];
            case 1:
                res = _a.sent();
                return [4 /*yield*/, res.arrayBuffer()];
            case 2:
                buffer = _a.sent();
                return [2 /*return*/, buffer];
        }
    });
}); };
// #endregion
// #region utility functions
/*
 * Utility function to ensure an object is a string array
 */
var mapToStringArray = function (obj) {
    if (typeof obj === 'string') {
        return [obj];
    }
    else if (obj instanceof Array) {
        return obj;
    }
    // If obj is undefined, return empty array
    return [];
};
// #endregion
// #region testing utilities
// Exports to only be used for tests
var Testing = {
    EventManager: EventManager,
    TaskQueueManager: TaskQueueManager,
};
// #endregion

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=rive.dev.js.map