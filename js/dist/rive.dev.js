(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["rive"] = factory();
	else
		root["rive"] = factory();
})(this, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

var Rive = (function() {
  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
  if (typeof __filename !== 'undefined') _scriptDir = _scriptDir || __filename;
  return (
function(Rive) {
  Rive = Rive || {};

null;

var Module = typeof Rive !== "undefined" ? Rive : {};

var readyPromiseResolve, readyPromiseReject;

Module["ready"] = new Promise(function(resolve, reject) {
 readyPromiseResolve = resolve;
 readyPromiseReject = reject;
});

var moduleOverrides = {};

var key;

for (key in Module) {
 if (Module.hasOwnProperty(key)) {
  moduleOverrides[key] = Module[key];
 }
}

var arguments_ = [];

var thisProgram = "./this.program";

var quit_ = function(status, toThrow) {
 throw toThrow;
};

var ENVIRONMENT_IS_WEB = false;

var ENVIRONMENT_IS_WORKER = false;

var ENVIRONMENT_IS_NODE = false;

var ENVIRONMENT_IS_SHELL = false;

ENVIRONMENT_IS_WEB = typeof window === "object";

ENVIRONMENT_IS_WORKER = typeof importScripts === "function";

ENVIRONMENT_IS_NODE = typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node === "string";

ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;

var scriptDirectory = "";

function locateFile(path) {
 if (Module["locateFile"]) {
  return Module["locateFile"](path, scriptDirectory);
 }
 return scriptDirectory + path;
}

var read_, readAsync, readBinary, setWindowTitle;

var nodeFS;

var nodePath;

if (ENVIRONMENT_IS_NODE) {
 if (ENVIRONMENT_IS_WORKER) {
  scriptDirectory = require("path").dirname(scriptDirectory) + "/";
 } else {
  scriptDirectory = __dirname + "/";
 }
 read_ = function shell_read(filename, binary) {
  var ret = tryParseAsDataURI(filename);
  if (ret) {
   return binary ? ret : ret.toString();
  }
  if (!nodeFS) nodeFS = require("fs");
  if (!nodePath) nodePath = require("path");
  filename = nodePath["normalize"](filename);
  return nodeFS["readFileSync"](filename, binary ? null : "utf8");
 };
 readBinary = function readBinary(filename) {
  var ret = read_(filename, true);
  if (!ret.buffer) {
   ret = new Uint8Array(ret);
  }
  assert(ret.buffer);
  return ret;
 };
 if (process["argv"].length > 1) {
  thisProgram = process["argv"][1].replace(/\\/g, "/");
 }
 arguments_ = process["argv"].slice(2);
 process["on"]("uncaughtException", function(ex) {
  if (!(ex instanceof ExitStatus)) {
   throw ex;
  }
 });
 process["on"]("unhandledRejection", abort);
 quit_ = function(status) {
  process["exit"](status);
 };
 Module["inspect"] = function() {
  return "[Emscripten Module object]";
 };
} else if (ENVIRONMENT_IS_SHELL) {
 if (typeof read != "undefined") {
  read_ = function shell_read(f) {
   var data = tryParseAsDataURI(f);
   if (data) {
    return intArrayToString(data);
   }
   return read(f);
  };
 }
 readBinary = function readBinary(f) {
  var data;
  data = tryParseAsDataURI(f);
  if (data) {
   return data;
  }
  if (typeof readbuffer === "function") {
   return new Uint8Array(readbuffer(f));
  }
  data = read(f, "binary");
  assert(typeof data === "object");
  return data;
 };
 if (typeof scriptArgs != "undefined") {
  arguments_ = scriptArgs;
 } else if (typeof arguments != "undefined") {
  arguments_ = arguments;
 }
 if (typeof quit === "function") {
  quit_ = function(status) {
   quit(status);
  };
 }
 if (typeof print !== "undefined") {
  if (typeof console === "undefined") console = {};
  console.log = print;
  console.warn = console.error = typeof printErr !== "undefined" ? printErr : print;
 }
} else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
 if (ENVIRONMENT_IS_WORKER) {
  scriptDirectory = self.location.href;
 } else if (document.currentScript) {
  scriptDirectory = document.currentScript.src;
 }
 if (_scriptDir) {
  scriptDirectory = _scriptDir;
 }
 if (scriptDirectory.indexOf("blob:") !== 0) {
  scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1);
 } else {
  scriptDirectory = "";
 }
 {
  read_ = function shell_read(url) {
   try {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", url, false);
    xhr.send(null);
    return xhr.responseText;
   } catch (err) {
    var data = tryParseAsDataURI(url);
    if (data) {
     return intArrayToString(data);
    }
    throw err;
   }
  };
  if (ENVIRONMENT_IS_WORKER) {
   readBinary = function readBinary(url) {
    try {
     var xhr = new XMLHttpRequest();
     xhr.open("GET", url, false);
     xhr.responseType = "arraybuffer";
     xhr.send(null);
     return new Uint8Array(xhr.response);
    } catch (err) {
     var data = tryParseAsDataURI(url);
     if (data) {
      return data;
     }
     throw err;
    }
   };
  }
  readAsync = function readAsync(url, onload, onerror) {
   var xhr = new XMLHttpRequest();
   xhr.open("GET", url, true);
   xhr.responseType = "arraybuffer";
   xhr.onload = function xhr_onload() {
    if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
     onload(xhr.response);
     return;
    }
    var data = tryParseAsDataURI(url);
    if (data) {
     onload(data.buffer);
     return;
    }
    onerror();
   };
   xhr.onerror = onerror;
   xhr.send(null);
  };
 }
 setWindowTitle = function(title) {
  document.title = title;
 };
} else {}

var out = Module["print"] || console.log.bind(console);

var err = Module["printErr"] || console.warn.bind(console);

for (key in moduleOverrides) {
 if (moduleOverrides.hasOwnProperty(key)) {
  Module[key] = moduleOverrides[key];
 }
}

moduleOverrides = null;

if (Module["arguments"]) arguments_ = Module["arguments"];

if (Module["thisProgram"]) thisProgram = Module["thisProgram"];

if (Module["quit"]) quit_ = Module["quit"];

var tempRet0 = 0;

var setTempRet0 = function(value) {
 tempRet0 = value;
};

var wasmBinary;

if (Module["wasmBinary"]) wasmBinary = Module["wasmBinary"];

var noExitRuntime;

if (Module["noExitRuntime"]) noExitRuntime = Module["noExitRuntime"];

if (typeof WebAssembly !== "object") {
 abort("no native wasm support detected");
}

var wasmMemory;

var wasmTable = new WebAssembly.Table({
 "initial": 1007,
 "maximum": 1007 + 0,
 "element": "anyfunc"
});

var ABORT = false;

var EXITSTATUS = 0;

function assert(condition, text) {
 if (!condition) {
  abort("Assertion failed: " + text);
 }
}

var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : undefined;

function UTF8ArrayToString(heap, idx, maxBytesToRead) {
 var endIdx = idx + maxBytesToRead;
 var endPtr = idx;
 while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;
 if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
  return UTF8Decoder.decode(heap.subarray(idx, endPtr));
 } else {
  var str = "";
  while (idx < endPtr) {
   var u0 = heap[idx++];
   if (!(u0 & 128)) {
    str += String.fromCharCode(u0);
    continue;
   }
   var u1 = heap[idx++] & 63;
   if ((u0 & 224) == 192) {
    str += String.fromCharCode((u0 & 31) << 6 | u1);
    continue;
   }
   var u2 = heap[idx++] & 63;
   if ((u0 & 240) == 224) {
    u0 = (u0 & 15) << 12 | u1 << 6 | u2;
   } else {
    u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63;
   }
   if (u0 < 65536) {
    str += String.fromCharCode(u0);
   } else {
    var ch = u0 - 65536;
    str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
   }
  }
 }
 return str;
}

function UTF8ToString(ptr, maxBytesToRead) {
 return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
}

function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
 if (!(maxBytesToWrite > 0)) return 0;
 var startIdx = outIdx;
 var endIdx = outIdx + maxBytesToWrite - 1;
 for (var i = 0; i < str.length; ++i) {
  var u = str.charCodeAt(i);
  if (u >= 55296 && u <= 57343) {
   var u1 = str.charCodeAt(++i);
   u = 65536 + ((u & 1023) << 10) | u1 & 1023;
  }
  if (u <= 127) {
   if (outIdx >= endIdx) break;
   heap[outIdx++] = u;
  } else if (u <= 2047) {
   if (outIdx + 1 >= endIdx) break;
   heap[outIdx++] = 192 | u >> 6;
   heap[outIdx++] = 128 | u & 63;
  } else if (u <= 65535) {
   if (outIdx + 2 >= endIdx) break;
   heap[outIdx++] = 224 | u >> 12;
   heap[outIdx++] = 128 | u >> 6 & 63;
   heap[outIdx++] = 128 | u & 63;
  } else {
   if (outIdx + 3 >= endIdx) break;
   heap[outIdx++] = 240 | u >> 18;
   heap[outIdx++] = 128 | u >> 12 & 63;
   heap[outIdx++] = 128 | u >> 6 & 63;
   heap[outIdx++] = 128 | u & 63;
  }
 }
 heap[outIdx] = 0;
 return outIdx - startIdx;
}

function stringToUTF8(str, outPtr, maxBytesToWrite) {
 return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
}

function lengthBytesUTF8(str) {
 var len = 0;
 for (var i = 0; i < str.length; ++i) {
  var u = str.charCodeAt(i);
  if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
  if (u <= 127) ++len; else if (u <= 2047) len += 2; else if (u <= 65535) len += 3; else len += 4;
 }
 return len;
}

var UTF16Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le") : undefined;

function UTF16ToString(ptr, maxBytesToRead) {
 var endPtr = ptr;
 var idx = endPtr >> 1;
 var maxIdx = idx + maxBytesToRead / 2;
 while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;
 endPtr = idx << 1;
 if (endPtr - ptr > 32 && UTF16Decoder) {
  return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
 } else {
  var i = 0;
  var str = "";
  while (1) {
   var codeUnit = HEAP16[ptr + i * 2 >> 1];
   if (codeUnit == 0 || i == maxBytesToRead / 2) return str;
   ++i;
   str += String.fromCharCode(codeUnit);
  }
 }
}

function stringToUTF16(str, outPtr, maxBytesToWrite) {
 if (maxBytesToWrite === undefined) {
  maxBytesToWrite = 2147483647;
 }
 if (maxBytesToWrite < 2) return 0;
 maxBytesToWrite -= 2;
 var startPtr = outPtr;
 var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;
 for (var i = 0; i < numCharsToWrite; ++i) {
  var codeUnit = str.charCodeAt(i);
  HEAP16[outPtr >> 1] = codeUnit;
  outPtr += 2;
 }
 HEAP16[outPtr >> 1] = 0;
 return outPtr - startPtr;
}

function lengthBytesUTF16(str) {
 return str.length * 2;
}

function UTF32ToString(ptr, maxBytesToRead) {
 var i = 0;
 var str = "";
 while (!(i >= maxBytesToRead / 4)) {
  var utf32 = HEAP32[ptr + i * 4 >> 2];
  if (utf32 == 0) break;
  ++i;
  if (utf32 >= 65536) {
   var ch = utf32 - 65536;
   str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
  } else {
   str += String.fromCharCode(utf32);
  }
 }
 return str;
}

function stringToUTF32(str, outPtr, maxBytesToWrite) {
 if (maxBytesToWrite === undefined) {
  maxBytesToWrite = 2147483647;
 }
 if (maxBytesToWrite < 4) return 0;
 var startPtr = outPtr;
 var endPtr = startPtr + maxBytesToWrite - 4;
 for (var i = 0; i < str.length; ++i) {
  var codeUnit = str.charCodeAt(i);
  if (codeUnit >= 55296 && codeUnit <= 57343) {
   var trailSurrogate = str.charCodeAt(++i);
   codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;
  }
  HEAP32[outPtr >> 2] = codeUnit;
  outPtr += 4;
  if (outPtr + 4 > endPtr) break;
 }
 HEAP32[outPtr >> 2] = 0;
 return outPtr - startPtr;
}

function lengthBytesUTF32(str) {
 var len = 0;
 for (var i = 0; i < str.length; ++i) {
  var codeUnit = str.charCodeAt(i);
  if (codeUnit >= 55296 && codeUnit <= 57343) ++i;
  len += 4;
 }
 return len;
}

var WASM_PAGE_SIZE = 65536;

function alignUp(x, multiple) {
 if (x % multiple > 0) {
  x += multiple - x % multiple;
 }
 return x;
}

var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;

function updateGlobalBufferAndViews(buf) {
 buffer = buf;
 Module["HEAP8"] = HEAP8 = new Int8Array(buf);
 Module["HEAP16"] = HEAP16 = new Int16Array(buf);
 Module["HEAP32"] = HEAP32 = new Int32Array(buf);
 Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
 Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
 Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
 Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
 Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
}

var DYNAMIC_BASE = 5266272, DYNAMICTOP_PTR = 23232;

var INITIAL_INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;

if (Module["wasmMemory"]) {
 wasmMemory = Module["wasmMemory"];
} else {
 wasmMemory = new WebAssembly.Memory({
  "initial": INITIAL_INITIAL_MEMORY / WASM_PAGE_SIZE,
  "maximum": 2147483648 / WASM_PAGE_SIZE
 });
}

if (wasmMemory) {
 buffer = wasmMemory.buffer;
}

INITIAL_INITIAL_MEMORY = buffer.byteLength;

updateGlobalBufferAndViews(buffer);

HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;

function callRuntimeCallbacks(callbacks) {
 while (callbacks.length > 0) {
  var callback = callbacks.shift();
  if (typeof callback == "function") {
   callback(Module);
   continue;
  }
  var func = callback.func;
  if (typeof func === "number") {
   if (callback.arg === undefined) {
    Module["dynCall_v"](func);
   } else {
    Module["dynCall_vi"](func, callback.arg);
   }
  } else {
   func(callback.arg === undefined ? null : callback.arg);
  }
 }
}

var __ATPRERUN__ = [];

var __ATINIT__ = [];

var __ATMAIN__ = [];

var __ATPOSTRUN__ = [];

var runtimeInitialized = false;

function preRun() {
 if (Module["preRun"]) {
  if (typeof Module["preRun"] == "function") Module["preRun"] = [ Module["preRun"] ];
  while (Module["preRun"].length) {
   addOnPreRun(Module["preRun"].shift());
  }
 }
 callRuntimeCallbacks(__ATPRERUN__);
}

function initRuntime() {
 runtimeInitialized = true;
 callRuntimeCallbacks(__ATINIT__);
}

function preMain() {
 callRuntimeCallbacks(__ATMAIN__);
}

function postRun() {
 if (Module["postRun"]) {
  if (typeof Module["postRun"] == "function") Module["postRun"] = [ Module["postRun"] ];
  while (Module["postRun"].length) {
   addOnPostRun(Module["postRun"].shift());
  }
 }
 callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
 __ATPRERUN__.unshift(cb);
}

function addOnPostRun(cb) {
 __ATPOSTRUN__.unshift(cb);
}

var runDependencies = 0;

var runDependencyWatcher = null;

var dependenciesFulfilled = null;

function addRunDependency(id) {
 runDependencies++;
 if (Module["monitorRunDependencies"]) {
  Module["monitorRunDependencies"](runDependencies);
 }
}

function removeRunDependency(id) {
 runDependencies--;
 if (Module["monitorRunDependencies"]) {
  Module["monitorRunDependencies"](runDependencies);
 }
 if (runDependencies == 0) {
  if (runDependencyWatcher !== null) {
   clearInterval(runDependencyWatcher);
   runDependencyWatcher = null;
  }
  if (dependenciesFulfilled) {
   var callback = dependenciesFulfilled;
   dependenciesFulfilled = null;
   callback();
  }
 }
}

Module["preloadedImages"] = {};

Module["preloadedAudios"] = {};

function abort(what) {
 if (Module["onAbort"]) {
  Module["onAbort"](what);
 }
 what += "";
 err(what);
 ABORT = true;
 EXITSTATUS = 1;
 what = "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
 var e = new WebAssembly.RuntimeError(what);
 readyPromiseReject(e);
 throw e;
}

function hasPrefix(str, prefix) {
 return String.prototype.startsWith ? str.startsWith(prefix) : str.indexOf(prefix) === 0;
}

var dataURIPrefix = "data:application/octet-stream;base64,";

function isDataURI(filename) {
 return hasPrefix(filename, dataURIPrefix);
}

var fileURIPrefix = "file://";

function isFileURI(filename) {
 return hasPrefix(filename, fileURIPrefix);
}

var wasmBinaryFile = "data:application/octet-stream;base64,AGFzbQEAAAABrQRJYAF/AGACf38Bf2ABfwF/YAJ/fwBgA39/fwF/YAN/f38AYAAAYAF/AX1gA399fQBgAAF/YAJ/fQBgBH9/f38AYAd/fX19fX19AGAFf39/f38AYAR/f399AGAEf39/fwF/YAZ/f39/f38AYAN/f30AYAJ/fwF9YAR/f319AGAFf319fX0AYAZ/f399f30AYAN/f30Bf2ACf30Bf2ABfQF9YAV/f39/fwF/YAd/f39/f39/AGAFf39/fX0AYAZ/f319fX0AYAh/f319fX19fQBgA39/fAF/YAJ/fAF/YAZ/fH9/f38Bf2ACfX0BfWADfX19AX1gCH9/f39/f39/AGAKf39/f39/f39/fwBgBH9+fn8AYAd/f39/f39/AX9gAn5/AX9gA39+fwF+YAN/f38BfWACf30BfWABfAF9YAJ8fwF8YA1/f39/f39/f39/f39/AGAFf39/f30AYAZ/f39/fX8AYAd/f39/fX99AGAGf39/f319AGAHf39/fX19fQBgCX9/f319fX19fQBgBH9/fX8AYAZ/f319f38AYAV/f319fQBgBX99fX9/AGAHfX1/f39/fwBgBn9/f39/fwF/YAR/f399AX9gBH9/f3wBf2AHf398f39/fwF/YAN/fX8Bf2ADf319AX9gA35/fwF/YAJ9fwF/YAF8AX9gAX8BfmAIf39/f319fX8BfWABfwF8YAN/f38BfGAFf39/f38BfGACfn4BfGACfHwBfAKIAikBYQFhACMBYQFiACQBYQFjAC0BYQFkAAEBYQFlAAsBYQFmACMBYQFnAAUBYQFoAA0BYQFpABoBYQFqAAUBYQFrAAsBYQFsAEUBYQFtAAUBYQFuAAQBYQFvAA8BYQFwAAUBYQFxAAMBYQFyABABYQFzAAYBYQF0AAEBYQF1AAEBYQF2ABkBYQF3AAABYQF4AAQBYQF5AAIBYQF6AAIBYQFBAAMBYQFCAA0BYQFDAAMBYQFEAAABYQFFAAABYQFGAAIBYQFHAAABYQFIAEYBYQFJAAABYQFKACQBYQFLABABYQFMABABYQFNAAIBYQZtZW1vcnkCAYACgIACAWEFdGFibGUBcADvBwOtCqsKAQACAgIBAAECRAAAAgICAwIDAgIBAAQAAj4BAgICAgEBAgAFAQACAgQCDQQDAQoKCgEABAEAAQMBKysG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QRBrIgIkACACIAE7AQ4gAiAAIAJBDmoQhwQ2AgggAhCZATYCAEEAIQAgAkEIaiACEP8DRQRAIAJBCGoQbSgCBCEACyACQRBqJAAgAAsJACAAKAIAEB4LmwEBAX8jAEEQayIDJAACf0EAIAAvASwgARBUIAFGDQAaIABBLGogARDJASAAIAAvASwgACgCACgCLBEDACAAKAIoIAAQlgZBASACRQ0AGiADIABBGGoiABAqNgIIIAMgABArNgIAA38gA0EIaiADECwEfyADKAIIKAIAIAFBARBaGiADQQhqEC0MAQVBAQsLCyEAIANBEGokACAAC1oBAn8gACABQbh/akEAIAEbIgM2AigCQCAAIANGDQBBASECIAEgACgCECABKAIAKAIAEQEAIgFFDQAgAUELIAEoAgAoAgwRAQBFDQAgACABNgIUQQAhAgsgAgsUACAABEAgACAAKAIAKAIEEQAACwsJACAAIAEQ8AULKAEBfyMAQRBrIgIkACACIAE2AgwgAEGMAWogAkEMahByIAJBEGokAAsYACAAIAEoAgA2AgAgACABKAIENgIEIAALSwECfCAAIACiIgEgAKIiAiABIAGioiABRKdGO4yHzcY+okR058ri+QAqv6CiIAIgAUSy+26JEBGBP6JEd6zLVFVVxb+goiAAoKC2C08BAXwgACAAoiIARIFeDP3//9+/okQAAAAAAADwP6AgACAAoiIBREI6BeFTVaU/oqAgACABoiAARGlQ7uBCk/k+okQnHg/oh8BWv6CioLYLBQAQEgALDwAgACAAKAIAKAJgEQAAC1IBAn0gAUEAECcqAgAhBCACQQAQJyoCACEFIABBABAnIAQgBSADlJI4AgAgAUEBECcqAgAhBCACQQEQJyoCACEFIABBARAnIAQgBSADlJI4AgALCgAgAEHoGzYCAAuCBAEDfyACQYAETwRAIAAgASACEBcaIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAs3AQF/IAAoAgQiA0EBdSABaiEBIAAoAgAhACABIAIgA0EBcQR/IAEoAgAgAGooAgAFIAALEQMAC1MCAn8BfSMAQRBrIgIkACAAKAIAIQMgAiABIAAoAgQiAEEBdWoiASAAQQFxBH8gASgCACADaigCAAUgAwsRBwA4AgwgAioCDCEEIAJBEGokACAECycBAX8jAEEQayICJAAgAiABNgIMIABBGGogAkEMahByIAJBEGokAAsPACAAKAIAIAAoAgQ2AgQLIAAgABC/AyAAQQA2AjwgAEHsKzYCACAAQbA6NgIAIAALRwAgABBlIABBpBU2AgAgAEEEakGwJhDaASAAQQA2AhAgAEEANgIUIABBtD82AgAgAEEYahA6GiAAQf//AzsBLCAAQQA2AigLCgAgACgCAEEIagsdAQF/IAAQmAEEQCAAKAIAIQEgABD6AxogARAyCwsNACAAKAIEIAAoAgBrCwwAIAAQuQIaIAAQMgsnACABEKYCBEAgACABKAI4EJwDEF8aDwsgACABKgIwIAEqAjQQQBoLIQAgACgCBCAAEC8oAgBHBEAgACABEKYBDwsgACABEKMDCwsAIAAQfhogABAyCwgAIABB2ABqC1gBA30gAUEAECcqAgAhBCABQQEQJyoCACEFIAJBABAnKgIAIQYgAEEAECcgBCAGIASTIAOUkjgCACACQQEQJyoCACEEIABBARAnIAUgBCAFkyADlJI4AgALCgAgAEHIGTYCAAtQAgJ/AX4jAEEQayIBJAACfiAAKAIAIAAoAgQgAUEIahDUByICRQRAIAAQrwFCAAwBCyAAIAAoAgAgAmo2AgAgASkDCAshAyABQRBqJAAgAwsMACAAKAIIIAEQ7gkLGQAgACgCACABNgIAIAAgACgCAEEIajYCAAsUAQF/QQQQKSIBIAAoAgA2AgAgAQsRACAAIABBf2pxRSAAQQJLcQsMACABIAIoAgA2AgALEgAgABAvKAIAIAAoAgBrQQJ1CzMBAX8gAEH8KjYCACAAKAKIASIBBEAgASABKAIAKAIEEQAACyAAQYwBahA+IAAQRBogAAsSACAAEC8oAgAgACgCAGtBA20LEgAgABAvKAIAIAAoAgBrQQN1CxAAIAAoAgQgACgCAGtBA20LFgAgABBsIABB/CU2AgAgAEHAJTYCAAsNACAAKgIMIAAqAgSTCw0AIAAqAgggACoCAJMLBwAgABDfAgskAQJ/IwBBEGsiACQAIABBCGpBABBBKAIAIQEgAEEQaiQAIAELDAAgABC3AhogABAyC3YBA38CQCAAELMBIgIgARCzAUcNACAAEJcBIQMgARCXASEBIAAQmAFFBEADQCACRSEEIAJFDQIgAy0AACABLQAARw0CIAFBAWohASADQQFqIQMgAkF/aiECDAAACwALIAIEfyADIAEgAhCECQVBAAtFIQQLIAQLVQECf0HAtQEoAgAiASAAQQNqQXxxIgJqIQACQCACQQFOQQAgACABTRsNACAAPwBBEHRLBEAgABAYRQ0BC0HAtQEgADYCACABDwtBiLEBQTA2AgBBfwvoAgIDfwF8IwBBEGsiASQAAn0gALwiA0H/////B3EiAkHan6T6A00EQEMAAIA/IAJBgICAzANJDQEaIAC7EGEMAQsgAkHRp+2DBE0EQCAAuyEEIAJB5JfbgARPBEBEGC1EVPshCcBEGC1EVPshCUAgA0F/ShsgBKAQYYwMAgsgA0F/TARAIAREGC1EVPsh+T+gEGAMAgtEGC1EVPsh+T8gBKEQYAwBCyACQdXjiIcETQRAIAJB4Nu/hQRPBEBEGC1EVPshGcBEGC1EVPshGUAgA0F/ShsgALugEGEMAgsgA0F/TARARNIhM3982RLAIAC7oRBgDAILIAC7RNIhM3982RLAoBBgDAELIAAgAJMgAkGAgID8B08NABoCQAJAAkACQCAAIAFBCGoQlgRBA3EOAwABAgMLIAErAwgQYQwDCyABKwMImhBgDAILIAErAwgQYYwMAQsgASsDCBBgCyEAIAFBEGokACAAC/4CAgN/AXwjAEEQayIBJAACQCAAvCIDQf////8HcSICQdqfpPoDTQRAIAJBgICAzANJDQEgALsQYCEADAELIAJB0aftgwRNBEAgALshBCACQeOX24AETQRAIANBf0wEQCAERBgtRFT7Ifk/oBBhjCEADAMLIAREGC1EVPsh+b+gEGEhAAwCC0QYLURU+yEJwEQYLURU+yEJQCADQX9KGyAEoJoQYCEADAELIAJB1eOIhwRNBEAgALshBCACQd/bv4UETQRAIANBf0wEQCAERNIhM3982RJAoBBhIQAMAwsgBETSITN/fNkSwKAQYYwhAAwCC0QYLURU+yEZwEQYLURU+yEZQCADQX9KGyAEoBBgIQAMAQsgAkGAgID8B08EQCAAIACTIQAMAQsCQAJAAkACQCAAIAFBCGoQlgRBA3EOAwABAgMLIAErAwgQYCEADAMLIAErAwgQYSEADAILIAErAwiaEGAhAAwBCyABKwMIEGGMIQALIAFBEGokACAAC1cBAn8jAEEQayIDJAAgACgCBCIEQQF1IAFqIQEgACgCACEAIARBAXEEQCABKAIAIABqKAIAIQALIAMgAhCmBCABIAMgABEBACEAIAMQbiADQRBqJAAgAAspAQF/IwBBEGsiAiQAIAIgADYCDCACQQxqIAEoAgAQeSACQRBqJAAgAAsPACAAEC8oAgAgACgCAGsLDgBBnK8BIAEgAhAJIAALmgEBAn8gASgCACAAKAIAIAMoAgARAQAhBSACKAIAIAEoAgAgAygCABEBACEEAn8CQCAFRQRAQQAgBEUNAhogASACEDZBASABKAIAIAAoAgAgAygCABEBAEUNAhogACABEDYMAQsgBARAIAAgAhA2QQEPCyAAIAEQNkEBIAIoAgAgASgCACADKAIAEQEARQ0BGiABIAIQNgtBAgsLCgAgABDXA0EBRgsOACAAIAEoAgA2AgAgAAsgAQF/IAAoAgAhAiAAIAE2AgAgAgRAIAAQQiACEP0CCwsHACAAQQJHCy4AIAAgARD0ASABQQgQSwRAIAAoAogBIAAgACgCACgCZBECACAAQYwBahDkBgsLBABBAAsWAAJ/IAAQmAEEQCAAKAIADAELIAAL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fGoiBSgCACACKAIAEQEADQALIAAgBU8Ef0EEBSAAIAUQNgwBCwsLIQUgACEDIAUOBQIAAgABAAsLCwsLDAAgAEGAAkEAEFoaCwcAIABBGHYLCAAgAEH/AXELCwAgAEEIdkH/AXELCwAgAEEQdkH/AXELWAAgAUEgEEsEQCAAEJIFCyABQcAAEEsEQCAAEJEFCwJAIAFBgAEQS0UNACAAIAAqAjw4AnAgACgCdCIBRQ0AIAAgASABKAIAKAJEEQcAIAAqAnCUOAJwCwsTACAAKAIUBEAgACgCFCAAEGkLCw8AIAAgACgCACgCADYCAAsfACABQSlGBEAgACACEJEBOgAuQQEPCyAAIAEgAhBSCyMAIABB1OgANgJEIABB/OcANgIAIABB0ABqED4gABBEGiAACwwAIAAQ3gEaIAAQMgssACAAEGUgAEF/NgIMIABCADcCBCAAQdTHADYCACAAQQA2AhAgAEGgCjYCAAsYACAAEOkCIABBsMUANgIAIABBsA82AgALCQAgAEEANgIACyMAIAAQZSAAQdANNgIAIABBBGpBwMMAENoBIABBsMoANgIACw0AIAAoAgAgASgCAEkLEAAgACgCACABKAIAa0ECdQsqACAAKAIAGiAAKAIAIAAQfUECdGoaIAAoAgAgABB9QQJ0ahogACgCABoLFgBBAUEgIABBf2pna3QgACAAQQJPGwslACMAQRBrIgAkACAAIAE2AgggAEEIahCCBiEBIABBEGokACABCwwAIAAgASgCADYCAAsJACAAIAEQgwILDAAgACABELICQQFzCycBAX8jAEEQayIBJAAgAUEIaiAAEOoCIAEoAgghACABQRBqJAAgAAtUAQF/IwBBEGsiASQAIAAQhwYgAEEIahCLAiABQQA2AgwgAEEMaiABQQxqIAFBCGoQhAIgAUGAgID8AzYCBCAAQRBqIAFBBGogARCEAiABQRBqJAALUAEBfyAAEKQCIAAQLyAAKAIAIAAoAgQgAUEEaiICEMcBIAAgAhA2IABBBGogAUEIahA2IAAQLyABEDUQNiABIAEoAgQ2AgAgACAAEDkQgAILCQAgABCHAiAACxEAIABBGCAAKAIAKAIMEQEACwkAIABBADYCAAsDAAELJQAgASAEEIoBIAOUEFYgASAEEIsBIAKUEFUgASAAKgKsARCcAQttAQJ/IwBB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ACgCACgCFBEIACAAIAEgA5IiAyACIAAoAgAoAhgRCAAgACADIAIgBJIiAiAAKAIAKAIYEQgAIAAgASACIAAoAgAoAhgRCAAgACAAKAIAKAIgEQAAC0MBAX8jAEEQayIBJAAgABAvGiABQf////8DNgIMIAFB/////wc2AgggAUEMaiABQQhqEMEBKAIAIQAgAUEQaiQAIAALKgEBfwJAIAFBAEgNACAAQdwAaiIAEDkgAUwNACAAIAEQLigCACECCyACCw8AIABBFGoQoAEgABCgAQshACAAKAIEIAAQLygCAEkEQCAAIAEQpgEPCyAAIAEQowMLEQEBfyAAKAIAIQEgABAtIAELEQAgABCHAiAAQRRqEIcCIAALMgAgABBsIABC/////w83AjAgAEGoPjYCACAAQQA2AkAgAEIANwI4IABBiMEANgIAIAAL+AIBBX8jAEEQayIBJAAgAEHUPTYCSCAAQfw8NgIAIAEgAEHcAGoiBRAqNgIIIAEgBRArNgIAA0AgAUEIaiABECxFBEAgASAAQegAaiIDECo2AgggASADECs2AgADQCABQQhqIAEQLEUEQCABIABB9ABqIgQQKjYCCCABIAQQKzYCAANAIAFBCGogARAsRQRAIAAoAqwBIgIEQCACIAIoAgAoAgQRAAALIAAoAqgBIgIEQCACIAIoAgAoAgQRAAALIABBmAFqED4gAEGMAWoQPiAAQYABahA+IAQQPiADED4gBRA+IABBzABqEI0DIAAQRBogAUEQaiQAIAAPCyABKAIIKAIAIgIEQCACIAIoAgAoAgQRAAALIAFBCGoQLQwAAAsACyABKAIIKAIAIgQEQCAEIAQoAgAoAgQRAAALIAFBCGoQLQwAAAsACyABKAIIKAIAIgMgAEYgA0VyRQRAIAMgAygCACgCBBEAAAsgAUEIahAtDAAACwALLAAgAEH8OjYCACAAQagCahBEGiAAQegBahBEGiAAQagBahBEGiAAEH4aIAALDAAgABCOAhogABAyCxkAIABB/DQ2AgAgAEGIAWoQPiAAEEQaIAALCQAgAEEEahA+Cy0AIABBpDM2AgAgAEHsAWoQPiAAQbABahCRAhogAEGgAWoQjQMgABCMAxogAAsPACAAIAAtAAAgAXI6AAALGAAgAEGwAWpBCEEBEFoaIABBoAFqELAGCxEAIABBADoAACAAQQRqEDoaCzUAIABBnDE2AgAgAEHsAmoQRBogAEGsAmoQRBogAEHsAWoQRBogAEGsAWoQRBogABB+GiAACysBAX8gACABKAIANgIAIAEoAgAhAyAAIAE2AgggACADIAJBAnRqNgIEIAALOgACQAJAAkAgAUGDf2oOAgABAgsgACACEDc2AqgBQQEPCyAAIAIQMLY4AqwBQQEPCyAAIAEgAhCjAgtCAQF9IAFDAABAQJQiAyACQwAAQECUIgIgAUMAAMDAlJIiASABkiAAlCADQwAAgD8gApOSQwAAQECUIACUIACUkpILTQAgAUEIEEsEQCAAQYwBahA5IAAgACgCACgCgAERAgBHBEAgACAAIAAoAgAoAoABEQIAEM0GCyAAIAAoAgAoAoQBEQAACyAAIAEQlQELGAEBfyAAEDkhAiAAIAEQmQMgACACELkDCzMBAX8gABA5IgIgAUkEQCAAIAEgAmsQzAYPCyACIAFLBEAgACAAKAIAIAFBAnRqEJcDCwsrAQF/IAAoAgQhAgNAIAEgAkcEQCAAEC8aIAJBfGohAgwBCwsgACABNgIECx8AIAAQ0wEgAEIFNwKoASAAQZQwNgIAIABBhC82AgALKwAgACoCMCAAKgI0IAAoAjgoAjQgACgCOCgCMCABIAIgACgCOBCcAxCuAgsHACAAQThqCwwAIAAgACgCABCZAwtcAQJ/IwBBEGsiASQAIAAoAjAgABBpIAEgACgCMBCQAiICECo2AgggASACECs2AgADQCABQQhqIAEQLARAIAEoAggoAgAgABBpIAFBCGoQLQwBBSABQRBqJAALCwsoACACIAFrIgBBAU4EQCADKAIAIAEgABBmGiADIAMoAgAgAGo2AgALC0YBAn8jAEEQayICJAAgARAvGiAAIAJBCGoQ3QYgARA5IgMEQCAAIAMQ3AYgACABKAIAIAEoAgQgAxDbBgsgAkEQaiQAIAALJQAgACABEOMGIABB7Cs2AgAgACABKAI8NgI8IABBsDo2AgAgAAsbACAAQQhBABBaGiAAKAKEASIABEAgABCQAwsLVgECfyMAQSBrIgMkACAAEC8iAiADQQhqIAAgABA5QQFqEMwBIAAQOSACEM4BIgIoAgggARB8IAIgAigCCEEEajYCCCAAIAIQiAIgAhChASADQSBqJAALHAAgABD1ASAAIAAoAoQBQaABakEAEKIBNgKIAQsHACAAEEMaCxYAIAEgAi8AADsAACABIAItAAI6AAILUAEBfyAAEJMCIAAQLyAAKAIAIAAoAgQgAUEEaiICEPcGIAAgAhA2IABBBGogAUEIahA2IAAQLyABEDUQNiABIAEoAgQ2AgAgACAAEEgQqgMLKwEBfyAAKAIEIQIDQCABIAJHBEAgABAvGiACQXhqIQIMAQsLIAAgATYCBAszACAAKAIAGiAAKAIAIAAQf0EDbGoaIAAoAgAgABCBAUEDbGoaIAAoAgAgABB/QQNsahoLLAAgACgCABogACgCACAAEIABQQN0ahogACgCACAAEIABQQN0ahogACgCABoLDAAgASACKQIANwIAC2ICAX8BfSMAQRBrIgIkACACIABBABAnKgIAIAFBABAnKgIAk4s4AgwgAiAAQQEQJyoCACABQQEQJyoCAJOLOAIIIAJBDGogAkEIahDwAyoCACEDIAJBEGokACADQwAAgD9eCysBAX8gAEGoKDYCACAAKAJoIgEEQCABIAEoAgAoAgQRAAALIAAQmQIaIAALCgAgAEHMKTYCAAtPACAAEK4DIABB2Cg2AgAgAEEEahA6GiAAQRBqEDoaIABBHGoQOhogAEEoahA6GiAAQTRqEDoaIABBQGsQOhogAEEANgJMIABB0ABqEE4aCw0AIAEgAJMgApQgAJILDQAgACgCACABQQNsagtjAQF/IwBBEGsiByQAIABBKGogB0EIakEBIABBBGoiABBIQf8BcRC1AxC0AyAAIAdBCGogASACEEAQpQEgACAHQQhqIAMgBBBAEKUBIAAgB0EIaiAFIAYQQBClASAHQRBqJAALVgECfyMAQSBrIgMkACAAEC8iAiADQQhqIAAgABA5QQFqEMwBIAAQOSACEKQGIgIoAgggARB8IAIgAigCCEEEajYCCCAAIAIQiAIgAhChASADQSBqJAALIQAgACgCBCAAEC8oAgBJBEAgACABEJEHDwsgACABEJAHCxkAIABBADoAAiAAIAI6AAEgACABOgAAIAALQAEBfyMAQRBrIgMkACAAQShqIANBCGpBACAAQQRqIgAQSEH/AXEQtQMQtAMgACADIAEgAhBAEKUBIANBEGokAAsnAQF/IwBBEGsiAyQAIABBBGogA0EIaiABIAIQQBClASADQRBqJAALOgEB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IAdBAWohBwwAAAsACyAKC6ABAQV/IwBBEGsiAyQAIAAQNRogAS8BACEEAkACQCAAEFAiBUUNACAAIAQgBRA7IgYQLigCACICRQ0AA0AgAigCACICRQ0BIAQgAigCBEcEQCACKAIEIAUQOyAGRw0CCyAEIAIoAgRHDQAgABBFIAJBCGogARDbA0UNAAsgA0EIaiACEEEoAgAhAgwBCyADEIYBIgI2AggLIANBEGokACACCwkAIAAgARCZCAsJACAAQRxqEDkLHwEBfyAAQRxqIgAQOSABSwR/IAAgARAuKAIABUEACwsnAQF/IwBBEGsiAiQAIAIgATYCDCAAQRxqIAJBDGoQUyACQRBqJAALJwEBfyMAQRBrIgIkACACIAE2AgwgAEEQaiACQQxqEFMgAkEQaiQAC8QBAQR/IwBBEGsiASQAIABBwA42AgAgASAAQRxqIgMQKjYCCCABIAMQKzYCAANAAkAgAUEIaiABECxFBEAgASAAQRBqIgIQKjYCCCABIAIQKzYCAANAIAFBCGogARAsRQ0CIAEoAggoAgAiBARAIAQgBCgCACgCBBEAAAsgAUEIahAtDAAACwALIAEoAggoAgAiAgRAIAIgAigCACgCBBEAAAsgAUEIahAtDAELCyADED4gAhA+IAAQ3gEaIAFBEGokACAAC2UCAn8BfSAAKgIEIAFcBEAgACABOAIEIAAqAgggACoCDJMhBCAAKAIALQAoBEAgACgCACgCICECCyAAKAIAKAIQIQMgAEEBNgIUIAAgASACIANsspMiATgCCCAAIAEgBJM4AgwLCz0BAX0gACABNgIAIAEtACgEQCABKAIgsiABKAIQspUhAgsgAEKAgICAEDcCECAAQgA3AgggACACOAIEIAALDAAgACABLQAAOgAACwkAIAAgAToACwsOACAAKAIIQf////8HcQs2AQF/IwBBEGsiAyQAIAFBN0YEQCADIAIQvwEgAEEEaiADELgCIAMQbgsgA0EQaiQAIAFBN0YLHQAgAC0AKAR9IAAoAiCyBUMAAAAACyAAKAIQspULcQEDfyMAQRBrIgEkACAAQYgNNgIAIAEgAEEsaiICECo2AgggASACECs2AgADQCABQQhqIAEQLARAIAEoAggoAgAiAwRAIAMgAygCACgCBBEAAAsgAUEIahAtDAELCyACED4gABDeARog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AEgNACADIgENACAAQwAAAACUDwsgAUEBdCEBIAJBf2oiAkH/AEoNAAtB/wAhAgsCQCABQYCAgARrIgNBAEgNACADIgENACAAQwAAAACUDwsCQCABQf///wNLBEAgASEDDAELA0AgAkF/aiECIAFBgICAAkkhBSABQQF0IgMhASAFDQALCyAEQYCAgIB4cSADQYCAgHxqIAJBF3RyIANBASACa3YgAkEBThtyvg8LIABDAAAAAJQgACABQYCAgPgHRhsLIwAgAEEANgIMIAAgATYCBCAAIAE2AgAgACABQQFqNgIIIAALIwAgACoCjAEgAVwEQCAAIAE4AowBIAAgACgCACgCWBEAAAsLCwAgACABIAIQ/QgLIwAgACoCiAEgAVwEQCAAIAE4AogBIAAgACgCACgCVBEAAAsLEgAgAEUEQEEADwsgACABEIEJCyEAIAAqAlggAVwEQCAAIAE4AlggACAAKAIAKAJQEQAACwuYAgACQAJAIAFBFEsNAAJAAkACQAJAAkACQAJAAkAgAUF3ag4KAAECCQMEBQYJBwgLIAIgAigCACIBQQRqNgIAIAAgASgCADYCAA8LIAIgAigCACIBQQRqNgIAIAAgATQCADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATUCADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATIBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATMBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATAAADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATEAADcDAA8LIAAgAiADEQMACw8LIAIgAigCAEEHakF4cSIBQQhqNgIAIAAgASkDADcDAAtEAQN/IAAoAgAsAAAQtgEEQANAIAAoAgAiAiwAACEDIAAgAkEBajYCACADIAFBCmxqQVBqIQEgAiwAARC2AQ0ACwsgAQshACAAKgJ8IAFcBEAgACABOAJ8IAAgACgCACgCVBEAAAsL2wIBA38jAEHQAWsiBSQAIAUgAjYCzAFBACECIAVBoAFqQQBBKBA9GiAFIAUoAswBNgLIAQJAQQAgASAFQcgBaiAFQdAAaiAFQaABaiADIAQQvwJBAEgNACAAKAJMQQBOBEBBASECCyAAKAIAIQYgACwASkEATARAIAAgBkFfcTYCAAsgBkEgcSEHAn8gACgCMARAIAAgASAFQcgBaiAFQdAAaiAFQaABaiADIAQQvwIMAQsgAEHQADYCMCAAIAVB0ABqNgIQIAAgBTYCHCAAIAU2AhQgACgCLCEGIAAgBTYCLCAAIAEgBUHIAWogBUHQAGogBUGgAWogAyAEEL8CIAZFDQAaIABBAEEAIAAoAiQRBAAaIABBADYCMCAAIAY2AiwgAEEANgIcIABBADYCECAAKAIUGiAAQQA2AhRBAAsaIAAgACgCACAHcjYCACACRQ0ACyAFQdABaiQAC38CAX8BfiAAvSIDQjSIp0H/D3EiAkH/D0cEfCACRQRAIAEgAEQAAAAAAAAAAGEEf0EABSAARAAAAAAAAPBDoiABEJUEIQAgASgCAEFAags2AgAgAA8LIAEgAkGCeGo2AgAgA0L/////////h4B/g0KAgICAgICA8D+EvwUgAAsLgQICA38BfCMAQRBrIgMkAAJAIAC8IgRB/////wdxIgJB2p+k7gRNBEAgASAAuyIFIAVEg8jJbTBf5D+iRAAAAAAAADhDoEQAAAAAAAA4w6AiBUQAAABQ+yH5v6KgIAVEY2IaYbQQUb6ioDkDACAFmUQAAAAAAADgQWMEQCAFqiECDAILQYCAgIB4IQIMAQsgAkGAgID8B08EQCABIAAgAJO7OQMAQQAhAgwBCyADIAIgAkEXdkHqfmoiAkEXdGu+uzkDCCADQQhqIAMgAhCPCSECIARBf0wEQCABIAMrAwCaOQMAQQAgAmshAgwBCyABIAMpAwA3AwALIANBEGokACACCygBAX8jAEEQayIBJAAgASAANgIMQfiwAUEFIAEoAgwQBiABQRBqJAALKAEBfyMAQRBrIgEkACABIAA2AgxB97ABQQQgASgCDBAGIAFBEGokAAsoAQF/IwBBEGsiASQAIAEgADYCDEH2sAFBAyABKAIMEAYgAUEQaiQACygBAX8jAEEQayIBJAAgASAANgIMQfWwAUECIAEoAgwQBiABQRBqJAALKAEBfyMAQRBrIgEkACABIAA2AgxBiK8BQQEgASgCDBAGIAFBEGokAAsoAQF/IwBBEGsiASQAIAEgADYCDEH0sAFBACABKAIMEAYgAUEQaiQACyEAIAAqAjggAVwEQCAAIAE4AjggACAAKAIAKAI8EQAACwviAQBBlK8BQfmEARAcQbywAUH+hAFBAUEBQQAQGxChCRCgCRCfCRCeCRCdCRCcCRCbCRCaCRCZCRCYCRCXCUHArwFB6IUBEBBB6rABQfSFARAQQeuwAUEEQZWGARAMQeywAUECQaKGARAMQe2wAUEEQbGGARAMQYSvAUHAhgEQGhCWCUHuhgEQnARBk4cBEJsEQbqHARCaBEHZhwEQmQRBgYgBEJgEQZ6IARCXBBCVCRCUCUGJiQEQnARBqYkBEJsEQcqJARCaBEHriQEQmQRBjYoBEJgEQa6KARCXBBCTCRCSCQs3AQF/IAAoAgQiA0EBdSABaiEBIAAoAgAhACABIAIgA0EBcQR/IAEoAgAgAGooAgAFIAALERcACykBAX8jAEEQayICJAAgAiABNgIMIAJBDGogABECACEAIAJBEGokACAACyQAIABB0IABNgIAIAAtAAQEQCAAQcT7ABB4CyAAQQhqEFkgAAsUACAAKAIIIAEgAiADIAQgBRCsCQs5AQF/IAAoAgQiBEEBdSABaiEBIAAoAgAhACABIAIgAyAEQQFxBH8gASgCACAAaigCAAUgAAsREQALEAAgACgCCCABIAIgAxDUCQskACAAQcj9ADYCACAALQAEBEAgAEHE+wAQeAsgAEEIahBZIAALJwECfyABKAIAIQIjAEEQayIDJAAgACABQQRqIAIQvAIgA0EQaiQACwsAQRgQKSAAENEDCy0AIAAgASACQwAAgD9cBH0gAiADlEMAAIA/IAKTIAAgARDiCZSSBSADCxDZCQskACAAQYT7ADYCACAALQAEBEAgAEHE+wAQeAsgAEEIahBZIAALOQEBfyAAKAIEIgRBAXUgAWohASAAKAIAIQAgASACIAMgBEEBcQR/IAEoAgAgAGooAgAFIAALEQUACw4AIAAoAgAQHSAAKAIACysBAX8gACgCBCECA0AgASACRwRAIAAQLxogAkF/aiECDAELCyAAIAE2AgQLIQAgASAAKAIYRwRAIAAgATYCGCAAIAAoAgAoAjQRAAALCx0BAX8jAEEQayIBJAAgASAANgIMIAFBEGokACAACzwBAX8jAEEQayICJAAgAiABKQIANwMIQbqwASAAQQJBpIMBQZj5AEGeByACQQhqEDRBABAAIAJBEGokAAslACAAIAEgAkMAAIA/XAR/IAAgARDHCiADIAIQ3AIFIAMLELwKCxkAIAFBARBYIgEEfyABIAAQ1gNBAAVBAQsLBgBBtrABCwYAQZuvAQsXACAAIAEQlwFB7q8BIAIoAgAQDRDkAQsaAQF/QQwQKSIBIAAQyAkgAUGYgAE2AgAgAQs7AQF/IwBBEGsiASQAIAEgADYCDEHurwFBoPoAQQJBgIABQaz5AEGRByABQQxqEHpBABAAIAFBEGokAAsGAEHurwELPgEBfyMAQRBrIgEkACABIAApAgA3AwhB7q8BQebxAEECQfj/AEGs+QBBjQcgAUEIahA0QQEQACABQRBqJAALEAAgASACIAMgACgCGBCwBAs+AQF/IwBBEGsiASQAIAEgACkCADcDCEHurwFB3vEAQQRB4P8AQfD/AEGMByABQQhqEDRBARAAIAFBEGokAAs+AQF/IwBBEGsiASQAIAEgACkCADcDCEHurwFBtvEAQQNBrP8AQbz5AEGKByABQQhqEDRBARAAIAFBEGokAAs+AQF/IwBBEGsiASQAIAEgACkCADcDCEHurwFBsvEAQQNBoP8AQbz5AEGJByABQQhqEDRBARAAIAFBEGokAAs+AQF/IwBBEGsiASQAIAEgACkCADcDCEHurwFBrfEAQQNBlP8AQbz5AEGIByABQQhqEDRBARAAIAFBEGokAAs+AQF/IwBBEGsiASQAIAEgACkCADcDCEHurwFBo/EAQQNBgP8AQYz/AEGHByABQQhqEDRBARAAIAFBEGokAAs+AQF/IwBBEGsiASQAIAEgACkCADcDCEHurwFBnfEAQQNB9P4AQbz5AEGGByABQQhqEDRBARAAIAFBEGokAAs+AQF/IwBBEGsiASQAIAEgACkCADcDCEHurwFBgPEAQQNB6P4AQbz5AEGFByABQQhqEDRBARAAIAFBEGokAAsGAEHsrwELFwAgACABEJcBQcOvASACKAIAEA0Q5AELGgEBf0EMECkiASAAEOEJIAFBlP0ANgIAIAELOwEBfyMAQRBrIgEkACABIAA2AgxBw68BQaD6AEECQfz8AEGs+QBBhAcgAUEMahB6QQAQACABQRBqJAALBgBBw68BCz4BAX8jAEEQayIBJAAgASAAKQIANwMIQcOvAUHx7gBBCEHQ/ABB8PwAQYAHIAFBCGoQNEEBEAAgAUEQaiQACwcAIAFBHUYLPgEBfyMAQRBrIgEkACABIAApAgA3AwhBw68BQdruAEEDQaD8AEG8+QBB/gYgAUEIahA0QQEQACABQRBqJAALPgEBfyMAQRBrIgEkACABIAApAgA3AwhBw68BQdLuAEEEQZD8AEHg+QBB/QYgAUEIahA0QQEQACABQRBqJAALBgBBwa8BCxcAIAAgARCXAUGZrwEgAigCABANEOQBC1QBAX8jAEEgayIDJAAgA0EIaiABEKYEIAMgAhDGAiADQRhqIANBCGogAyAAEQUAIANBGGoQqwQhACADQRhqEFkgAxBZIANBCGoQbiADQSBqJAAgAAsaAQF/QQwQKSIBIAAQ9gkgAUHg+gA2AgAgAQs7AQF/IwBBEGsiASQAIAEgADYCDEGZrwFBoPoAQQJByPoAQaz5AEH7BiABQQxqEHpBABAAIAFBEGokAAsEAEEdCwYAQZmvAQs+AQF/IwBBEGsiASQAIAEgACkCADcDCEGWrwFBq+4AQQZBgPoAQZj6AEH3BiABQQhqEDRBABAAIAFBEGokAAvYBAIBfwx9IwBB4ABrIgUkACAEQQIQJyoCACAEQQAQJyoCAJMhBiAEQQMQJyoCACAEQQEQJyoCAJMhByAEQQAQJyoCACEOIAIqAgAhDyAEQQEQJyoCACEQQwAAgD8hCCACKgIEIRFDAACAPyEJAkACfQJAAkACQAJAAkACQCABDgcAAQIEAwcFBwsgAxCEASAGlSEJIAMQgwEgB5UhCAwGCyADEIQBIAaVIAMQgwEgB5UQ0gMMBAsgAxCEASAGlSADEIMBIAeVEPMIDAMLIAMQgwEgB5UMAgsgAxCEASAGlQwBCyADEIQBIAaVIAMQgwEgB5UQ0gMiCEMAAIA/IAhDAACAP10bCyIIIQkLIAVByABqEE4hASADQQAQJyoCACEKIAMQhAEhCyACKgIAIQwgAxCEASENIAFBBBAnIAu7RAAAAAAAAOA/oiAKu6AgDCANlLtEAAAAAAAA4D+ioLY4AgAgA0EBECcqAgAhCiADEIMBIQsgAioCBCEMIAMQgwEhDSABQQUQJyALu0QAAAAAAADgP6IgCrugIAwgDZS7RAAAAAAAAOA/oqC2OAIAIAVBMGoQTiIDQQAQJyAJOAIAIANBAxAnIAg4AgAgBUEYahBOIgRBBBAnIA6MuyAGu0QAAAAAAADgP6KhIAYgD5S7RAAAAAAAAOA/oqG2OAIAIARBBRAnIBCMuyAHu0QAAAAAAADgP6KhIAcgEZS7RAAAAAAAAOA/oqG2OAIAIAUQTiICIAEgAxCsASACIAIgBBCsASAAIAIgACgCACgCEBEDACAFQeAAaiQACz4BAX8jAEEQayIBJAAgASAAKQIANwMIQZmvAUGi7gBBA0Ho+QBBvPkAQfYGIAFBCGoQNEEBEAAgAUEQaiQACz4BAX8jAEEQayIBJAAgASAAKQIANwMIQZmvAUGZ7gBBBEHQ+QBB4PkAQfUGIAFBCGoQNEEBEAAgAUEQaiQACz4BAX8jAEEQayIBJAAgASAAKQIANwMIQZmvAUGP7gBBA0Gw+QBBvPkAQfQGIAFBCGoQNEEBEAAgAUEQaiQACwYAQZavAQsqAQF/IwBBEGsiACQAQfTtAEECQZD5AEGY+QBB8gZB2AUQJSAAQRBqJAALz0MCBX8BfiMAQZANayIAJAAQ1wRBlq8BQZevAUGYrwFBAEGc+QBB2QVBn/kAQQBBn/kAQQBB+e0AQaH5AEHaBRACIABCiICAgBA3A4gIIABCiICAgBA3A4gNQYLuACAAQYgIahDPAiAAQoyAgIAQNwOACCAAQoyAgIAQNwOIDUGH7gAgAEGACGoQzwIgAEKQgICAEDcD+AcgAEKQgICAEDcDiA0gAEH4B2oQ1QQgAEKUgICAEDcD8AcgAEKUgICAEDcDiA0gAEHwB2oQ1AQgAEKYgICAEDcD6AcgAEKYgICAEDcDiA0gAEHoB2oQ0wQgAEEANgKMDSAAQdsFNgKIDSAAIAApA4gNNwPgByAAQeAHahDRBEGZrwFBmq8BQZ+vAUGWrwFBnPkAQdwFQZz5AEH4BkGc+QBB+QZBse4AQaH5AEHdBRACQfoGEM4EQZavAUG0+gBBAkHQ+gBBmPkAQd4FQd8FEAhBlq8BQb76AEEDQfD7AEH8+wBB4AVB4QUQCEHBrwFBhq8BQcKvAUEAQZz5AEHiBUGf+QBBAEGf+QBBAEHB7gBBofkAQeMFEAIgAEKIgICAEDcD2AcgAEKIgICAEDcDiA1BzO4AIABB2AdqEM4CIABCqICAgBA3A9AHIABCqICAgBA3A4gNIABB0AdqEMkEIABCjICAgBA3A8gHIABCjICAgBA3A4gNIABByAdqEMgEIABClICAgBA3A8AHIABClICAgBA3A4gNQePuACAAQcAHahDNAiAAQpiAgIAQNwO4ByAAQpiAgIAQNwOIDUHq7gAgAEG4B2oQzQIgAEKcgICAEDcDsAcgAEKcgICAEDcDiA0gAEGwB2oQxgQgAEKggICAEDcDqAcgAEKggICAEDcDiA1B+e4AIABBqAdqEM4CQcOvAUHErwFBx68BQcGvAUGc+QBB5AVBnPkAQYEHQZz5AEGCB0H/7gBBofkAQeUFEAJBgwcQxARBwa8BQbT6AEECQYT9AEGY+QBB5gVB5wUQCEHBrwFBvvoAQQNB8PsAQfz7AEHgBUHoBRAIAn9B6K8BQZHvAEEEQQEQCiAAQYgNagtBou8AQQEQzAJBp+8AQQAQzAIaAn9Bxa8BQa7vAEEEQQEQCiAAQYgNagtBt+8AQQAQywJBv+8AQQEQywIaAn9B6a8BQcfvAEEEQQAQCiAAQYgNagtB0e8AQQAQ6gFB1u8AQQEQ6gFB3O8AQQIQ6gEaAn9B6q8BQePvAEEEQQAQCiAAQYgNagtB7u8AQQAQ6QFB1u8AQQEQ6QFB9O8AQQIQ6QEaAn9B668BQfrvAEEEQQAQCiAAQYgNagtBhPAAQQMQT0GM8ABBDhBPQZPwAEEPEE9Bm/AAQRAQT0Gi8ABBERBPQarwAEESEE9BtfAAQRMQT0G/8ABBFBBPQcnwAEEVEE9B0/AAQRYQT0He8ABBFxBPQejwAEEYEE9B8fAAQRkQT0H18ABBGhBPQYDxAEEbEE9BhvEAQRwQTxpB7K8BQYWvAUHtrwFBAEGc+QBB6QVBn/kAQQBBn/kAQQBBkfEAQaH5AEHqBRACIABChICAgBA3A6AHIABChICAgBA3A4gNIABBoAdqEMAEIABCgICAgBA3A5gHIABCgICAgBA3A4gNIABBmAdqEL8EIABCiICAgBA3A5AHIABCiICAgBA3A4gNIABBkAdqEL4EIABCjICAgBA3A4gHIABCjICAgBA3A4gNIABBiAdqEL0EIABCkICAgBA3A4AHIABCkICAgBA3A4gNIABBgAdqELwEIABClICAgBA3A/gGIABClICAgBA3A4gNIABB+AZqELsEIABCmICAgBA3A/AGIABCmICAgBA3A4gNQcDxACAAQfAGahDJAiAAQpyAgIAQNwPoBiAAQpyAgIAQNwOIDUHP8QAgAEHoBmoQyQIgAEKggICAEDcD4AYgAEKggICAEDcDiA0gAEHgBmoQugQgAEKkgICAEDcD2AYgAEKkgICAEDcDiA0gAEHYBmoQuARB7q8BQe+vAUHwrwFB7K8BQZz5AEHrBUGc+QBBjgdBnPkAQY8HQffxAEGh+QBB7AUQAkGQBxC2BEHsrwFBtPoAQQJBiIABQZj5AEHtBUHuBRAIQeyvAUG++gBBA0Hw+wBB/PsAQeAFQe8FEAhBm68BQbSwAUG1sAFBAEGc+QBB8AVBn/kAQQBBn/kAQQBBivIAQaH5AEHxBRACIABBADYCjA0gAEHyBTYCiA0gACAAKQOIDTcD0AZBm68BQZDyAEHGrwFBkIIBQfMFIABB0AZqEDNBAEEAQQBBABABIABBADYCjA0gAEH0BTYCiA0gACAAKQOIDTcDyAZBm68BQZPyAEHGrwFBkIIBQfMFIABByAZqEDNBAEEAQQBBABABIABBADYCjA0gAEH1BTYCiA0gACAAKQOIDTcDwAZBm68BQZbyAEHGrwFBkIIBQfMFIABBwAZqEDNBAEEAQQBBABABIABBADYCjA0gAEH2BTYCiA0gACAAKQOIDTcDuAZBm68BQZnyAEHGrwFBkIIBQfMFIABBuAZqEDNBAEEAQQBBABABIABBADYCjA0gAEH3BTYCiA0gACAAKQOIDTcDsAZBm68BQZzyAEHGrwFBkIIBQfMFIABBsAZqEDNBAEEAQQBBABABIABBADYCjA0gAEH4BTYCiA0gACAAKQOIDTcDqAZBm68BQZ/yAEHGrwFBkIIBQfMFIABBqAZqEDNBAEEAQQBBABABQbawAUGVrwFBt7ABQQBBnPkAQfkFQZ/5AEEAQZ/5AEEAQaLyAEGh+QBB+gUQAiAAQQA2AvQMIABB+wU2AvAMIAAgACkD8Aw3A6AGIABB+AxqIABBoAZqEDggACAAKQP4DCIFNwOYBiAAIAU3A4gNIABBmAZqEM4KIABBADYC5AwgAEH8BTYC4AwgACAAKQPgDDcDkAYgAEHoDGogAEGQBmoQOCAAIAApA+gMIgU3A4gGIAAgBTcDiA0gAEGIBmoQzQogAEEANgLUDCAAQf0FNgLQDCAAIAApA9AMNwOABiAAQdgMaiAAQYAGahA4IAAoAtgMIQEgACAAKALcDDYCjA0gACABNgKIDSAAIAApA4gNNwP4BSAAQfgFahDMCiAAQQA2AowNIABB/gU2AogNIAAgACkDiA03A/AFIABB8AVqEMsKQbqwAUG4sAFBu7ABQQBBnPkAQf8FQZ/5AEEAQZ/5AEEAQeTyAEGh+QBBgAYQAiAAQQA2AsQMIABBgQY2AsAMIAAgACkDwAw3A+gFIABByAxqIABB6AVqEDggACgCyAwhASAAIAAoAswMNgKMDSAAIAE2AogNIAAgACkDiA03A+AFQbqwAUHt8gBBwK8BQZj5AEGCBiAAQeAFahAzQQBBAEEAQQAQASAAQQA2AowNIABBgwY2AogNIAAgACkDiA03A9gFIABB2AVqEMkKIABBADYCjA0gAEGEBjYCiA0gACAAKQOIDTcD0AUgAEHQBWoQyAogAEEANgKMDSAAQYUGNgKIDSAAIAApA4gNNwPIBSAAQcgFahDFCiAAQQA2AowNIABBhgY2AogNIAAgACkDiA03A8AFIABBwAVqEMMKIABBADYCjA0gAEGHBjYCiA0gACAAKQOIDTcDuAUgAEG4BWoQwQogAEEANgKMDSAAQYgGNgKIDSAAIAApA4gNNwOwBSAAQbAFahC/CiAAQQA2ArQMIABBiQY2ArAMIAAgACkDsAw3A6gFIABBuAxqIABBqAVqEDggACgCuAwhASAAIAAoArwMNgKMDSAAIAE2AogNIAAgACkDiA03A6AFIABBoAVqEL4KIABBADYCpAwgAEGKBjYCoAwgACAAKQOgDDcDmAUgAEGoDGogAEGYBWoQOCAAKAKoDCEBIAAgACgCrAw2AowNIAAgATYCiA0gACAAKQOIDTcDkAUgAEGQBWoQvQogAEEANgKMDSAAQYsGNgKIDSAAIAApA4gNNwOIBUHG8wAgAEGIBWoQrwQgAEEANgKUDCAAQYwGNgKQDCAAIAApA5AMNwOABSAAQZgMaiAAQYAFahA4IAAoApgMIQEgACAAKAKcDDYCjA0gACABNgKIDSAAIAApA4gNNwP4BCAAQfgEahC6CiAAQQA2AoQMIABBjQY2AoAMIAAgACkDgAw3A/AEIABBiAxqIABB8ARqEDggACgCiAwhASAAIAAoAowMNgKMDSAAIAE2AogNIAAgACkDiA03A+gEIABB6ARqELkKIABBADYCjA0gAEGOBjYCiA0gACAAKQOIDTcD4ARB/PMAIABB4ARqEK8EIABBADYCjA0gAEGPBjYCiA0gACAAKQOIDTcD2ARBurABQY70AEGerwFBmPkAQZAGIABB2ARqEDNBAEEAQQBBABABQcSwAUG+sAFBxbABQQBBnPkAQZEGQZ/5AEEAQZ/5AEEAQZX0AEGh+QBBkgYQAiAAQQA2AvQLIABBkwY2AvALIAAgACkD8As3A9AEIABB+AtqIABB0ARqEDggAEEANgLkCyAAQZQGNgLgCyAAIAApA+ALNwPIBCAAKAL4CyEBIAAoAvwLIQIgAEHoC2ogAEHIBGoQOCAAKALoCyEDIAAoAuwLIQQgACACNgKMDSAAIAE2AogNIAAgACkDiA03A8AEIABBwARqEDMhASAAIAQ2AoQNIAAgAzYCgA0gACAAKQOADTcDuARBxLABQaj0AEHGrwFBkIIBQZUGIAFBxq8BQYz/AEGWBiAAQbgEahAzEAEgAEEANgLUCyAAQZcGNgLQCyAAIAApA9ALNwOwBCAAQdgLaiAAQbAEahA4IABBADYCxAsgAEGYBjYCwAsgACAAKQPACzcDqAQgACgC2AshASAAKALcCyECIABByAtqIABBqARqEDggACgCyAshAyAAKALMCyEEIAAgAjYCjA0gACABNgKIDSAAIAApA4gNNwOgBCAAQaAEahAzIQEgACAENgKEDSAAIAM2AoANIAAgACkDgA03A5gEQcSwAUGv9ABBxq8BQZCCAUGVBiABQcavAUGM/wBBlgYgAEGYBGoQMxABIABBADYCtAsgAEGZBjYCsAsgACAAKQOwCzcDkAQgAEG4C2ogAEGQBGoQOCAAQQA2AqQLIABBmgY2AqALIAAgACkDoAs3A4gEIAAoArgLIQEgACgCvAshAiAAQagLaiAAQYgEahA4IAAoAqgLIQMgACgCrAshBCAAIAI2AowNIAAgATYCiA0gACAAKQOIDTcDgAQgAEGABGoQMyEBIAAgBDYChA0gACADNgKADSAAIAApA4ANNwP4A0HEsAFBtvQAQcavAUGQggFBlQYgAUHGrwFBjP8AQZYGIABB+ANqEDMQAUHGsAFBv7ABQcewAUHEsAFBnPkAQZsGQZz5AEGhB0Gc+QBBogdBv/QAQaH5AEGcBhACIABCyICAgBA3A5ALIABCyICAgBA3A/ADIABBmAtqIABB8ANqEDggAEEANgKECyAAQZ0GNgKACyAAIAApA4ALNwPoAyAAKAKYCyEBIAAoApwLIQIgAEGIC2ogAEHoA2oQOCAAKAKICyEDIAAoAowLIQQgACACNgKMDSAAIAE2AogNIAAgACkDiA03A+ADIABB4ANqEDMhASAAIAQ2AoQNIAAgAzYCgA0gACAAKQOADTcD2ANBxrABQcT0AEHGrwFBkIIBQZ4GIAFBxq8BQYz/AEGfBiAAQdgDahAzEAEgAELMgICAEDcD8AogAELMgICAEDcD0AMgAEH4CmogAEHQA2oQOCAAQQA2AuQKIABBoAY2AuAKIAAgACkD4Ao3A8gDIAAoAvgKIQEgACgC/AohAiAAQegKaiAAQcgDahA4IAAoAugKIQMgACgC7AohBCAAIAI2AowNIAAgATYCiA0gACAAKQOIDTcDwAMgAEHAA2oQMyEBIAAgBDYChA0gACADNgKADSAAIAApA4ANNwO4A0HGsAFBxvQAQcavAUGQggFBngYgAUHGrwFBjP8AQZ8GIABBuANqEDMQAUHIsAFBwLABQcmwAUHEsAFBnPkAQaEGQZz5AEGjB0Gc+QBBpAdByPQAQaH5AEGiBhACIABBADYC1AogAEGjBjYC0AogACAAKQPQCjcDsAMgAEHYCmogAEGwA2oQOCAAQQA2AsQKIABBpAY2AsAKIAAgACkDwAo3A6gDIAAoAtgKIQEgACgC3AohAiAAQcgKaiAAQagDahA4IAAoAsgKIQMgACgCzAohBCAAIAI2AowNIAAgATYCiA0gACAAKQOIDTcDoAMgAEGgA2oQMyEBIAAgBDYChA0gACADNgKADSAAIAApA4ANNwOYA0HIsAFBzfQAQcavAUGQggFBpQYgAUHGrwFBjP8AQaYGIABBmANqEDMQAUHKsAFBwbABQcuwAUHIsAFBnPkAQacGQZz5AEGlB0Gc+QBBpgdB1PQAQaH5AEGoBhACIABCyICAgBA3A7AKIABCyICAgBA3A5ADIABBuApqIABBkANqEDggAEEANgKkCiAAQakGNgKgCiAAIAApA6AKNwOIAyAAKAK4CiEBIAAoArwKIQIgAEGoCmogAEGIA2oQOCAAKAKoCiEDIAAoAqwKIQQgACACNgKMDSAAIAE2AogNIAAgACkDiA03A4ADIABBgANqEDMhASAAIAQ2AoQNIAAgAzYCgA0gACAAKQOADTcD+AJByrABQcT0AEHGrwFBkIIBQaoGIAFBxq8BQYz/AEGrBiAAQfgCahAzEAEgAELMgICAEDcDkAogAELMgICAEDcD8AIgAEGYCmogAEHwAmoQOCAAQQA2AoQKIABBrAY2AoAKIAAgACkDgAo3A+gCIAAoApgKIQEgACgCnAohAiAAQYgKaiAAQegCahA4IAAoAogKIQMgACgCjAohBCAAIAI2AowNIAAgATYCiA0gACAAKQOIDTcD4AIgAEHgAmoQMyEBIAAgBDYChA0gACADNgKADSAAIAApA4ANNwPYAkHKsAFBxvQAQcavAUGQggFBqgYgAUHGrwFBjP8AQasGIABB2AJqEDMQAUHMsAFBzbABQc6wAUEAQZz5AEGtBkGf+QBBAEGf+QBBAEHd9ABBofkAQa4GEAIgAEEANgL0CSAAQa8GNgLwCSAAIAApA/AJNwPQAiAAQfgJaiAAQdACahA4IAAoAvgJIQEgACAAKAL8CTYCjA0gACABNgKIDSAAIAApA4gNNwPIAkHMsAFB7fIAQcCvAUGY+QBBsAYgAEHIAmoQM0EAQQBBAEEAEAFBz7ABQcKwAUHQsAFBzLABQZz5AEGxBkGc+QBBpwdBnPkAQagHQef0AEGh+QBBsgYQAiAAQQA2AuQJIABBrwY2AuAJIAAgACkD4Ak3A8ACIABB6AlqIABBwAJqEDggACgC6AkhASAAIAAoAuwJNgKMDSAAIAE2AogNIAAgACkDiA03A7gCQc+wAUHt8gBBwK8BQZj5AEGzBiAAQbgCahAzQQBBAEEAQQAQASAAQQA2AtQJIABBtAY2AtAJIAAgACkD0Ak3A7ACIABB2AlqIABBsAJqEDggACgC2AkhASAAIAAoAtwJNgKMDSAAIAE2AogNIAAgACkDiA03A6gCQc+wAUH39ABB0bABQZj5AEG1BiAAQagCahAzQQBBAEEAQQAQASAAQQA2AsQJIABBtgY2AsAJIAAgACkDwAk3A6ACIABByAlqIABBoAJqEDggACgCyAkhASAAIAAoAswJNgKMDSAAIAE2AogNIAAgACkDiA03A5gCQc+wAUGA9QBB0bABQZj5AEG1BiAAQZgCahAzQQBBAEEAQQAQASAAQQA2ArQJIABBtwY2ArAJIAAgACkDsAk3A5ACIABBuAlqIABBkAJqEDggACgCuAkhASAAIAAoArwJNgKMDSAAIAE2AogNIAAgACkDiA03A4gCQc+wAUGE9QBB0bABQZj5AEG1BiAAQYgCahAzQQBBAEEAQQAQASAAQQA2AqQJIABBuAY2AqAJIAAgACkDoAk3A4ACIABBqAlqIABBgAJqEDggACgCqAkhASAAIAAoAqwJNgKMDSAAIAE2AogNIAAgACkDiA03A/gBQc+wAUGO9QBB0bABQZj5AEG1BiAAQfgBahAzQQBBAEEAQQAQASAAQQA2ApQJIABBuQY2ApAJIAAgACkDkAk3A/ABIABBmAlqIABB8AFqEDggACgCmAkhASAAIAAoApwJNgKMDSAAIAE2AogNIAAgACkDiA03A+gBQc+wAUGW9QBBvLABQZj5AEG6BiAAQegBahAzQQBBAEEAQQAQASAAQQA2AoQJIABBuwY2AoAJIAAgACkDgAk3A+ABIABBiAlqIABB4AFqEDggACgCiAkhASAAIAAoAowJNgKMDSAAIAE2AogNIAAgACkDiA03A9gBQc+wAUGl9QBB0bABQZj5AEG1BiAAQdgBahAzQQBBAEEAQQAQASAAQQA2AvQIIABBvAY2AvAIIAAgACkD8Ag3A9ABIABB+AhqIABB0AFqEDggACgC+AghASAAIAAoAvwINgKMDSAAIAE2AogNIAAgACkDiA03A8gBQc+wAUGv9QBBxq8BQZCCAUG9BiAAQcgBahAzQQBBAEEAQQAQASAAQQA2AowNIABBvgY2AogNIAAgACkDiA03A8ABIABBwAFqEK4KQdKwAUHTsAFB1LABQQBBnPkAQb8GQZ/5AEEAQZ/5AEEAQbv1AEGh+QBBwAYQAhCrCiAAQQA2AuQIIABBwgY2AuAIIAAgACkD4Ag3A7gBIABB6AhqIABBuAFqEDggAEEANgLUCCAAQcMGNgLQCCAAIAApA9AINwOwASAAKALoCCEBIAAoAuwIIQIgAEHYCGogAEGwAWoQOCAAKALYCCEDIAAoAtwIIQQgACACNgKMDSAAIAE2AogNIAAgACkDiA03A6gBIABBqAFqEDMhASAAIAQ2AoQNIAAgAzYCgA0gACAAKQOADTcDoAFB0rABQdP1AEHGrwFBkIIBQcQGIAFBxq8BQYz/AEHFBiAAQaABahAzEAEgAEEANgKMDSAAQcYGNgKIDSAAIAApA4gNNwOYAUHSsAFB2PUAQbywAUGY+QBBxwYgAEGYAWoQM0EAQQBBAEEAEAEgAEEANgKMDSAAQcgGNgKIDSAAIAApA4gNNwOQASAAQZABahCoCiAAQQA2AowNIABByQY2AogNIAAgACkDiA03A4gBIABBiAFqEKYKQdWwAUHDsAFB1rABQcywAUGc+QBBygZBnPkAQa0HQZz5AEGuB0Hg9QBBofkAQcsGEAJB17ABQdiwAUHZsAFBAEGc+QBBzAZBn/kAQQBBn/kAQQBB7fUAQaH5AEHNBhACEKEKIABBADYCjA0gAEHPBjYCiA0gACAAKQOIDTcDgAEgAEGAAWoQoAogAEEANgKMDSAAQdAGNgKIDSAAIAApA4gNNwN4IABB+ABqEJ8KIABBADYCjA0gAEHRBjYCiA0gACAAKQOIDTcDcCAAQfAAahCdCiAAQQA2AowNIABB0gY2AogNIAAgACkDiA03A2ggAEHoAGoQnApB27ABQdqwAUHcsAFBAEGc+QBB0wZBn/kAQQBBn/kAQQBBk/YAQaH5AEHUBhACIABBADYCjA0gAEHVBjYCiA0gACAAKQOIDTcDYEHbsAFBnPYAQd2wAUGY+QBB1gYgAEHgAGoQM0EAQQBBAEEAEAEgAEEANgKMDSAAQdcGNgKIDSAAIAApA4gNNwNYQduwAUHt8gBBwK8BQZj5AEHYBiAAQdgAahAzQQBBAEEAQQAQAUHbsAFBofYAQd2wAUGm9gBBnPkAQdkGQQBBABAFQduwAUGo9gBB3bABQbD2AEGc+QBB2QZBAEEAEAVB27ABQbL2AEHdsAFBuvYAQZz5AEHZBkEAQQAQBRCXChCVChCSCkHhsAFB3rABQeKwAUHbsAFBnPkAQd0GQZz5AEG3B0Gc+QBBuAdB1vYAQaH5AEHeBhACIABBADYCxAggAEHfBjYCwAggACAAKQPACDcDUCAAQcgIaiAAQdAAahA4IABBADYCtAggAEHgBjYCsAggACAAKQOwCDcDSCAAKALICCEBIAAoAswIIQIgAEG4CGogAEHIAGoQOCAAKAK4CCEDIAAoArwIIQQgACACNgKMDSAAIAE2AogNIAAgACkDiA03A0AgAEFAaxAzIQEgACAENgKEDSAAIAM2AoANIAAgACkDgA03AzhB4bABQd72AEG8sAFBmPkAQeEGIAFBvLABQbz5AEHiBiAAQThqEDMQAUHjsAFB37ABQeSwAUHbsAFBnPkAQeMGQZz5AEG5B0Gc+QBBugdB5PYAQaH5AEHkBhACIABBADYCpAggAEHlBjYCoAggACAAKQOgCDcDMCAAQagIaiAAQTBqEDggAEEANgKUCCAAQeYGNgKQCCAAIAApA5AINwMoIAAoAqgIIQEgACgCrAghAiAAQZgIaiAAQShqEDggACgCmAghAyAAKAKcCCEEIAAgAjYCjA0gACABNgKIDSAAIAApA4gNNwMgIABBIGoQMyEBIAAgBDYChA0gACADNgKADSAAIAApA4ANNwMYQeOwAUHe9gBBxq8BQZCCAUHnBiABQcavAUGM/wBB6AYgAEEYahAzEAFB5bABQeCwAUHmsAFB27ABQZz5AEHpBkGc+QBBuwdBnPkAQbwHQe72AEGh+QBB6gYQAiAAQQA2AowNIABB6wY2AogNIAAgACkDiA03AxAgAEEQahCNCgJ/QZyvAUH+9gBBAUEAEAogAEGIDWoLQaLvAEEAEI8BQYL3AEEBEI8BQYr3AEECEI8BQZD3AEEDEI8BQZn3AEEEEI8BQaP3AEEFEI8BQaj3AEEGEI8BGkGdrwFB57ABQeiwAUEAQZz5AEHsBkGf+QBBAEGf+QBBAEGy9wBBofkAQe0GEAIgAEEANgKMDSAAQe4GNgKIDSAAIAApA4gNNwMIQZ2vAUHE9ABBxq8BQZCCAUHvBiAAQQhqEDNBAEEAQQBBABABIABBADYCjA0gAEHwBjYCiA0gACAAKQOIDTcDAEGdrwFBxvQAQcavAUGQggFB7wYgABAzQQBBAEEAQQAQAUGdrwFBvPcAQZ2vAUHg5ABBnPkAQfEGQQBBABAFQZ2vAUHE9wBBna8BQejkAEGc+QBB8QZBAEEAEAVBna8BQc73AEGdrwFB8OQAQZz5AEHxBkEAQQAQBUGdrwFB1/cAQZ2vAUH45ABBnPkAQfEGQQBBABAFQZ2vAUHi9wBBna8BQYDlAEGc+QBB8QZBAEEAEAVBna8BQen3AEGdrwFBiOUAQZz5AEHxBkEAQQAQBUGdrwFB9fcAQZ2vAUGQ5QBBnPkAQfEGQQBBABAFQZ2vAUGA+ABBna8BQZjlAEGc+QBB8QZBAEEAEAVBna8BQY34AEGdrwFBoOUAQZz5AEHxBkEAQQAQBQJ/QZ6vAUGZ+ABB9IQBQb4HQaH5AEG/BxAkIABBiA1qC0Ge+ABBABDmAUGj+ABBBBDmAUGo+ABBCBDmAUGt+ABBDBDmARpBnq8BECIgAEGQDWokAAspAQF/IwBBEGsiAiQAEPoJIABB8O0AIAJBCGogARD5CRAEIAJBEGokAAszAQF/IwBBEGsiAiQAIAIgADYCBCACQQhqIAEQOCACQQRqIAJBCGoQ+wkgAkEQaiQAIAALkgEBAn8jAEEgayIDJAACQCAAEC8oAgAgACgCBGsgAU8EQCAAIAEQhQoMAQsgABAvIQIgA0EIaiAAIAAQbyABahCECiAAEG8gAhCDCiICIAEQggogACACEIEKIAIgAigCBBD8CSACKAIABEAgAigCEBogAigCACEAIAIQNSgCACACKAIAaxogABAyCwsgA0EgaiQACysBAX8jAEEQayICJAAgAEGIrwEgAkEIaiABENoEEBM2AgAgAkEQaiQAIAALQQEBfyAAEG8iAiABSQRAIAAgASACaxDbBA8LIAIgAUsEQCAAKAIAIAFqIQEgABBvIQIgACABEKwEIAAgAhCACgsLRAICfwF8IwBBEGsiASQAIAAoAgBBwPgAKAIAIAFBBGoQCyEDIAEgASgCBBBBIQAgAxDlASECIAAQuwEgAUEQaiQAIAILPAEBfyMAQRBrIgIkACAAIAEoAgACfyACQQhqIgBB5e0AEB82AgAgACgCAAsQFBBBGiAAEFkgAkEQaiQACzIAIAFBGhBYIgFFBEBBAQ8LIAAgACgCBLIgASgCBCgCELKVOAIUIAEoAgggABDBA0EAC8UBAQN/IwBBMGsiASQAIAFBIGoQOiECIAFBCGogABDfBCABQQhqEN4EIQMgAUEIahBZIAIgAxDdBCABIAIoAgA2AgwgASADNgIIIAFBGGogAUEIahDcBCIDKAIAIAAQ2QQgAUEIaiACKAIAIAIQbxDVByEAIAFBADYCBCAAIAFBBGoQ7AUgASgCBCEAIAMQWSACENACIAIoAgAEQCACIAIoAgAQrAQgAhAvGiACKAIAIQMgAhCOARogAxAyCyABQTBqJAAgAAtEAgJ/AXwjAEEQayIBJAAgACgCAEG8+AAoAgAgAUEEahALIQMgASABKAIEEEEhACADEOUBIQIgABC7ASABQRBqJAAgAgtIAgF/AXwjAEEQayIDJAAQhgogASACIANBBGogA0EIahCuBBAhIQQgAyADKAIEEEEhASAAIAQQ5QEQxgIgARC7ASADQRBqJAALRAICfwF8IwBBEGsiASQAIAAoAgBBuPgAKAIAIAFBBGoQCyEDIAEgASgCBBBBIQAgAxDlASECIAAQuwEgAUEQaiQAIAILPgECfyMAQRBrIgAkACAAENICIABBCGogAEHG7QAQ0QIgABBZIABBCGoQ5AQhASAAQQhqEFkgAEEQaiQAIAELTAEBf0EBIQICQCAAKAIMQQFOBEAgASAAKAIMIAEoAgAoAgARAQAiAUUNASABQRwgASgCACgCDBEBAEUNASAAIAE2AhALQQAhAgsgAgtZAAJAAkACQAJAAkAgAUGOf2oOBAABAgMECyAAIAIQMLY4AjBBAQ8LIAAgAhAwtjgCNEEBDwsgACACEDC2OAI4QQEPCyAAIAIQNzYCPEEBDwsgACABIAIQUgsTAEEBIQAgAUEKRiABQS9GckVFCwQAQS8LCgAgAEFAahDTAgsMACAAQUBqIAEQ1AILHwAgACgCFBCKAgR/IAAoAhQgAEFAazYCSEEABUECCwsJACAAENUCEDILGAAgAUE1RgRAIAAgAhA3NgIECyABQTVGC1IBAX8gABBsIABCADcCMCAAQeTsADYCACAAQgA3AjggAEFAayIBQbDtADYCACAAQYDsADYCACABQdTsADYCABC6ASEBIABBADYCSCAAIAE2AkQLGwEBfyAAKAIwIgEgACgCQCABKAIAKAIMEQMACxsBAX8gACgCMCIBIAAoAjwgASgCACgCEBEDAAsbAQF/IAAoAjAiASAAKgI4IAEoAgAoAggRCgALSQEBfyAALQAuBEAgAQJ/IAAoAkgiAwRAIAMgAiADKAIAKAIAEQEAIQILIAILIAIoAgAoAiQRAgAgACgCMCABKAIAKAIUEQUACwtQACAAIAEQ6wEiAUEAIAEoAgAoAgARAwAgASAAKgI4IAEoAgAoAggRCgAgASAAKAI8IAEoAgAoAhARAwAgASAAKAJAIAEoAgAoAgwRAwAgAQsMAEECQQQgAC0ARBsLDwAgACAAKAIAKAI4EQAACwoAIABBTGoQ1gILBwAgAUEaRgs2AAJAIAAgARBbIgENAEEBIQEgAEE0aiAAKAIUENcCRQ0AIAAgACgCACgCOBEAAEEAIQELIAELHAAgACgCFBCyBiIBRQRAQQEPCyABIAAQgARBAAs4ACAAKAJMIgAgAUEAECcqAgAgAUEBECcqAgAgAkEAECcqAgAgAkEBECcqAgAgACgCACgCHBEUAAuyAQEFfyMAQRBrIgUkACAAIABBBGogAEEIaiIGIAIQkAEaIABBDGohAwNAIAEgA0cEQCADKAIAIAYoAgAgAigCABEBAARAIAUgAygCADYCDCADIQcDQAJAIAcgBiIEKAIANgIAIAAgBEYEQCAAIQQMAQsgBCEHIAUoAgwgBEF8aiIGKAIAIAIoAgARAQANAQsLIAQgBUEMaigCADYCAAsgAyIGQQRqIQMMAQsLIAVBEGokAAsEAEEaCwcAIAAqAhALCQAgABD4ARAyCwsAIABBvH9qEO8BCzgAIAAoAkwiACABQQAQJyoCACABQQEQJyoCACACQQAQJyoCACACQQEQJyoCACAAKAIAKAIYERQACzwBAX8jAEEgayICJAAgAiABNgIQIAIgADYCGCACQbIFNgIMIAIoAhggAigCECACQQxqEO4BIAJBIGokAAsdACABQRkQWCIBRQRAQQEPCyABKAIEIAAQwQNBAAsNACAAKgI0IAEqAjRdC+oCAgZ/An0jAEEgayICJAAgAUGABBBLBEAgAEHQAGoiAxAqIAMQKxCCBQsgAUHAABBLIQMCQCABQYACQYABEKkBQSAQqQEQS0UEQCAALQBcRSADQQFzcg0BCyAAQcQAaiIGKAIIIQEgAkEYaiAAKgIwIAAqAjQQQCEDIAJBEGogACoCOCAAKgI8EEAhBQJAAkAgAC0AXEUNACAAKAJgIgRFDQAgBBB0IQQgAkEIahBDIgcgAyAEEKwCIAIQQyIDIAUgBBCsAiAAIAcgAyAAKAIAKAJMEQUADAELIAAgAyAFIAAoAgAoAkwRBQALIAAqAkAhCCAGKgIEIQkgAiAAQdAAaiIAECo2AgggAiAAECs2AgAgCCAJlCEIA0AgAkEIaiACECwEQCABIAIoAggoAgAiACgCMCAIEN0CIAAqAjQgASgCACgCIBERACACQQhqEC0MAQUgASABKAIAKAIkEQAACwsLIAJBIGokAAsoAQF/IwBBEGsiAiQAIAIgATYCDCAAQdAAaiACQQxqEFMgAkEQaiQACzYBAX8CQCAAKAIUIgFFDQAgASgCFEUNACAAIAEoAhQiARCqAgR/IAEFQQALNgJgIAEgABBpCwsiACAAIAEQWyIBRQRAIABBxABqIAAoAhQQ1wJBAXMPCyABCxQAIAAoAhRBgAJBgAQQVEEAEFoaCwoAIAAoAhQQ7wELPAEBfwJAIAAgARBbIgENAEEBIQEgACgCFCICQRYgAigCACgCDBEBAEUNACAAKAIUIAAQhgVBACEBCyABCz0AIAAtAC4EQCACIAIoAgAoAiQRAgAiAiAAKAI4IAIoAgAoAgwRAwAgASACIAAoAjAgASgCACgCFBEFAAsLagEBfyMAQRBrIgIkACACIABBCGoiABAqNgIIIAIgABArNgIAA0ACQCACQQhqIAIQLEUEQEEAIQAMAQsgAigCCCgCACIAIAEgACgCACgCGBEBACIADQAgAkEIahAtDAELCyACQRBqJAAgAAsaACAAIAEQ6wEiAEEBIAAoAgAoAgARAwAgAAtqAQF/IwBBEGsiAiQAIAIgAEEIaiIAECo2AgggAiAAECs2AgADQAJAIAJBCGogAhAsRQRAQQAhAAwBCyACKAIIKAIAIgAgASAAKAIAKAIUEQEAIgANACACQQhqEC0MAQsLIAJBEGokACAACwwAIABBgAFBARBaGgsxAQJ/IABB2ABqIQEgACgCdCICBEAgASACQdgAaiAAQUBrEKwBDwsgASAAQUBrEMUHC3cCAX8BfSAAQUBrIQECQCAAKgIwQwAAAABcBEAgASAAKgIwEMYHDAELIAEQzwMLIAAgACgCACgCSBEHACECIABBQGsiAUEEECcgAjgCACAAIAAoAgAoAkwRBwAhAiABQQUQJyACOAIAIAEgACoCNCAAKgI4EMQHCwcAIAAoAggLKgEBfyMAQRBrIgEkACABQQhqIABBCGooAgAQQSgCACEAIAFBEGokACAACzMBAX8jAEEQayICJAAgAiABNgIIIAIoAggvAQAhASAAQQA2AgQgACABOwEAIAJBEGokAAvVAQIDfwF9IwBBEGsiAiQAIAIgATYCDAJAIAIgAUEBRgR/QQIFIAEgAUF/anFFDQEgARCaAQsiATYCDAsCQCABIAAQUCIDSwRAIAAgARDhAgwBCyABIANPDQAgAxB7IQQCfyAAEDUoAgCzIAAQRSoCAJWNIgVDAACAT10gBUMAAAAAYHEEQCAFqQwBC0EACyEBIAICfyAEBEAgARCBAgwBCyABEJoBCzYCCCACIAJBDGogAkEIahBdKAIAIgE2AgwgASADTw0AIAAgARDhAgsgAkEQaiQAC1oAIwBBEGsiAyQAIAEQLyEBIABBEBApIANBCGogAUEAEMQBEMMBIgAoAgBBCGogBCgCABCVBSAAEEJBAToABCAAKAIAIAI2AgQgACgCAEEANgIAIANBEGokAAveAQEFfyMAQRBrIgckACABEFAhBSABIAIoAgQgBRA7IgYQLigCACEDA0AgAyIEKAIAIgMgAkcNAAsCQCAEIAFBCGpHBEAgBCgCBCAFEDsgBkYNAQsgAigCACIDBEAgAygCBCAFEDsgBkYNAQsgASAGEC5BADYCAAsCQCACKAIAIgNFDQAgAygCBCAFEDsiAyAGRg0AIAEgAxAuIAQ2AgALIAQgAigCADYCACACQQA2AgAgARA1IgQgBCgCAEF/ajYCACAAIAIgB0EIaiABEC9BARDEARDDARogB0EQaiQACzwBAn8jAEEgayICJAAgAkEYaiABEEEiAxD2ASACQQhqIAAgARCYBSACQQhqEMIBIAMoAgAaIAJBIGokAAvpAwIFfwF9IwBBIGsiBSQAIAEQNRogAi8BACEIIAEQUCEGIAVBADoAHwJAAkAgBkUNACABIAggBhA7IgkQLigCACIHRQ0AA0AgBygCACIHRQ0BIAggBygCBEcEQCAHKAIEIAYQOyAJRw0CCyABEEUgB0EIaiACENsDRQ0ACwwBCyAFQRBqIAEgCEGIwwAgAyAEEJcFIAEQNSgCACECIAEQRSEDAkAgBgRAIAMqAgAgBrOUIAJBAWqzXUEBcw0BCyAFIAYQe0EBcyAGQQF0cjYCDCAFAn8gARA1KAIAQQFqsyABEEUqAgCVjSIKQwAAgE9dIApDAAAAAGBxBEAgCqkMAQtBAAs2AgggASAFQQxqIAVBCGoQXSgCABCWBSAIIAEQUCIGEDshCQsCQCABIAkQLigCACICRQRAIAUoAhAgAUEIaiICKAIANgIAIAIgBSgCEDYCACABIAkQLiACNgIAIAUoAhAoAgBFDQEgBSgCECECIAEgBSgCECgCACgCBCAGEDsQLiACNgIADAELIAUoAhAgAigCADYCACACIAUoAhA2AgALIAVBEGoQyAEhByABEDUiASABKAIAQQFqNgIAIAVBAToAHyAFQRBqEMIBCyAAIAVBEGogBxBBIAVBH2oQxgEgBUEgaiQACwcAIAAqAhQLTgEBfyMAQSBrIgIkACACIAAgARDvAzYCGCACEIYBNgIQIAJBGGogAkEQahCyAkUEQCAAIAJBCGogAkEYahCSASgCABCZBQsgAkEgaiQAC6ABAQV/IwBBEGsiAyQAIAAQNRogASgCACEEAkACQCAAEFAiBUUNACAAIAQgBRA7IgYQLigCACICRQ0AA0AgAigCACICRQ0BIAQgAigCBEcEQCACKAIEIAUQOyAGRw0CCyAEIAIoAgRHDQAgABBFIAJBCGogARCeAUUNAAsgA0EIaiACEEEoAgAhAgwBCyADEIYBIgI2AggLIANBEGokACACC1cAAkACQAJAAkACQCABQZJ/ag4EAAECAwQLIAAgAhA3NgJAQQEPCyAAIAIQNzYCREEBDwsgACACEDc2AkhBAQ8LIAAgAhA3NgJMQQEPCyAAIAEgAhDcAwsrACABQXZqIgBB//8DcUEkTQRAQoGAgICAAyAArUL//wODiKdBAXEPC0EACwQAQS4LIwAgAUF2akH//wNxIgBBHU0EQEGDgICAAyAAdkEBcQ8LQQALBABBJwsHACABQRdGC4UCAgV/AX0gAEEIaiIHEDkiCEF/aiEEA0ACQAJAIAUgBEwEQCAHIAQgBWpBAXUiBhAuKAIAKgIUIgkgAl1BAXNFBEAgBkEBaiEFDAQLIAkgAl5BAXNFDQEgBiEFCyAAKAIEIQYgBUUEQCAHQQAQLigCACIAIAEgBiADIAAoAgAoAiwRDgAPCyAHIAVBf2oQLigCACEEIAUgCEgEQCAHIAUQLigCACIAKgIUIAJbBEAgACABIAYgAyAAKAIAKAIsEQ4ADwsgBCgCCEUNAiAEIAEgBiACIAAgAyAEKAIAKAIwERUADwsMAQsgBkF/aiEEDAELCyAEIAEgBiADIAQoAgAoAiwRDgALBABBFwsfACABQShGBEAgACACEDc2AjhBAQ8LIAAgASACEPcBCyQAIAFBdmoiAEH//wNxQQtNBEBBgxggAEH/H3F2QQFxDwtBAAsEAEEUCzcAAkACQAJAIAFBWmoOAgABAgsgACACEK4BNgIwQQEPCyAAIAIQMLY4AjRBAQ8LIAAgASACEFILEwBBASEAIAFBCkYgAUETRnJFRQsEAEETCx8AIAFBJUYEQCAAIAIQrgE2AjBBAQ8LIAAgASACEFILEwBBASEAIAFBCkYgAUESRnJFRQsEAEESCwkAIAAQ5gIQMgskACABQXZqIgBB//8DcUELTQRAQYMQIABB/x9xdkEBcQ8LQQALBABBFQtYAAJAAkACQAJAAkAgAUFRag4EAAECAwQLIAAgAhAwtjgCOEEBDwsgACACEDc2AjxBAQ8LIAAgAhA3NgJAQQEPCyAAIAIQkQE6AERBAQ8LIAAgASACEPcBCyYAIAFBdmoiAEH//wNxQQ5NBEBBg5ABIABB//8BcXZBAXEPC0EACwQAQRgLJAAgAUF2aiIAQf//A3FBDE0EQEGDISAAQf8/cXZBAXEPC0EACwQAQRELeQACQAJAAkACQAJAAkACQCABQV9qDgoBAgMFBQUFBQUABAsgACACEDC2OAIwQQEPCyAAIAIQMLY4AjRBAQ8LIAAgAhAwtjgCOEEBDwsgACACEDC2OAI8QQEPCyABQS5GDQELIAAgASACEFIPCyAAIAIQMLY4AkBBAQskACABQXZqIgBB//8DcUEMTQRAQYMgIABB/z9xdkEBcQ8LQQALBABBFgshACABQY0BRgRAIAAgAhCRAToAEEEBDwsgACABIAIQtgILIgAgAUFKaiIAQf//A3FBBU0EQEEjIABBP3F2QQFxDwtBAAsEAEE7CyQAIAFBRGoiAEH//wNxQQZNBEBB0QAgAEH/AHF2QQFxDwtBAAsFAEHAAAsiACABQUpqIgBB//8DcUEETQRAQRMgAEEfcXZBAXEPC0EACyUAA0AgASAAKAIIRwRAIAAoAhAaIAAgACgCCEF8ajYCCAwBCwsLBABBOgskACABQURqIgBB//8DcUEGTQRAQckAIABB/wBxdkEBcQ8LQQALBABBPwskACABQURqIgBB//8DcUEGTQRAQcUAIABB/wBxdkEBcQ8LQQALBABBPgseAEEBIQACQAJAIAFBvX9qDgMBAAEAC0EAIQALIAALBQBBxQALBwAgACoCCAshACABQYwBRgRAIAAgAhAwtjgCEEEBDwsgACABIAIQtgILCgAgAUFKakEDSQsEAEE4CxkAIAFBlQFGBEAgACACEDc2AhBBAQ8LQQALJAAgAUFEaiIAQf//A3FBBk0EQEHDACAAQf8AcXZBAXEPC0EACwQAQT0LNwAgABBsIABCADcCRCAAQoCAgICAgIDAPzcCPCAAQoCAgPwDNwI0IABBfzYCMCAAQfTdADYCAAsoACAAEIIBIABCADcCMCAAQbzYADYCACAAQgA3AjggAEFAa0IANwIACzUAIAAQ/QEgAEEAOgAoIABCfzcCICAAQoCAgPwDNwIYIABCvICAgMAHNwIQIABByM0ANgIACykBAX8jAEEQayICJAAgAkEIaiAAIAEQnQUQQSgCACEAIAJBEGokACAAC0EAIAAQ7QIgAEL/gYCAEDcCSCAAQv+BgIAQNwJAIABBoN8ANgIAIABBzN4ANgIAIABB0ABqEEMaIABB2ABqEEMaC1IAIAAQggEgAEIANwJAIABCgICAgICAgMA/NwI4IABCgICA/AM3AjAgAEGg3QA2AgAgAEH8FjYCACAAQcgAahBOGiAAQeAAahA6GiAAQQA2AmwLdwEBfyAAENAFIABByABqIgFBkNkANgIAIABBzABqEJEDIABB/Dw2AgAgAUHUPTYCACAAQdwAahA6GiAAQegAahA6GiAAQfQAahA6GiAAQYABahA6GiAAQYwBahA6GiAAQZgBahA6GiAAQgA3AqwBIABCADcCpAELKAAgABD9ASAAQczMADYCACAAQcAONgIAIABBEGoQOhogAEEcahA6GgsuACAAEOkCIABBhMoANgIAIABBgBE2AgAgAEEQahA6GiAAQQA2AiQgAEIANwIcC+kDAgV/AX0jAEEgayIFJAAgARA1GiACKAIAIQggARBQIQYgBUEAOgAfAkACQCAGRQ0AIAEgCCAGEDsiCRAuKAIAIgdFDQADQCAHKAIAIgdFDQEgCCAHKAIERwRAIAcoAgQgBhA7IAlHDQILIAEQRSAHQQhqIAIQngFFDQALDAELIAVBEGogASAIQYjDACADIAQQ+wIgARA1KAIAIQIgARBFIQMCQCAGBEAgAyoCACAGs5QgAkEBarNdQQFzDQELIAUgBhB7QQFzIAZBAXRyNgIMIAUCfyABEDUoAgBBAWqzIAEQRSoCAJWNIgpDAACAT10gCkMAAAAAYHEEQCAKqQwBC0EACzYCCCABIAVBDGogBUEIahBdKAIAEPoCIAggARBQIgYQOyEJCwJAIAEgCRAuKAIAIgJFBEAgBSgCECABQQhqIgIoAgA2AgAgAiAFKAIQNgIAIAEgCRAuIAI2AgAgBSgCECgCAEUNASAFKAIQIQIgASAFKAIQKAIAKAIEIAYQOxAuIAI2AgAMAQsgBSgCECACKAIANgIAIAIgBSgCEDYCAAsgBUEQahDIASEHIAEQNSIBIAEoAgBBAWo2AgAgBUEBOgAfIAVBEGoQwgELIAAgBUEQaiAHEEEgBUEfahDGASAFQSBqJAALHQEBfyAAQQRqIgAQnQIEf0EABSAAQQAQLigCAAsLYgEBfyMAQRBrIgIkACACIABBBGoiABAqNgIIIAIgABArNgIAA0ACQCACQQhqIAIQLEUEQEEAIQAMAQsgAigCCCgCACIAEEIgARCIAQ0AIAJBCGoQLQwBCwsgAkEQaiQAIAALQgEBfyMAQSBrIgIkACACIAEQhgI2AhAgAkEYaiAAIAEgAkEQaiACQQhqEJoFIAJBGGoQbSEAIAJBIGokACAAQQRqC1UBAX8jAEEQayICJAAgAiABNgIIIAIgABAqNgIAIAJBCGogAhD/ASEBIAAgACgCACABQQJ0aiIBQQRqIAAoAgQgARDyAhCXAyABENYBGiACQRBqJAALVgEBfyMAQRBrIgMkACADIAE2AgAgAyAANgIIA0ACQCADQQhqIAMQLEUNACADKAIIKAIAIAIoAgBGDQAgA0EIahAtDAELCyADKAIIIQAgA0EQaiQAIAALLQEBfyMAQRBrIgEkACABIAAoAgQ2AgggAUEIahDiAigCACEAIAFBEGokACAACzUBAX8jAEEQayICJAAgAiAAKAIENgIIIAIgASgCBDYCACACQQhqIAIQLCEAIAJBEGokACAAC1UBAX8jAEEQayICJAAgAiABNgIMIAIgAEEMaiACQQxqENIFNgIIIAIQmQE2AgBBfyEAIAJBCGogAhD/A0UEQCACQQhqEG0oAgQhAAsgAkEQaiQAIAALIAAgAEF8aiIAQZwBTQRAIABBAnRB7N8AaigCAA8LQX8L+REBAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABBf2oORysdHiUfKSIkMzMzMzMzMyEXGRocMxYsGAIFCgszDREzMyAjMw4zMy4vJjAxLTIbACoGJygPMzMDCRIVMwEIEBMMMzMEMwcUMwtBxAAQKUEAQcQAED0iABCIAxoMMwtBGBApIgBCADcDACAAQgA3AxAgAEIANwMIIAAQrQEaIABBfzYCECAAQfjDADYCACAAQczDADYCAAwyC0EUECkiAEIANwMAIABBADYCECAAQgA3AwggABBlIABBADYCBCAAQaTEADYCACAAQcAINgIAIABBCGoQOhoMMQtBFBApIgBCADcDACAAQQA2AhAgAEIANwMIIAAQ+wEgAEEANgIQIABBgMUANgIAIABB0MQANgIADDALQQgQKSIAQgA3AwAgABDoAiAAQYjGADYCACAAQZQUNgIADC8LQRQQKSIAQgA3AwAgAEEANgIQIABCADcDCCAAEGUgAEEANgIEIABB6MYANgIAIABBsAk2AgAgAEEIahA6GgwuC0EcECkiAEIANwMAIABBADYCGCAAQgA3AxAgAEIANwMIIAAQ+gEgAEF/NgIYIABBlMcANgIAIABB3As2AgAMLQtBEBApIgBCADcDACAAQgA3AwggABDnAiAAQQA2AgwgAEGIyAA2AgAgAEHYEzYCAAwsC0EQECkiAEIANwMAIABCADcDCCAAEK0BGiAAQdzJADYCACAAQbTJADYCAAwrC0EoEClBAEEoED0iABDXBQwqC0EQECkiAEIANwMAIABCADcDCCAAEP0BDCkLQcAAEClBAEHAABA9IgAiAiIBEGUgAULh9dH4g4CAwD83AgwgAUK9lNz2AzcCBCABQdzKADYCACACQYgINgIADCgLQSQQKUEAQSQQPSIAIgEiAhDUAyACQgA3AgwgAkL/////DzcCBCACQZTLADYCACABQQA2AhQgAUHwETYCACABQRhqEDoaDCcLQRwQKSIAQgA3AwAgAEEANgIYIABCADcDECAAQgA3AwggABD6ASAAQQA2AhggAEHMywA2AgAgAEGcCzYCAAwmC0EcECkiAEIANwMAIABBADYCGCAAQgA3AxAgAEIANwMIIAAQ+gEgAEEANgIYIABBjMwANgIAIABB3Ao2AgAMJQtBKBApQQBBKBA9IgAQ1gUMJAtBEBApIgBCADcDACAAQgA3AwggABCtARogAEGgzQA2AgAgAEH4zAA2AgAMIwtBOBApQQBBOBA9IgAiARDRBSABQYgNNgIAIAFBLGoQOhoMIgtBEBApIgBCADcDACAAQgA3AwggABD7ASAAQbzOADYCACAAQZDOADYCAAwhC0EQECkiAEIANwMAIABCADcDCCAAEK0BGiAAQZDPADYCACAAQejOADYCAAwgC0EMECkiAEIANwMAIABBADYCCCAAEOcCIABBuM8ANgIAIABB7BI2AgAMHwtBFBApIgBCADcDACAAQQA2AhAgAEIANwMIIAAQ+wEgAEEAOgAQIABBoNAANgIAIABB8M8ANgIADB4LQeQAEClBAEHkABA9IgAQ7gIMHQtB5AAQKUEAQeQAED0iACIBIgIQ7gIgAkGE0gA2AkQgAkGs0QA2AgAgAUH86QA2AkQgAUGk6QA2AgAMHAtBzAAQKUEAQcwAED0iACICIgEQ5AIgAUEBOgBEIAFBADYCQCABQoCAgPwDNwI4IAFBkNIANgIAIAJBADYCSCACQaTrADYCAAwbC0HAABApQQBBwAAQPSIAIgEiAhBsIAJB9OjRezYCMCACQazTADYCACABQTRqEOsCIQIgAUHU6gA2AgAgAkGY6wA2AgAMGgtBOBApQQBBOBA9IgAiAiIBEGwgAUL/////DzcCMCABQezTADYCACACQbjnADYCAAwZC0HMABApIgAQ7wQMGAtBPBApQQBBPBA9IgAiAiIBEOQCIAFBADYCOCABQbDUADYCACACQejmADYCAAwXC0GAARApQQBBgAEQPSIAEKECDBYLQfwBECkiABC/BgwVC0HAABApQQBBwAAQPSIAEGsaDBQLQdwAEClBAEHcABA9IgAiAiIBEJ8CIAFBADYCWCABQgA3AlAgAUGA1QA2AgAgAkHMHTYCAAwTC0GkARApQQBBpAEQPSIAIgEiAhDDAyACQQA6AJgBIAJB3NUANgIAIAFBnAFqIgJBADYCBCACQdDWADYCACABQYAuNgIAIAJB+C42AgAMEgtBrAMQKSIAEMUGDBELQdgAEClBAEHYABA9IgAiAiIBEJ8CIAFCADcCUCABQdzWADYCACACQYgfNgIADBALQegCECkiABCoBgwPC0GoBBApIgAQqgcMDgtB0AAQKUEAQdAAED0iACIBIgIQbCACQQE6ADggAkL/////DzcCMCACQbTXADYCACABQcAcNgIAIAFBPGoQOhogAUIANwJIDA0LQbABECkiABCaAwwMC0G0ARApIgAiARCaAyABQYCAgPgDNgKwASABQZw5NgIAIAFBiDg2AgAMCwtB4AAQKUEAQeAAED0iABCnARoMCgtBOBApQQBBOBA9IgAiASICEIIBIAJBfzYCMCACQfzXADYCACABQQA2AjQgAUHIwAA2AgAMCQtBtAEQKUEAQbQBED0iABDVBQwIC0EEECkiAEEANgIAIAAQZSAAQcTZADYCACAAQZzZADYCAAwHC0HAABApQQBBwAAQ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ECwEQCACKAIYKAIAIgNFDQIgAxCrAkUNASADIQEDQCABRQ0CIAEgBEYEQCADIAAQ7gUMAwUgASgCFCEBDAELAAALAAsgABC6ATYCTCACQSBqJABBAA8LIAMQzANFIAMgBEZyDQAgAyEBA0AgAUUNASAAKAJIIAFGBEAgAiADNgIMIANBoAFqQQRBEBCpARCPAyAFIAJBDGoQUwUgASgCFCEBDAELCwsgAkEYahAtDAAACwALNQEBfSABQQAQJyoCACAAQQAQJyoCAJMiAiAClCABQQEQJyoCACAAQQEQJyoCAJMiAiAClJILUAEBfyAAQQAQJyIDIAMqAgAgAZQ4AgAgAEEBECciAyADKgIAIAGUOAIAIABBAhAnIgMgAyoCACAClDgCACAAQQMQJyIAIAAqAgAgApQ4AgALiAEBAX8gAUEAECcoAgAhAiAAQQAQJyACNgIAIAFBARAnKAIAIQIgAEEBECcgAjYCACABQQIQJygCACECIABBAhAnIAI2AgAgAUEDECcoAgAhAiAAQQMQJyACNgIAIAFBBBAnKAIAIQIgAEEEECcgAjYCACABQQUQJygCACEBIABBBRAnIAE2AgALVQEBfSABEIsBIQIgARCKASEBIABBABAnIAE4AgAgAEEBECcgAjgCACAAQQIQJyACjDgCACAAQQMQJyABOAIAIABBBBAnQQA2AgAgAEEFECdBADYCAAssACAAIAEoAgA2AgAgACABKAIENgIEIAAgASgCCDYCCCAAIAEoAgw2AgwgAAsIACABQcIARgsFAEHCAAsvAQF/IwBBEGsiASQAIABCADcCACABQQA2AgwgAEEIaiABQQxqEPwBIAFBEGokAAsiAQF/QRAQKSIBQgA3AwAgAUIANwMIIAAgARCtARDVA0EBC7ECAQR/IwBBIGsiAiQAIAAoAggoAgQhAyACIAAoAgRBEGoiARAqNgIYIAIgARArNgIQA0ACQAJAAkAgAkEYaiACQRBqECxFBEBBAiEBDAELAkAgAigCGCgCACIBELEBRQ0AIAEoAhBBf0YNACABIAMgASgCEBD/AiIENgIUIAQNAEEBIQFBASEADAMLIAIgAUEEaiIBECo2AgggAiABECs2AgACfwNAIAJBCGogAhAsRQRAQQQhAUEADAILAkAgAigCCCgCACIBKAIEQQBIDQAgASgCBCAAKAIE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IAAoAghPRQRAIAAoAgwgAkECdGooAgAiAyADKAIAKAIAEQAAIAJBAWohAgwBCwsgAC0ABAtZAQJ/A0AgACgCDCEBIAIgACgCCE8EQCABBEAgARAyCyAAKAIUIgAEQCAAEDILDwsgASACQQJ0aigCACIBBEAgASABKAIAKAIIEQAACyACQQFqIQIMAAALAAsrACAAQgA3AhQgAEIANwIAIABBgICA/AM2AhwgAEIANwIIIABBADoAECAAC+QDAQR/IABBADoABCAAIAE2AgAgACABEPEDIgM2AgggAEF/IANBAnQgAyADQf////8DcUcbECk2AgwDfyACIANPBH8gACABQRBqEDkiBDYCEEF/IARBBXQiAiAEIARB////P3FHGxApIQMgBARAIAIgA2ohBCADIQIDQCACEKEIQSBqIgIgBEcNAAsLIAAgAzYCFEEABQJAIAEgAhDyAyIFRQRAIAAoAgwgAkECdGpBADYCAAwBCwJAAkACQAJAIAUgBSgCACgCCBECAEFIag4EAQMCAAMLQRAQKSIDIgQgBSAAELQCIARBnBA2AgAgBCAFLQAQOgAMIAAoAgwgAkECdGogAzYCAAwDC0EQECkiAyIEIAUgABC0AiAEQbAQNgIAIAQgBSoCEDgCDCAAKAIMIAJBAnRqIAM2AgAMAgtBEBApIgMiBCAFIAAQtAIgBEEAOgAMIARBxBA2AgAgACgCDCACQQJ0aiADNgIADAELIAAoAgwgAkECdGpBADYCAAsgAkEBaiECIAAoAgghAwwBCwshAgNAIAIgACgCEEkEQCAAKAIUIAJBBXRqIgQgAUEQaiIDEDkgAksEfyADIAIQLigCAAVBAAsiAzYCACAEIAMoAiA2AgQgAkEBaiECDAELCyAACwkAIABBADoADAsXACAALQAMRQRAIABBAToADCAAELMCCwsZACAAKgIMIAFcBEAgACABOAIMIAAQswILCxkAIAEgAC0ADEcEQCAAIAE6AAwgABCzAgsLCQAgACgCCBBCCwcAIAFBNkYLBABBNgtWAQF/AkACQAJAAkACQAJAIAFBQWoOBAABAgMFCyAAIAIQMLY4AgQMAwsgACACEDC2OAIIDAILIAAgAhAwtjgCDAwBCyAAIAIQMLY4AhALQQEhAwsgAwsMACABQf7/A3FBNkYLBABBNwsdACABQTUQWCIBRQRAQQEPCyABKAIEIAAQ8wNBAAsTAEEBIQAgAUEbRiABQTVGckVFCwQAQTULBwAgAUEcRgscACABQQEQWCIBBH8gASgCBCAAEJgGQQAFQQELC88BAQN/IwBBEGsiAiQAIAIgAEEcaiIDECo2AgggAiADECs2AgADQAJAIAJBCGogAhAsIgRFDQAgAigCCCgCACIDIAEgAygCACgCGBEBACIDDQAgAkEIahAtDAELCwJAIARFBEAgAiAAQRBqIgAQKjYCCCACIAAQKzYCAANAIAJBCGogAhAsRQRAQQAhAwwDCyACKAIIKAIAIgAgASAAKAIAKAIYEQEAIgMNAiACQQhqEC0MAAALAAsgAkEQaiQAIANB/wFxDwsgAkEQaiQAIAMLzwEBA38jAEEQayICJAAgAiAAQRxqIgMQKjYCCCACIAMQKzYCAANAAkAgAkEIaiACECwiBEUNACACKAIIKAIAIgMgASADKAIAKAIUEQEAIgMNACACQQhqEC0MAQsLAkAgBEUEQCACIABBEGoiABAqNgIIIAIgABArNgIAA0AgAkEIaiACECxFBEBBACEDDAMLIAIoAggoAgAiACABIAAoAgAoAhQRAQAiAw0CIAJBCGoQLQwAAAsACyACQRBqJAAgA0H/AXEPCyACQRBqJAAgAwsJACAAEPUDEDILBABBHAsHACAAKAIcC1kBAn8jAEEQayICJAAgABCYAQRAIAAoAgAhAyAAEPoDGiADEDILIAAgASgCCDYCCCAAIAEpAgA3AgAgAUEAEPkDIAJBADoADyABIAJBD2oQ+AMgAkEQaiQACwcAIAFBG0YLBABBGwuHAQACQAJAAkACQAJAAkACQAJAAkAgAUFIag4HAAECAwQFBgcLIAAgAhA3NgIQDAcLIAAgAhA3NgIUDAYLIAAgAhAwtjgCGAwFCyAAIAIQNzYCHAwECyAAIAIQNzYCIAwDCyAAIAIQNzYCJAwCCyAAIAIQkQE6ACgMAQsgACABIAIQ+wMPC0EBCx8AQQEhAAJAAkAgAUFlag4FAQAAAAEAC0EAIQALIAALBABBHwsHACAAKAIUCwcAIAAoAiQLBwAgACgCIAsHACAALQAoCxwAIAFBARBYIgEEfyABKAIEIAAQmQZBAAVBAQsLJwEBfyMAQRBrIgIkACACIAE2AgwgAEEsaiACQQxqEFMgAkEQaiQAC2oBAX8jAEEQayICJAAgAiAAQSxqIgAQKjYCCCACIAAQKzYCAANAAkAgAkEIaiACECxFBEBBACEADAELIAIoAggoAgAiACABIAAoAgAoAhgRAQAiAA0AIAJBCGoQLQwBCwsgAkEQaiQAIAALagEBfyMAQRBrIgIkACACIABBLGoiABAqNgIIIAIgABArNgIAA0ACQCACQQhqIAIQLEUEQEEAIQAMAQsgAigCCCgCACIAIAEgACgCACgCFBEBACIADQAgAkEIahAtDAELCyACQRBqJAAgAAsJACAAEP0DEDILFABBASEAIAFBPEYgAUHCAEZyRUULBABBPAsaACABQTkQWCIBRQRAQQEPCyABIAAQ1QNBAAtqAQF/IwBBEGsiAiQAIAIgAEEEaiIAECo2AgggAiAAECs2AgADQAJAIAJBCGogAhAsRQRAQQAhAAwBCyACKAIIKAIAIgAgASAAKAIAKAIYEQEAIgANACACQQhqEC0MAQsLIAJBEGokACAAC2oBAX8jAEEQayICJAAgAiAAQQRqIgAQKjYCCCACIAAQKzYCAANAAkAgAkEIaiACECxFBEBBACEADAELIAIoAggoAgAiACABIAAoAgAoAhQRAQAiAA0AIAJBCGoQLQwBCwsgAkEQaiQAIAALCQAgABC5AhAyCyAAIAFB+gBGBEAgACACEDc2AhhBAQ8LIAAgASACELgBCxMAQQEhACABQR1GIAFBMkZyRUULBABBMgsOACABIAIgACgCGBCFBAsiAQF+IAEgAq0gA61CIIaEIAQgABEoACIFQiCIpxAWIAWnCxMAIAEgAiADIAQgBSAGIAARIAALEQAgASACIAMgBCAFIAARFAALBwAgABEJAAsNACABIAIgAyAAERYACxEAIAEgAiADIAQgBSAAERsACw0AIAEgAiADIAARHgALDgAgASACIAAoAhgQhQQLEwAgASACIAMgBCAFIAYgABEcAAsXACABIAIgAyAEIAUgBiAHIAggABEdAAsTACABIAIgAyAEIAUgBiAAERAACw8AIAEgAiADIAQgABELAAsLACABIAIgABEXAAsPACABIAIgAyAEIAAREwALDQAgASACIAMgABERAAsLACABIAIgABEKAAsLACABIAIgABEfAAsLACABIAIgABESAAsRACABIAIgAyAEIAUgABENAAsVACABIAIgAyAEIAUgBiAHIAARDAALDQAgASACIAMgABEIAAsNACABIAIgAyAAEQUACwkAIAEgABEHAAsLACABIAIgABEDAAsTACABIAIgAyAEIAUgBiAAERUACw8AIAEgAiADIAQgABEOAAsHACAAEQYACw0AIAEgAiADIAARBAALBwAgACoCOAsLACABIAIgABEBAAsJACABIAARAAALCQAgASAAEQIAC1kBAX8gACAALQBKIgFBf2ogAXI6AEogACgCACIBQQhxBEAgACABQSByNgIAQX8PCyAAQgA3AgQgACAAKAIsIgE2AhwgACABNgIUIAAgASAAKAIwajYCEEEACwcAIAAqAjQLiQQCAn8EfgJAIAG9IgZCAYYiBVAgBkL///////////8Ag0KAgICAgICA+P8AVnJFBEAgAL0iB0I0iKdB/w9xIgJB/w9HDQELIAAgAaIiACAAow8LIAdCAYYiBCAFVgRAIAZCNIinQf8PcSEDAn4gAkUEQEEAIQIgB0IMhiIEQgBZBEADQCACQX9qIQIgBEIBhiIEQn9VDQALCyAHQQEgAmuthgwBCyAHQv////////8Hg0KAgICAgICACIQLIQQCfiADRQRAQQAhAyAGQgyGIgVCAFkEQANAIANBf2ohAyAFQgGGIgVCf1UNAAsLIAZBASADa62GDAELIAZC/////////weDQoCAgICAgIAIhAshBiACIANKBEADQAJAIAQgBn0iBUIAUw0AIAUiBEIAUg0AIABEAAAAAAAAAACiDwsgBEIBhiEEIAJBf2oiAiADSg0ACyADIQILAkAgBCAGfSIFQgBTDQAgBSIEQgBSDQAgAEQAAAAAAAAAAKIPCwJAIARC/////////wdWBEAgBCEFDAELA0AgAkF/aiECIARCgICAgICAgARUIQMgBEIBhiIFIQQgAw0ACwsgB0KAgICAgICAgIB/gyEEIAJBAU4EfiAFQoCAgICAgIB4fCACrUI0hoQFIAVBASACa62ICyAEhL8PCyAARAAAAAAAAAAAoiAAIAQgBVEbCzIAIAC8Qf////8HcUGAgID8B00EQCAAIAAgAZcgAbxB/////wdxQYCAgPwHSxsPCyABCzIAIAC8Qf////8HcUGAgID8B00EQCAAIAAgAZYgAbxB/////wdxQYCAgPwHSxsPCyABCwcAIAAqAjALAwAACzIBAX8jAEEQayIBJAAgAUEIaiAAKAIEEEEoAgBBAToAACAAKAIIQQE6AAAgAUEQaiQACy4BAX8CQCAAKAIIIgAtAAAiAUEBRwR/IAFBAnENASAAQQI6AABBAQVBAAsPCwALMwECfyMAQRBrIgEkACABQQhqIAAoAgQQQSgCAC0AAEUEQCAAEPgIIQILIAFBEGokACACCyQAIABBC08EfyAAQRBqQXBxIgAgAEF/aiIAIABBC0YbBUEKCwtFAQF/IwBBEGsiAiQAAkAgARCYAUUEQCAAIAEoAgg2AgggACABKQIANwIADAELIAAgASgCACABKAIEELwCCyACQRBqJAALbwECfyMAQRBrIgMkACABIABrQQJ1IQEDQCABBEAgAyAANgIMIAMgAygCDCABQQF2IgRBAnRqNgIMIAMoAgwgAhD+AQR/IAMgAygCDEEEaiIANgIMIAEgBEF/c2oFIAQLIQEMAQsLIANBEGokACAACyEBAX8jAEEQayIDJAAgACABIAIQ/AghACADQRBqJAAgAAtQAQF+AkAgA0HAAHEEQCABIANBQGqthiECQgAhAQwBCyADRQ0AIAIgA60iBIYgAUHAACADa62IhCECIAEgBIYhAQsgACABNwMAIAAgAjcDCAvZAwICfwJ+IwBBIGsiAiQAAkAgAUL///////////8AgyIFQoCAgICAgMD/Q3wgBUKAgICAgIDAgLx/fFQEQCABQgSGIABCPIiEIQQgAEL//////////w+DIgBCgYCAgICAgIAIWgRAIARCgYCAgICAgIDAAHwhBAwCCyAEQoCAgICAgICAQH0hBCAAQoCAgICAgICACIVCAFINASAEQgGDIAR8IQQMAQsgAFAgBUKAgICAgIDA//8AVCAFQoCAgICAgMD//wBRG0UEQCABQgSGIABCPIiEQv////////8Dg0KAgICAgICA/P8AhCEEDAELQoCAgICAgID4/wAhBCAFQv///////7//wwBWDQBCACEEIAVCMIinIgNBkfcASQ0AIAJBEGogACABQv///////z+DQoCAgICAgMAAhCIEIANB/4h/ahD+CCACIAAgBEGB+AAgA2sQgAkgAikDCEIEhiACKQMAIgBCPIiEIQQgAikDECACKQMYhEIAUq0gAEL//////////w+DhCIAQoGAgICAgICACFoEQCAEQgF8IQQMAQsg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aiQACygBAX8jAEEQayICJAAgAiABNgIMIAAoAgggAkEMahDmCSACQRBqJAALNAEBfyMAQRBrIgMkACADIAI2AgggAyABNgIMIAAoAgggA0EMaiADQQhqEOkJIANBEGokAAsMACAAKAIIIAEQ7AkLCgAgAEGH7gAQeAsKACAAQYLuABB4CwcAIAAqAhgLDAAgABCpBBogABAyCy0AIABBADYCACAAQaj7ADYCACAAQQRqELcBIABBhPsANgIAIABBCGogARDCAgs9AQF/IAAoAgQiBkEBdSABaiEBIAAoAgAhACABIAIgAyAEIAUgBkEBcQR/IAEoAgAgAGooAgAFIAALEQ0ACxAAIAEgAiADIAAqAhgQqAQLKQEBfyMAQRBrIgIkACACIAA2AgwgAkEMaiABEKsEEHkgAkEQaiQAIAALTAECfwJAQZCvAS0AAEEBcQ0AQZCvARBNRQ0AIwBBEGsiACQAQQJBiPkAEAMhASAAQRBqJABBjK8BIAE2AgBBkK8BEEwLQYyvASgCAAspACAAKAIAIAEoAgA2AgAgACgCACABKAIENgIEIAAgACgCAEEIajYCAAslAANAIAEgACgCCEcEQCAAKAIQGiAAIAAoAghBf2o2AggMAQsLCyYAIAAoAgAaIAAoAgAgABCOAWoaIAAoAgAgABCOAWoaIAAoAgAaCygBAX8gACABKAIANgIAIAEoAgAhAyAAIAE2AgggACACIANqNgIEIAALPwEBfyMAQRBrIgEkACAAEC8aIAFBfzYCDCABQf////8HNgIIIAFBDGogAUEIahDBASgCACEAIAFBEGokACAACyUAIAAoAgAaIAAoAgAgABCOAWoaIAAoAgAaIAAoAgAgABBvahoLUAEBfyAAENACIAAQLyAAKAIAIAAoAgQgAUEEaiICEMcBIAAgAhA2IABBBGogAUEIahA2IAAQLyABEDUQNiABIAEoAgQ2AgAgACAAEG8Q/QkLWQECfyMAQRBrIgIkACACIABBCGogARD+CSIBKAIAIQMDQCABKAIEIANHBEAgACgCEBogASgCABC3ASABIAEoAgBBAWoiAzYCAAwBCwsgARDQASACQRBqJAALbgECfyMAQRBrIgQkACAEQQA2AgwgAEEMaiAEQQxqIAMQnwEgAQRAIAAoAhAaQX8gAUkEQBBiAAsgARApIQULIAAgBTYC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QRAQKSACEMcHIQAgAkEQaiQAIAALCgAgAEH0AGoQOQs+AQF/IwBBEGsiASQAIAEgACkCADcDCEG6sAFB6fMAQQNBuIMBQfz7AEGgByABQQhqEDRBABAAIAFBEGokAAs+AQF/IwBBEGsiASQAIAEgACkCADcDCEG6sAFB1fMAQQNBrIMBQfz7AEGfByABQQhqEDRBABAAIAFBEGokAAsKACAAQegAahA5CzcAAkACQAJAAkAgAUFbag4CAQIACyABQdgARw0CIAAgAhCtBA8LIAAgAhDFAg8LIAAgAhDFAgsLPgEBfyMAQRBrIgEkACABIAApAgA3AwhBurABQbbzAEEDQZiDAUH8+wBBnQcgAUEIahA0QQAQACABQRBqJAALPgEBfyMAQRBrIgEkACABIAApAgA3AwhBurABQaXzAEEDQYyDAUH8+wBBnAcgAUEIahA0QQAQACABQRBqJAALPgEBfyMAQRBrIgEkACABIAApAgA3AwhBurABQZzzAEEDQYCDAUH8+wBBmwcgAUEIahA0QQAQACABQRBqJAALfQEBfyMAQRBrIgIkACACIABB3ABqIgAQKjYCCCACIAAQKzYCAANAAkAgAkEIaiACECxFBEBBACEADAELAkAgAigCCCgCACIARQ0AIABBKSAAKAIAKAIMEQEARQ0AIAAQQiABEIgBDQELIAJBCGoQLQwBCwsgAkEQaiQAIAALPgEBfyMAQRBrIgEkACABIAApAgA3AwhBurABQZfzAEEDQfSCAUH8+wBBmgcgAUEIahA0QQAQACABQRBqJAALcwEBfyMAQRBrIgIkACACIABB3ABqIgAQKjYCCCACIAAQKzYCAANAAkAgAkEIaiACECxFBEBBACEADAELAkAgAigCCCgCACIARQ0AIAAQsQJFDQAgABBCIAEQiAENAQsgAkEIahAtDAELCyACQRBqJAAgAAs+AQF/IwBBEGsiASQAIAEgACkCADcDCEG6sAFBkvMAQQNB6IIBQfz7AEGZByABQQhqEDRBABAAIAFBEGokAAtzAQF/IwBBEGsiAiQAIAIgAEHcAGoiABAqNgIIIAIgABArNgIAA0ACQCACQQhqIAIQLEUEQEEAIQAMAQsCQCACKAIIKAIAIgBFDQAgABCqAkUNACAAEEIgARCIAQ0BCyACQQhqEC0MAQsLIAJBEGokACAACz4B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AKkBAACqAQAAqwEAAKwBAABk////AAAAAK0BAEGELwuGAa4BAACvAQAAsAEAALEBAACyAQAAQQEAAEIBAACuAAAArwAAALAAAABDAQAARAEAALMBAAC0AAAAtQAAALYAAAC3AAAAuAAAAEYBAABHAQAASAEAAEkBAABKAQAASwEAAEwBAABNAQAATgEAAE8BAABQAQAAUQEAALQBAAC1AQAAtgEAALcBAEGUMAt+UgEAALgBAACwAQAAsQEAALIBAABBAQAAQgEAAK4AAACvAAAAsAAAAEMBAABEAQAAVAEAALQAAAC1AAAAtgAAALcAAAC4AAAARgEAAEcBAABIAQAASQEAAEoBAABLAQAATAEAAE0BAABOAQAATwEAAFABAABRAQAAuQEAALoBAEGcMQt6uwEAALwBAAC9AQAAvgEAAL8BAABBAQAAQgEAAK4AAACvAAAAsAAAAEMBAABEAQAAwAEAALQAAAC1AAAAtgAAALcAAAC4AAAARgEAAEcBAABIAQAASQEAAEoBAABLAQAATAEAAE0BAABOAQAATwEAAFABAABRAQAAwQEAQaAyC3pSAQAAwgEAAL0BAAC+AQAAvwEAAEEBAABCAQAArgAAAK8AAACwAAAAQwEAAEQBAABUAQAAtAAAALUAAAC2AAAAtwAAALgAAABGAQAARwEAAEgBAABJAQAASgEAAEsBAABMAQAATQEAAE4BAABPAQAAUAEAAFEBAADDAQBBpDMLYsQBAADFAQAAxgEAAMcBAADIAQAAyQEAAGABAACuAAAArwAAALAAAADKAQAAsgAAAMsBAAC0AAAAtQAAALYAAAC3AAAAuAAAAEYBAABHAQAASAEAAEkBAADMAQAAzQEAAM4BAEGQNAthzwEAANABAADGAQAAxwEAAMgBAACsAAAAYAEAAK4AAACvAAAAsAAAALEAAACyAAAAswAAALQAAAC1AAAAtgAAALcAAAC4AAAARgEAAEcBAABIAQAASQEAAMwBAADNAQAAKQBB/DQLYc8BAADRAQAA0gEAANMBAADIAQAArAAAAGABAACuAAAArwAAALAAAACxAAAAsgAAALMAAAC0AAAAtQAAALYAAAC3AAAAuAAAAEYBAABHAQAASAEAAEkBAADMAQAAzQEAACkAQeg1C6MB2QAAANQBAADSAQAA0wEAAMgBAACsAAAAYAEA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QYzbAAtN2QAAAJUCAACWAgAAlwIAAGoBAACsAAAAYAEAAK4AAACvAAAAsAAAALEAAACyAAAAswAAALQAAAC1AAAAtgAAALcAAAC4AAAAKQAAACkAQeTbAAtN2QAAAJgCAACWAgAAlwIAAGoBAACsAAAAYAEAAK4AAACvAAAAsAAAALEAAACyAAAAswAAALQAAAC1AAAAtgAAALcAAAC4AAAAKQAAACkAQbzcAAtapwAAAJkCAADCAAAAwwAAAMQAAACsAAAArQAAAK4AAACvAAAAsAAAALEAAACyAAAAswAAALQAAAC1AAAAtgAAALcAAAC4AAAAxgAAAMcAAAC7AAAAmgIAAJsCAEGg3QALSdkAAACcAgAAzAAAAM0AAADOAAAArAAAACkAAACuAAAArwAAALAAAADgAAAAsgAAAOEAAADTAAAA1AAAANUAAADWAAAA1wAAANgAQfTdAAtN2QAAAJ0CAADbAAAA3AAAAN0AAACsAAAAKQAAAK4AAACvAAAAsAAAAOAAAACyAAAA4QAAAOIAAADjAAAA5AAAAOUAAADmAAAA5wAAAOgAQczeAAtK2QAAAJ4CAACfAgAAoAIAAKECAADtAAAA7gAAAK4AAACvAAAAsAAAAOAAAACyAAAA4QAAAO8AAADwAAAAogIAAKMCAACkAgAApQIAQaDfAAvZAdkAAACmAgAAnwIAAKACAAChAgAA7QAAAO4AAACuAAAArwAAALAAAADgAAAAsgAAAOEAAADvAAAA8AAAAKICAACjAgAApAIAAKUCAAABAAAAAAAAAP////8CAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAD/////AgAAAAIAAAD/////AAAAAAIAAAACAAAAAgAAAP////////////////////8CAAAAAAAAAAIAAAACAAAAAgAAAP////8DAAAAAwAAAAIAQYThAAsVAgAAAP///////////////wIAAAACAEGs4QALDf////8AAAAA/////wEAQcThAAsBAgBB2OEACw0CAAAAAgAAAAIAAAACAEH04QALVQIAAAD//////////////////////////////////////////wIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAMAAAACAAAAAgAAAAIAQdziAAsVAgAAAAIAAAACAAAAAgAAAAIAAAACAEH84gALFQIAAAACAAAAAgAAAAIAAAACAAAAAgBBpOMACxQCAAAAAgAAAAIAAAAAAAAA/////wBByOMACxECAAAAAgAAAAAAAAACAAAAAgBB5OMAC5gB//////////////////////////////////////////8BAAAA/////wIAAAAAAAAA/////////////////////////////////////wAAAAD/////AAAAAAAAAAD//////////wAAAAAAAAAAAgAAAAAAAAD/////AAAAAAAAgL8AAIC/AAAAAAAAgL8AAIA/AACAvwAAgL8AQYrlAAt8gD8AAAAAAACAvwAAgD8AAAAAAACAPwAAgD8AAIA/AAAAAAAAAADZAAAApwIAAGIBAABjAQAAZAEAAKwAAABgAQAArgAAAK8AAACwAAAAsQAAALIAAACzAAAAtAAAALUAAAC2AAAAtwAAALgAAABGAQAARwEAAEgBAABJAQBBkOYAC03ZAAAAqAIAAGgBAABpAQAAagEAAKwAAABgAQAArgAAAK8AAACwAAAAsQAAALIAAACzAAAAtAAAALUAAAC2AAAAtwAAALgAAAApAAAAKQBB6OYAC0ZfAgAAqQIAAHsCAAB8AgAAfQIAAKwAAABkAgAArgAAAK8AAACwAAAA4AAAALIAAADhAAAAZQIAAKoCAACrAgAArAIAAH4CAEG45wALOtkAAACtAgAAdQIAAHYCAAB3AgAArgIAAK8CAACuAAAArwAAALAAAADgAAAAsgAAAOEAAACwAgAAsQIAQfznAAufAU8CAACzAgAARwIAAEgCAABJAgAAUwIAAFQCAACuAAAArwAAALAAAABVAgAAsgAAAFYCAABXAgAAWAIAAFkCAABaAgAAWwIAAFwCAABdAgAAvP///wAAAABeAgAAYWxsb2NhdG9yPFQ+OjphbGxvY2F0ZShzaXplX3QgbikgJ24nIGV4Y2VlZHMgbWF4aW11bSBzdXBwb3J0ZWQgc2l6ZQBBpOkAC1pPAgAAtAIAAFECAABSAgAASQIAAFMCAAC1AgAArgAAAK8AAACwAAAAVQIAALIAAABWAgAAVwIAAFgCAABZAgAAWgIAAFsCAABcAgAAtgIAALz///8AAAAAXgIAQYjqAAtBXwIAALcCAABsAgAAbQIAAG4CAACsAAAAZAIAAK4AAACvAAAAsAAAAOAAAACyAAAA4QAAAGUCAABmAgAAKQAAACkAQdTqAAtG2QAAALgCAABwAgAAcQIAAHICAAC5AgAAugIAAK4AAACvAAAAsAAAAOAAAACyAAAA4QAAALsCAAC8AgAAzP///wAAAAC9AgBBpOsAC1JfAgAAvgIAAGECAABiAgAAYwIAAKwAAABkAgAArgAAAK8AAACwAAAA4AAAALIAAADhAAAAZQIAAL8CAADAAgAAwQIAAMICAADDAgAAxAIAAGoCAEGA7AALWsUCAADGAgAAxwIAAMgCAADJAgAArAAAAMoCAACuAAAArwAAALAAAADgAAAAsgAAAOEAAADLAgAAzAIAAM0CAADOAgAAzwIAANACAADA////AAAAANECAADSAgBB5OwAC0LZAAAA0wIAAMcCAADIAgAAyQIAAKwAAAApAAAArgAAAK8AAACwAAAA4AAAALIAAADhAAAA1AIAANUCAADWAgAA1wIAQbDtAAuQDCkAAAApAAAAcmVuZGVyRmFjdG9yeQBtYWtlUmVuZGVyUGFpbnQAbWFrZVJlbmRlclBhdGgAYnl0ZUxlbmd0aABzZXQAbG9hZABSZW5kZXJlcgBzYXZlAHJlc3RvcmUAdHJhbnNmb3JtAGRyYXdQYXRoAGNsaXBQYXRoAGFsaWduAFJlbmRlcmVyV3JhcHBlcgBSZW5kZXJQYXRoAHJlc2V0AGFkZFBhdGgAZmlsbFJ1bGUAbW92ZVRvAGxpbmVUbwBjdWJpY1RvAGNsb3NlAFJlbmRlclBhdGhXcmFwcGVyAFJlbmRlclBhaW50U3R5bGUAZmlsbABzdHJva2UARmlsbFJ1bGUAbm9uWmVybwBldmVuT2RkAFN0cm9rZUNhcABidXR0AHJvdW5kAHNxdWFyZQBTdHJva2VKb2luAG1pdGVyAGJldmVsAEJsZW5kTW9kZQBzcmNPdmVyAHNjcmVlbgBvdmVybGF5AGRhcmtlbgBsaWdodGVuAGNvbG9yRG9kZ2UAY29sb3JCdXJuAGhhcmRMaWdodABzb2Z0TGlnaHQAZGlmZmVyZW5jZQBleGNsdXNpb24AbXVsdGlwbHkAaHVlAHNhdHVyYXRpb24AY29sb3IAbHVtaW5vc2l0eQBSZW5kZXJQYWludABzdHlsZQB0aGlja25lc3MAam9pbgBjYXAAYmxlbmRNb2RlAGxpbmVhckdyYWRpZW50AHJhZGlhbEdyYWRpZW50AGFkZFN0b3AAY29tcGxldGVHcmFkaWVudABSZW5kZXJQYWludFdyYXBwZXIATWF0MkQAeHgAeHkAeXgAeXkAdHgAdHkARmlsZQBkZWZhdWx0QXJ0Ym9hcmQAYXJ0Ym9hcmRCeU5hbWUAYXJ0Ym9hcmRCeUluZGV4AGFydGJvYXJkQ291bnQAQXJ0Ym9hcmQAbmFtZQBhZHZhbmNlAGRyYXcAdHJhbnNmb3JtQ29tcG9uZW50AG5vZGUAYm9uZQByb290Qm9uZQBhbmltYXRpb25CeUluZGV4AGFuaW1hdGlvbkJ5TmFtZQBhbmltYXRpb25Db3VudABzdGF0ZU1hY2hpbmVCeUluZGV4AHN0YXRlTWFjaGluZUJ5TmFtZQBzdGF0ZU1hY2hpbmVDb3VudABib3VuZHMAVHJhbnNmb3JtQ29tcG9uZW50AHNjYWxlWABzY2FsZVkAcm90YXRpb24ATm9kZQB4AHkAQm9uZQBsZW5ndGgAUm9vdEJvbmUAQW5pbWF0aW9uAExpbmVhckFuaW1hdGlvbgBkdXJhdGlvbgBmcHMAd29ya1N0YXJ0AHdvcmtFbmQAZW5hYmxlV29ya0FyZWEAbG9vcFZhbHVlAHNwZWVkAGFwcGx5AExpbmVhckFuaW1hdGlvbkluc3RhbmNlAHRpbWUAZGlkTG9vcABTdGF0ZU1hY2hpbmUAU3RhdGVNYWNoaW5lSW5zdGFuY2UAaW5wdXRDb3VudABpbnB1dABTTUlJbnB1dAB0eXBlAGJvb2wAOwBudW1iZXIAADgAdHJpZ2dlcgA6AGFzQm9vbABhc051bWJlcgBhc1RyaWdnZXIAU01JQm9vbAB2YWx1ZQBTTUlOdW1iZXIAU01JVHJpZ2dlcgBmaXJlAEZpdABjb250YWluAGNvdmVyAGZpdFdpZHRoAGZpdEhlaWdodABub25lAHNjYWxlRG93bgBBbGlnbm1lbnQAdG9wTGVmdAB0b3BDZW50ZXIAdG9wUmlnaHQAY2VudGVyTGVmdABjZW50ZXIAY2VudGVyUmlnaHQAYm90dG9tTGVmdABib3R0b21DZW50ZXIAYm90dG9tUmlnaHQAQUFCQgBtaW5Y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aGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxzaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8bG9uZz4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgbG9uZz4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGZsb2F0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxkb3VibGU+AAADAAAABAAAAAQAAAAGAAAAg/miAERObgD8KRUA0VcnAN009QBi28AAPJmVAEGQQwBjUf4Au96rALdhxQA6biQA0k1CAEkG4AAJ6i4AHJLRAOsd/gApsRwA6D6nAPU1ggBEuy4AnOmEALQmcABBfl8A1pE5AFODOQCc9DkAi1+EACj5vQD4HzsA3v+XAA+YBQARL+8AClqLAG0fbQDPfjYACcsnAEZPtwCeZj8ALepfALondQDl68cAPXvxAPc5BwCSUooA+2vqAB+xXwAIXY0AMANWAHv8RgDwq2sAILzPADb0mgDjqR0AXmGRAAgb5gCFmWUAoBRfAI1AaACA2P8AJ3NNAAYGMQDKVhUAyahzAHviYABrjMAAGcRHAM1nwwAJ6NwAWYMqAIt2xACmHJYARK/dABlX0QClPgUABQf/ADN+PwDCMugAmE/eALt9MgAmPcMAHmvvAJ/4XgA1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";

if (!isDataURI(wasmBinaryFile)) {
 wasmBinaryFile = locateFile(wasmBinaryFile);
}

function getBinary() {
 try {
  if (wasmBinary) {
   return new Uint8Array(wasmBinary);
  }
  var binary = tryParseAsDataURI(wasmBinaryFile);
  if (binary) {
   return binary;
  }
  if (readBinary) {
   return readBinary(wasmBinaryFile);
  } else {
   throw "both async and sync fetching of the wasm failed";
  }
 } catch (err) {
  abort(err);
 }
}

function getBinaryPromise() {
 if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === "function" && !isFileURI(wasmBinaryFile)) {
  return fetch(wasmBinaryFile, {
   credentials: "same-origin"
  }).then(function(response) {
   if (!response["ok"]) {
    throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
   }
   return response["arrayBuffer"]();
  }).catch(function() {
   return getBinary();
  });
 }
 return Promise.resolve().then(getBinary);
}

function createWasm() {
 var info = {
  "a": asmLibraryArg
 };
 function receiveInstance(instance, module) {
  var exports = instance.exports;
  Module["asm"] = exports;
  removeRunDependency("wasm-instantiate");
 }
 addRunDependency("wasm-instantiate");
 function receiveInstantiatedSource(output) {
  receiveInstance(output["instance"]);
 }
 function instantiateArrayBuffer(receiver) {
  return getBinaryPromise().then(function(binary) {
   return WebAssembly.instantiate(binary, info);
  }).then(receiver, function(reason) {
   err("failed to asynchronously prepare wasm: " + reason);
   abort(reason);
  });
 }
 function instantiateAsync() {
  if (!wasmBinary && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && typeof fetch === "function") {
   fetch(wasmBinaryFile, {
    credentials: "same-origin"
   }).then(function(response) {
    var result = WebAssembly.instantiateStreaming(response, info);
    return result.then(receiveInstantiatedSource, function(reason) {
     err("wasm streaming compile failed: " + reason);
     err("falling back to ArrayBuffer instantiation");
     return instantiateArrayBuffer(receiveInstantiatedSource);
    });
   });
  } else {
   return instantiateArrayBuffer(receiveInstantiatedSource);
  }
 }
 if (Module["instantiateWasm"]) {
  try {
   var exports = Module["instantiateWasm"](info, receiveInstance);
   return exports;
  } catch (e) {
   err("Module.instantiateWasm callback failed with error: " + e);
   return false;
  }
 }
 instantiateAsync();
 return {};
}

__ATINIT__.push({
 func: function() {
  ___wasm_call_ctors();
 }
});

var char_0 = 48;

var char_9 = 57;

function makeLegalFunctionName(name) {
 if (undefined === name) {
  return "_unknown";
 }
 name = name.replace(/[^a-zA-Z0-9_]/g, "$");
 var f = name.charCodeAt(0);
 if (f >= char_0 && f <= char_9) {
  return "_" + name;
 } else {
  return name;
 }
}

function createNamedFunction(name, body) {
 name = makeLegalFunctionName(name);
 return new Function("body", "return function " + name + "() {\n" + '    "use strict";' + "    return body.apply(this, arguments);\n" + "};\n")(body);
}

var emval_free_list = [];

var emval_handle_array = [ {}, {
 value: undefined
}, {
 value: null
}, {
 value: true
}, {
 value: false
} ];

function count_emval_handles() {
 var count = 0;
 for (var i = 5; i < emval_handle_array.length; ++i) {
  if (emval_handle_array[i] !== undefined) {
   ++count;
  }
 }
 return count;
}

function get_first_emval() {
 for (var i = 5; i < emval_handle_array.length; ++i) {
  if (emval_handle_array[i] !== undefined) {
   return emval_handle_array[i];
  }
 }
 return null;
}

function init_emval() {
 Module["count_emval_handles"] = count_emval_handles;
 Module["get_first_emval"] = get_first_emval;
}

function __emval_register(value) {
 switch (value) {
 case undefined:
  {
   return 1;
  }

 case null:
  {
   return 2;
  }

 case true:
  {
   return 3;
  }

 case false:
  {
   return 4;
  }

 default:
  {
   var handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;
   emval_handle_array[handle] = {
    refcount: 1,
    value: value
   };
   return handle;
  }
 }
}

function extendError(baseErrorType, errorName) {
 var errorClass = createNamedFunction(errorName, function(message) {
  this.name = errorName;
  this.message = message;
  var stack = new Error(message).stack;
  if (stack !== undefined) {
   this.stack = this.toString() + "\n" + stack.replace(/^Error(:[^\n]*)?\n/, "");
  }
 });
 errorClass.prototype = Object.create(baseErrorType.prototype);
 errorClass.prototype.constructor = errorClass;
 errorClass.prototype.toString = function() {
  if (this.message === undefined) {
   return this.name;
  } else {
   return this.name + ": " + this.message;
  }
 };
 return errorClass;
}

var PureVirtualError = undefined;

function embind_init_charCodes() {
 var codes = new Array(256);
 for (var i = 0; i < 256; ++i) {
  codes[i] = String.fromCharCode(i);
 }
 embind_charCodes = codes;
}

var embind_charCodes = undefined;

function readLatin1String(ptr) {
 var ret = "";
 var c = ptr;
 while (HEAPU8[c]) {
  ret += embind_charCodes[HEAPU8[c++]];
 }
 return ret;
}

function getInheritedInstanceCount() {
 return Object.keys(registeredInstances).length;
}

function getLiveInheritedInstances() {
 var rv = [];
 for (var k in registeredInstances) {
  if (registeredInstances.hasOwnProperty(k)) {
   rv.push(registeredInstances[k]);
  }
 }
 return rv;
}

var deletionQueue = [];

function flushPendingDeletes() {
 while (deletionQueue.length) {
  var obj = deletionQueue.pop();
  obj.$$.deleteScheduled = false;
  obj["delete"]();
 }
}

var delayFunction = undefined;

function setDelayFunction(fn) {
 delayFunction = fn;
 if (deletionQueue.length && delayFunction) {
  delayFunction(flushPendingDeletes);
 }
}

function init_embind() {
 Module["getInheritedInstanceCount"] = getInheritedInstanceCount;
 Module["getLiveInheritedInstances"] = getLiveInheritedInstances;
 Module["flushPendingDeletes"] = flushPendingDeletes;
 Module["setDelayFunction"] = setDelayFunction;
}

var registeredInstances = {};

var BindingError = undefined;

function throwBindingError(message) {
 throw new BindingError(message);
}

function getBasestPointer(class_, ptr) {
 if (ptr === undefined) {
  throwBindingError("ptr should not be undefined");
 }
 while (class_.baseClass) {
  ptr = class_.upcast(ptr);
  class_ = class_.baseClass;
 }
 return ptr;
}

function registerInheritedInstance(class_, ptr, instance) {
 ptr = getBasestPointer(class_, ptr);
 if (registeredInstances.hasOwnProperty(ptr)) {
  throwBindingError("Tried to register registered instance: " + ptr);
 } else {
  registeredInstances[ptr] = instance;
 }
}

function requireHandle(handle) {
 if (!handle) {
  throwBindingError("Cannot use deleted val. handle = " + handle);
 }
 return emval_handle_array[handle].value;
}

var registeredTypes = {};

function getTypeName(type) {
 var ptr = ___getTypeName(type);
 var rv = readLatin1String(ptr);
 _free(ptr);
 return rv;
}

function requireRegisteredType(rawType, humanName) {
 var impl = registeredTypes[rawType];
 if (undefined === impl) {
  throwBindingError(humanName + " has unknown type " + getTypeName(rawType));
 }
 return impl;
}

function unregisterInheritedInstance(class_, ptr) {
 ptr = getBasestPointer(class_, ptr);
 if (registeredInstances.hasOwnProperty(ptr)) {
  delete registeredInstances[ptr];
 } else {
  throwBindingError("Tried to unregister unregistered instance: " + ptr);
 }
}

function detachFinalizer(handle) {}

var finalizationGroup = false;

function runDestructor($$) {
 if ($$.smartPtr) {
  $$.smartPtrType.rawDestructor($$.smartPtr);
 } else {
  $$.ptrType.registeredClass.rawDestructor($$.ptr);
 }
}

function releaseClassHandle($$) {
 $$.count.value -= 1;
 var toDelete = 0 === $$.count.value;
 if (toDelete) {
  runDestructor($$);
 }
}

function attachFinalizer(handle) {
 if ("undefined" === typeof FinalizationGroup) {
  attachFinalizer = function(handle) {
   return handle;
  };
  return handle;
 }
 finalizationGroup = new FinalizationGroup(function(iter) {
  for (var result = iter.next(); !result.done; result = iter.next()) {
   var $$ = result.value;
   if (!$$.ptr) {
    console.warn("object already deleted: " + $$.ptr);
   } else {
    releaseClassHandle($$);
   }
  }
 });
 attachFinalizer = function(handle) {
  finalizationGroup.register(handle, handle.$$, handle.$$);
  return handle;
 };
 detachFinalizer = function(handle) {
  finalizationGroup.unregister(handle.$$);
 };
 return attachFinalizer(handle);
}

function __embind_create_inheriting_constructor(constructorName, wrapperType, properties) {
 constructorName = readLatin1String(constructorName);
 wrapperType = requireRegisteredType(wrapperType, "wrapper");
 properties = requireHandle(properties);
 var arraySlice = [].slice;
 var registeredClass = wrapperType.registeredClass;
 var wrapperPrototype = registeredClass.instancePrototype;
 var baseClass = registeredClass.baseClass;
 var baseClassPrototype = baseClass.instancePrototype;
 var baseConstructor = registeredClass.baseClass.constructor;
 var ctor = createNamedFunction(constructorName, function() {
  registeredClass.baseClass.pureVirtualFunctions.forEach(function(name) {
   if (this[name] === baseClassPrototype[name]) {
    throw new PureVirtualError("Pure virtual function " + name + " must be implemented in JavaScript");
   }
  }.bind(this));
  Object.defineProperty(this, "__parent", {
   value: wrapperPrototype
  });
  this["__construct"].apply(this, arraySlice.call(arguments));
 });
 wrapperPrototype["__construct"] = function __construct() {
  if (this === wrapperPrototype) {
   throwBindingError("Pass correct 'this' to __construct");
  }
  var inner = baseConstructor["implement"].apply(undefined, [ this ].concat(arraySlice.call(arguments)));
  detachFinalizer(inner);
  var $$ = inner.$$;
  inner["notifyOnDestruction"]();
  $$.preservePointerOnDelete = true;
  Object.defineProperties(this, {
   $$: {
    value: $$
   }
  });
  attachFinalizer(this);
  registerInheritedInstance(registeredClass, $$.ptr, this);
 };
 wrapperPrototype["__destruct"] = function __destruct() {
  if (this === wrapperPrototype) {
   throwBindingError("Pass correct 'this' to __destruct");
  }
  detachFinalizer(this);
  unregisterInheritedInstance(registeredClass, this.$$.ptr);
 };
 ctor.prototype = Object.create(wrapperPrototype);
 for (var p in properties) {
  ctor.prototype[p] = properties[p];
 }
 return __emval_register(ctor);
}

var structRegistrations = {};

function runDestructors(destructors) {
 while (destructors.length) {
  var ptr = destructors.pop();
  var del = destructors.pop();
  del(ptr);
 }
}

function simpleReadValueFromPointer(pointer) {
 return this["fromWireType"](HEAPU32[pointer >> 2]);
}

var awaitingDependencies = {};

var typeDependencies = {};

var InternalError = undefined;

function throwInternalError(message) {
 throw new InternalError(message);
}

function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {
 myTypes.forEach(function(type) {
  typeDependencies[type] = dependentTypes;
 });
 function onComplete(typeConverters) {
  var myTypeConverters = getTypeConverters(typeConverters);
  if (myTypeConverters.length !== myTypes.length) {
   throwInternalError("Mismatched type converter count");
  }
  for (var i = 0; i < myTypes.length; ++i) {
   registerType(myTypes[i], myTypeConverters[i]);
  }
 }
 var typeConverters = new Array(dependentTypes.length);
 var unregisteredTypes = [];
 var registered = 0;
 dependentTypes.forEach(function(dt, i) {
  if (registeredTypes.hasOwnProperty(dt)) {
   typeConverters[i] = registeredTypes[dt];
  } else {
   unregisteredTypes.push(dt);
   if (!awaitingDependencies.hasOwnProperty(dt)) {
    awaitingDependencies[dt] = [];
   }
   awaitingDependencies[dt].push(function() {
    typeConverters[i] = registeredTypes[dt];
    ++registered;
    if (registered === unregisteredTypes.length) {
     onComplete(typeConverters);
    }
   });
  }
 });
 if (0 === unregisteredTypes.length) {
  onComplete(typeConverters);
 }
}

function __embind_finalize_value_object(structType) {
 var reg = structRegistrations[structType];
 delete structRegistrations[structType];
 var rawConstructor = reg.rawConstructor;
 var rawDestructor = reg.rawDestructor;
 var fieldRecords = reg.fields;
 var fieldTypes = fieldRecords.map(function(field) {
  return field.getterReturnType;
 }).concat(fieldRecords.map(function(field) {
  return field.setterArgumentType;
 }));
 whenDependentTypesAreResolved([ structType ], fieldTypes, function(fieldTypes) {
  var fields = {};
  fieldRecords.forEach(function(field, i) {
   var fieldName = field.fieldName;
   var getterReturnType = fieldTypes[i];
   var getter = field.getter;
   var getterContext = field.getterContext;
   var setterArgumentType = fieldTypes[i + fieldRecords.length];
   var setter = field.setter;
   var setterContext = field.setterContext;
   fields[fieldName] = {
    read: function(ptr) {
     return getterReturnType["fromWireType"](getter(getterContext, ptr));
    },
    write: function(ptr, o) {
     var destructors = [];
     setter(setterContext, ptr, setterArgumentType["toWireType"](destructors, o));
     runDestructors(destructors);
    }
   };
  });
  return [ {
   name: reg.name,
   "fromWireType": function(ptr) {
    var rv = {};
    for (var i in fields) {
     rv[i] = fields[i].read(ptr);
    }
    rawDestructor(ptr);
    return rv;
   },
   "toWireType": function(destructors, o) {
    for (var fieldName in fields) {
     if (!(fieldName in o)) {
      throw new TypeError('Missing field:  "' + fieldName + '"');
     }
    }
    var ptr = rawConstructor();
    for (fieldName in fields) {
     fields[fieldName].write(ptr, o[fieldName]);
    }
    if (destructors !== null) {
     destructors.push(rawDestructor, ptr);
    }
    return ptr;
   },
   "argPackAdvance": 8,
   "readValueFromPointer": simpleReadValueFromPointer,
   destructorFunction: rawDestructor
  } ];
 });
}

function getShiftFromSize(size) {
 switch (size) {
 case 1:
  return 0;

 case 2:
  return 1;

 case 4:
  return 2;

 case 8:
  return 3;

 default:
  throw new TypeError("Unknown type size: " + size);
 }
}

function registerType(rawType, registeredInstance, options) {
 options = options || {};
 if (!("argPackAdvance" in registeredInstance)) {
  throw new TypeError("registerType registeredInstance requires argPackAdvance");
 }
 var name = registeredInstance.name;
 if (!rawType) {
  throwBindingError('type "' + name + '" must have a positive integer typeid pointer');
 }
 if (registeredTypes.hasOwnProperty(rawType)) {
  if (options.ignoreDuplicateRegistrations) {
   return;
  } else {
   throwBindingError("Cannot register type '" + name + "' twice");
  }
 }
 registeredTypes[rawType] = registeredInstance;
 delete typeDependencies[rawType];
 if (awaitingDependencies.hasOwnProperty(rawType)) {
  var callbacks = awaitingDependencies[rawType];
  delete awaitingDependencies[rawType];
  callbacks.forEach(function(cb) {
   cb();
  });
 }
}

function __embind_register_bool(rawType, name, size, trueValue, falseValue) {
 var shift = getShiftFromSize(size);
 name = readLatin1String(name);
 registerType(rawType, {
  name: name,
  "fromWireType": function(wt) {
   return !!wt;
  },
  "toWireType": function(destructors, o) {
   return o ? trueValue : falseValue;
  },
  "argPackAdvance": 8,
  "readValueFromPointer": function(pointer) {
   var heap;
   if (size === 1) {
    heap = HEAP8;
   } else if (size === 2) {
    heap = HEAP16;
   } else if (size === 4) {
    heap = HEAP32;
   } else {
    throw new TypeError("Unknown boolean type size: " + name);
   }
   return this["fromWireType"](heap[pointer >> shift]);
  },
  destructorFunction: null
 });
}

function ClassHandle_isAliasOf(other) {
 if (!(this instanceof ClassHandle)) {
  return false;
 }
 if (!(other instanceof ClassHandle)) {
  return false;
 }
 var leftClass = this.$$.ptrType.registeredClass;
 var left = this.$$.ptr;
 var rightClass = other.$$.ptrType.registeredClass;
 var right = other.$$.ptr;
 while (leftClass.baseClass) {
  left = leftClass.upcast(left);
  leftClass = leftClass.baseClass;
 }
 while (rightClass.baseClass) {
  right = rightClass.upcast(right);
  rightClass = rightClass.baseClass;
 }
 return leftClass === rightClass && left === right;
}

function shallowCopyInternalPointer(o) {
 return {
  count: o.count,
  deleteScheduled: o.deleteScheduled,
  preservePointerOnDelete: o.preservePointerOnDelete,
  ptr: o.ptr,
  ptrType: o.ptrType,
  smartPtr: o.smartPtr,
  smartPtrType: o.smartPtrType
 };
}

function throwInstanceAlreadyDeleted(obj) {
 function getInstanceTypeName(handle) {
  return handle.$$.ptrType.registeredClass.name;
 }
 throwBindingError(getInstanceTypeName(obj) + " instance already deleted");
}

function ClassHandle_clone() {
 if (!this.$$.ptr) {
  throwInstanceAlreadyDeleted(this);
 }
 if (this.$$.preservePointerOnDelete) {
  this.$$.count.value += 1;
  return this;
 } else {
  var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {
   $$: {
    value: shallowCopyInternalPointer(this.$$)
   }
  }));
  clone.$$.count.value += 1;
  clone.$$.deleteScheduled = false;
  return clone;
 }
}

function ClassHandle_delete() {
 if (!this.$$.ptr) {
  throwInstanceAlreadyDeleted(this);
 }
 if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
  throwBindingError("Object already scheduled for deletion");
 }
 detachFinalizer(this);
 releaseClassHandle(this.$$);
 if (!this.$$.preservePointerOnDelete) {
  this.$$.smartPtr = undefined;
  this.$$.ptr = undefined;
 }
}

function ClassHandle_isDeleted() {
 return !this.$$.ptr;
}

function ClassHandle_deleteLater() {
 if (!this.$$.ptr) {
  throwInstanceAlreadyDeleted(this);
 }
 if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
  throwBindingError("Object already scheduled for deletion");
 }
 deletionQueue.push(this);
 if (deletionQueue.length === 1 && delayFunction) {
  delayFunction(flushPendingDeletes);
 }
 this.$$.deleteScheduled = true;
 return this;
}

function init_ClassHandle() {
 ClassHandle.prototype["isAliasOf"] = ClassHandle_isAliasOf;
 ClassHandle.prototype["clone"] = ClassHandle_clone;
 ClassHandle.prototype["delete"] = ClassHandle_delete;
 ClassHandle.prototype["isDeleted"] = ClassHandle_isDeleted;
 ClassHandle.prototype["deleteLater"] = ClassHandle_deleteLater;
}

function ClassHandle() {}

var registeredPointers = {};

function ensureOverloadTable(proto, methodName, humanName) {
 if (undefined === proto[methodName].overloadTable) {
  var prevFunc = proto[methodName];
  proto[methodName] = function() {
   if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
    throwBindingError("Function '" + humanName + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + proto[methodName].overloadTable + ")!");
   }
   return proto[methodName].overloadTable[arguments.length].apply(this, arguments);
  };
  proto[methodName].overloadTable = [];
  proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
 }
}

function exposePublicSymbol(name, value, numArguments) {
 if (Module.hasOwnProperty(name)) {
  if (undefined === numArguments || undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments]) {
   throwBindingError("Cannot register public name '" + name + "' twice");
  }
  ensureOverloadTable(Module, name, name);
  if (Module.hasOwnProperty(numArguments)) {
   throwBindingError("Cannot register multiple overloads of a function with the same number of arguments (" + numArguments + ")!");
  }
  Module[name].overloadTable[numArguments] = value;
 } else {
  Module[name] = value;
  if (undefined !== numArguments) {
   Module[name].numArguments = numArguments;
  }
 }
}

function RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {
 this.name = name;
 this.constructor = constructor;
 this.instancePrototype = instancePrototype;
 this.rawDestructor = rawDestructor;
 this.baseClass = baseClass;
 this.getActualType = getActualType;
 this.upcast = upcast;
 this.downcast = downcast;
 this.pureVirtualFunctions = [];
}

function upcastPointer(ptr, ptrClass, desiredClass) {
 while (ptrClass !== desiredClass) {
  if (!ptrClass.upcast) {
   throwBindingError("Expected null or instance of " + desiredClass.name + ", got an instance of " + ptrClass.name);
  }
  ptr = ptrClass.upcast(ptr);
  ptrClass = ptrClass.baseClass;
 }
 return ptr;
}

function constNoSmartPtrRawPointerToWireType(destructors, handle) {
 if (handle === null) {
  if (this.isReference) {
   throwBindingError("null is not a valid " + this.name);
  }
  return 0;
 }
 if (!handle.$$) {
  throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
 }
 if (!handle.$$.ptr) {
  throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
 }
 var handleClass = handle.$$.ptrType.registeredClass;
 var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
 return ptr;
}

function genericPointerToWireType(destructors, handle) {
 var ptr;
 if (handle === null) {
  if (this.isReference) {
   throwBindingError("null is not a valid " + this.name);
  }
  if (this.isSmartPointer) {
   ptr = this.rawConstructor();
   if (destructors !== null) {
    destructors.push(this.rawDestructor, ptr);
   }
   return ptr;
  } else {
   return 0;
  }
 }
 if (!handle.$$) {
  throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
 }
 if (!handle.$$.ptr) {
  throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
 }
 if (!this.isConst && handle.$$.ptrType.isConst) {
  throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
 }
 var handleClass = handle.$$.ptrType.registeredClass;
 ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
 if (this.isSmartPointer) {
  if (undefined === handle.$$.smartPtr) {
   throwBindingError("Passing raw pointer to smart pointer is illegal");
  }
  switch (this.sharingPolicy) {
  case 0:
   if (handle.$$.smartPtrType === this) {
    ptr = handle.$$.smartPtr;
   } else {
    throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
   }
   break;

  case 1:
   ptr = handle.$$.smartPtr;
   break;

  case 2:
   if (handle.$$.smartPtrType === this) {
    ptr = handle.$$.smartPtr;
   } else {
    var clonedHandle = handle["clone"]();
    ptr = this.rawShare(ptr, __emval_register(function() {
     clonedHandle["delete"]();
    }));
    if (destructors !== null) {
     destructors.push(this.rawDestructor, ptr);
    }
   }
   break;

  default:
   throwBindingError("Unsupporting sharing policy");
  }
 }
 return ptr;
}

function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
 if (handle === null) {
  if (this.isReference) {
   throwBindingError("null is not a valid " + this.name);
  }
  return 0;
 }
 if (!handle.$$) {
  throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
 }
 if (!handle.$$.ptr) {
  throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
 }
 if (handle.$$.ptrType.isConst) {
  throwBindingError("Cannot convert argument of type " + handle.$$.ptrType.name + " to parameter type " + this.name);
 }
 var handleClass = handle.$$.ptrType.registeredClass;
 var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
 return ptr;
}

function RegisteredPointer_getPointee(ptr) {
 if (this.rawGetPointee) {
  ptr = this.rawGetPointee(ptr);
 }
 return ptr;
}

function RegisteredPointer_destructor(ptr) {
 if (this.rawDestructor) {
  this.rawDestructor(ptr);
 }
}

function RegisteredPointer_deleteObject(handle) {
 if (handle !== null) {
  handle["delete"]();
 }
}

function downcastPointer(ptr, ptrClass, desiredClass) {
 if (ptrClass === desiredClass) {
  return ptr;
 }
 if (undefined === desiredClass.baseClass) {
  return null;
 }
 var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);
 if (rv === null) {
  return null;
 }
 return desiredClass.downcast(rv);
}

function getInheritedInstance(class_, ptr) {
 ptr = getBasestPointer(class_, ptr);
 return registeredInstances[ptr];
}

function makeClassHandle(prototype, record) {
 if (!record.ptrType || !record.ptr) {
  throwInternalError("makeClassHandle requires ptr and ptrType");
 }
 var hasSmartPtrType = !!record.smartPtrType;
 var hasSmartPtr = !!record.smartPtr;
 if (hasSmartPtrType !== hasSmartPtr) {
  throwInternalError("Both smartPtrType and smartPtr must be specified");
 }
 record.count = {
  value: 1
 };
 return attachFinalizer(Object.create(prototype, {
  $$: {
   value: record
  }
 }));
}

function RegisteredPointer_fromWireType(ptr) {
 var rawPointer = this.getPointee(ptr);
 if (!rawPointer) {
  this.destructor(ptr);
  return null;
 }
 var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
 if (undefined !== registeredInstance) {
  if (0 === registeredInstance.$$.count.value) {
   registeredInstance.$$.ptr = rawPointer;
   registeredInstance.$$.smartPtr = ptr;
   return registeredInstance["clone"]();
  } else {
   var rv = registeredInstance["clone"]();
   this.destructor(ptr);
   return rv;
  }
 }
 function makeDefaultHandle() {
  if (this.isSmartPointer) {
   return makeClassHandle(this.registeredClass.instancePrototype, {
    ptrType: this.pointeeType,
    ptr: rawPointer,
    smartPtrType: this,
    smartPtr: ptr
   });
  } else {
   return makeClassHandle(this.registeredClass.instancePrototype, {
    ptrType: this,
    ptr: ptr
   });
  }
 }
 var actualType = this.registeredClass.getActualType(rawPointer);
 var registeredPointerRecord = registeredPointers[actualType];
 if (!registeredPointerRecord) {
  return makeDefaultHandle.call(this);
 }
 var toType;
 if (this.isConst) {
  toType = registeredPointerRecord.constPointerType;
 } else {
  toType = registeredPointerRecord.pointerType;
 }
 var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);
 if (dp === null) {
  return makeDefaultHandle.call(this);
 }
 if (this.isSmartPointer) {
  return makeClassHandle(toType.registeredClass.instancePrototype, {
   ptrType: toType,
   ptr: dp,
   smartPtrType: this,
   smartPtr: ptr
  });
 } else {
  return makeClassHandle(toType.registeredClass.instancePrototype, {
   ptrType: toType,
   ptr: dp
  });
 }
}

function init_RegisteredPointer() {
 RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;
 RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;
 RegisteredPointer.prototype["argPackAdvance"] = 8;
 RegisteredPointer.prototype["readValueFromPointer"] = simpleReadValueFromPointer;
 RegisteredPointer.prototype["deleteObject"] = RegisteredPointer_deleteObject;
 RegisteredPointer.prototype["fromWireType"] = RegisteredPointer_fromWireType;
}

function RegisteredPointer(name, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {
 this.name = name;
 this.registeredClass = registeredClass;
 this.isReference = isReference;
 this.isConst = isConst;
 this.isSmartPointer = isSmartPointer;
 this.pointeeType = pointeeType;
 this.sharingPolicy = sharingPolicy;
 this.rawGetPointee = rawGetPointee;
 this.rawConstructor = rawConstructor;
 this.rawShare = rawShare;
 this.rawDestructor = rawDestructor;
 if (!isSmartPointer && registeredClass.baseClass === undefined) {
  if (isConst) {
   this["toWireType"] = constNoSmartPtrRawPointerToWireType;
   this.destructorFunction = null;
  } else {
   this["toWireType"] = nonConstNoSmartPtrRawPointerToWireType;
   this.destructorFunction = null;
  }
 } else {
  this["toWireType"] = genericPointerToWireType;
 }
}

function replacePublicSymbol(name, value, numArguments) {
 if (!Module.hasOwnProperty(name)) {
  throwInternalError("Replacing nonexistant public symbol");
 }
 if (undefined !== Module[name].overloadTable && undefined !== numArguments) {
  Module[name].overloadTable[numArguments] = value;
 } else {
  Module[name] = value;
  Module[name].argCount = numArguments;
 }
}

function embind__requireFunction(signature, rawFunction) {
 signature = readLatin1String(signature);
 function makeDynCaller(dynCall) {
  var args = [];
  for (var i = 1; i < signature.length; ++i) {
   args.push("a" + i);
  }
  var name = "dynCall_" + signature + "_" + rawFunction;
  var body = "return function " + name + "(" + args.join(", ") + ") {\n";
  body += "    return dynCall(rawFunction" + (args.length ? ", " : "") + args.join(", ") + ");\n";
  body += "};\n";
  return new Function("dynCall", "rawFunction", body)(dynCall, rawFunction);
 }
 var dc = Module["dynCall_" + signature];
 var fp = makeDynCaller(dc);
 if (typeof fp !== "function") {
  throwBindingError("unknown function pointer with signature " + signature + ": " + rawFunction);
 }
 return fp;
}

var UnboundTypeError = undefined;

function throwUnboundTypeError(message, types) {
 var unboundTypes = [];
 var seen = {};
 function visit(type) {
  if (seen[type]) {
   return;
  }
  if (registeredTypes[type]) {
   return;
  }
  if (typeDependencies[type]) {
   typeDependencies[type].forEach(visit);
   return;
  }
  unboundTypes.push(type);
  seen[type] = true;
 }
 types.forEach(visit);
 throw new UnboundTypeError(message + ": " + unboundTypes.map(getTypeName).join([ ", " ]));
}

function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name, destructorSignature, rawDestructor) {
 name = readLatin1String(name);
 getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
 if (upcast) {
  upcast = embind__requireFunction(upcastSignature, upcast);
 }
 if (downcast) {
  downcast = embind__requireFunction(downcastSignature, downcast);
 }
 rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
 var legalFunctionName = makeLegalFunctionName(name);
 exposePublicSymbol(legalFunctionName, function() {
  throwUnboundTypeError("Cannot construct " + name + " due to unbound types", [ baseClassRawType ]);
 });
 whenDependentTypesAreResolved([ rawType, rawPointerType, rawConstPointerType ], baseClassRawType ? [ baseClassRawType ] : [], function(base) {
  base = base[0];
  var baseClass;
  var basePrototype;
  if (baseClassRawType) {
   baseClass = base.registeredClass;
   basePrototype = baseClass.instancePrototype;
  } else {
   basePrototype = ClassHandle.prototype;
  }
  var constructor = createNamedFunction(legalFunctionName, function() {
   if (Object.getPrototypeOf(this) !== instancePrototype) {
    throw new BindingError("Use 'new' to construct " + name);
   }
   if (undefined === registeredClass.constructor_body) {
    throw new BindingError(name + " has no accessible constructor");
   }
   var body = registeredClass.constructor_body[arguments.length];
   if (undefined === body) {
    throw new BindingError("Tried to invoke ctor of " + name + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(registeredClass.constructor_body).toString() + ") parameters instead!");
   }
   return body.apply(this, arguments);
  });
  var instancePrototype = Object.create(basePrototype, {
   constructor: {
    value: constructor
   }
  });
  constructor.prototype = instancePrototype;
  var registeredClass = new RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);
  var referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false);
  var pointerConverter = new RegisteredPointer(name + "*", registeredClass, false, false, false);
  var constPointerConverter = new RegisteredPointer(name + " const*", registeredClass, false, true, false);
  registeredPointers[rawType] = {
   pointerType: pointerConverter,
   constPointerType: constPointerConverter
  };
  replacePublicSymbol(legalFunctionName, constructor);
  return [ referenceConverter, pointerConverter, constPointerConverter ];
 });
}

function new_(constructor, argumentList) {
 if (!(constructor instanceof Function)) {
  throw new TypeError("new_ called with constructor type " + typeof constructor + " which is not a function");
 }
 var dummy = createNamedFunction(constructor.name || "unknownFunctionName", function() {});
 dummy.prototype = constructor.prototype;
 var obj = new dummy();
 var r = constructor.apply(obj, argumentList);
 return r instanceof Object ? r : obj;
}

function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {
 var argCount = argTypes.length;
 if (argCount < 2) {
  throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
 }
 var isClassMethodFunc = argTypes[1] !== null && classType !== null;
 var needsDestructorStack = false;
 for (var i = 1; i < argTypes.length; ++i) {
  if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {
   needsDestructorStack = true;
   break;
  }
 }
 var returns = argTypes[0].name !== "void";
 var argsList = "";
 var argsListWired = "";
 for (var i = 0; i < argCount - 2; ++i) {
  argsList += (i !== 0 ? ", " : "") + "arg" + i;
  argsListWired += (i !== 0 ? ", " : "") + "arg" + i + "Wired";
 }
 var invokerFnBody = "return function " + makeLegalFunctionName(humanName) + "(" + argsList + ") {\n" + "if (arguments.length !== " + (argCount - 2) + ") {\n" + "throwBindingError('function " + humanName + " called with ' + arguments.length + ' arguments, expected " + (argCount - 2) + " args!');\n" + "}\n";
 if (needsDestructorStack) {
  invokerFnBody += "var destructors = [];\n";
 }
 var dtorStack = needsDestructorStack ? "destructors" : "null";
 var args1 = [ "throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam" ];
 var args2 = [ throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1] ];
 if (isClassMethodFunc) {
  invokerFnBody += "var thisWired = classParam.toWireType(" + dtorStack + ", this);\n";
 }
 for (var i = 0; i < argCount - 2; ++i) {
  invokerFnBody += "var arg" + i + "Wired = argType" + i + ".toWireType(" + dtorStack + ", arg" + i + "); // " + argTypes[i + 2].name + "\n";
  args1.push("argType" + i);
  args2.push(argTypes[i + 2]);
 }
 if (isClassMethodFunc) {
  argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
 }
 invokerFnBody += (returns ? "var rv = " : "") + "invoker(fn" + (argsListWired.length > 0 ? ", " : "") + argsListWired + ");\n";
 if (needsDestructorStack) {
  invokerFnBody += "runDestructors(destructors);\n";
 } else {
  for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {
   var paramName = i === 1 ? "thisWired" : "arg" + (i - 2) + "Wired";
   if (argTypes[i].destructorFunction !== null) {
    invokerFnBody += paramName + "_dtor(" + paramName + "); // " + argTypes[i].name + "\n";
    args1.push(paramName + "_dtor");
    args2.push(argTypes[i].destructorFunction);
   }
  }
 }
 if (returns) {
  invokerFnBody += "var ret = retType.fromWireType(rv);\n" + "return ret;\n";
 } else {}
 invokerFnBody += "}\n";
 args1.push(invokerFnBody);
 var invokerFunction = new_(Function, args1).apply(null, args2);
 return invokerFunction;
}

function heap32VectorToArray(count, firstElement) {
 var array = [];
 for (var i = 0; i < count; i++) {
  array.push(HEAP32[(firstElement >> 2) + i]);
 }
 return array;
}

function __embind_register_class_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, fn) {
 var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
 methodName = readLatin1String(methodName);
 rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
 whenDependentTypesAreResolved([], [ rawClassType ], function(classType) {
  classType = classType[0];
  var humanName = classType.name + "." + methodName;
  function unboundTypesHandler() {
   throwUnboundTypeError("Cannot call " + humanName + " due to unbound types", rawArgTypes);
  }
  var proto = classType.registeredClass.constructor;
  if (undefined === proto[methodName]) {
   unboundTypesHandler.argCount = argCount - 1;
   proto[methodName] = unboundTypesHandler;
  } else {
   ensureOverloadTable(proto, methodName, humanName);
   proto[methodName].overloadTable[argCount - 1] = unboundTypesHandler;
  }
  whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
   var invokerArgsArray = [ argTypes[0], null ].concat(argTypes.slice(1));
   var func = craftInvokerFunction(humanName, invokerArgsArray, null, rawInvoker, fn);
   if (undefined === proto[methodName].overloadTable) {
    func.argCount = argCount - 1;
    proto[methodName] = func;
   } else {
    proto[methodName].overloadTable[argCount - 1] = func;
   }
   return [];
  });
  return [];
 });
}

function validateThis(this_, classType, humanName) {
 if (!(this_ instanceof Object)) {
  throwBindingError(humanName + ' with invalid "this": ' + this_);
 }
 if (!(this_ instanceof classType.registeredClass.constructor)) {
  throwBindingError(humanName + ' incompatible with "this" of type ' + this_.constructor.name);
 }
 if (!this_.$$.ptr) {
  throwBindingError("cannot call emscripten binding method " + humanName + " on deleted object");
 }
 return upcastPointer(this_.$$.ptr, this_.$$.ptrType.registeredClass, classType.registeredClass);
}

function __embind_register_class_class_property(rawClassType, fieldName, rawFieldType, rawFieldPtr, getterSignature, getter, setterSignature, setter) {
 fieldName = readLatin1String(fieldName);
 getter = embind__requireFunction(getterSignature, getter);
 whenDependentTypesAreResolved([], [ rawClassType ], function(classType) {
  classType = classType[0];
  var humanName = classType.name + "." + fieldName;
  var desc = {
   get: function() {
    throwUnboundTypeError("Cannot access " + humanName + " due to unbound types", [ rawFieldType ]);
   },
   enumerable: true,
   configurable: true
  };
  if (setter) {
   desc.set = function() {
    throwUnboundTypeError("Cannot access " + humanName + " due to unbound types", [ rawFieldType ]);
   };
  } else {
   desc.set = function(v) {
    throwBindingError(humanName + " is a read-only property");
   };
  }
  Object.defineProperty(classType.registeredClass.constructor, fieldName, desc);
  whenDependentTypesAreResolved([], [ rawFieldType ], function(fieldType) {
   fieldType = fieldType[0];
   var desc = {
    get: function() {
     return fieldType["fromWireType"](getter(rawFieldPtr));
    },
    enumerable: true
   };
   if (setter) {
    setter = embind__requireFunction(setterSignature, setter);
    desc.set = function(v) {
     var destructors = [];
     setter(rawFieldPtr, fieldType["toWireType"](destructors, v));
     runDestructors(destructors);
    };
   }
   Object.defineProperty(classType.registeredClass.constructor, fieldName, desc);
   return [];
  });
  return [];
 });
}

function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {
 assert(argCount > 0);
 var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
 invoker = embind__requireFunction(invokerSignature, invoker);
 var args = [ rawConstructor ];
 var destructors = [];
 whenDependentTypesAreResolved([], [ rawClassType ], function(classType) {
  classType = classType[0];
  var humanName = "constructor " + classType.name;
  if (undefined === classType.registeredClass.constructor_body) {
   classType.registeredClass.constructor_body = [];
  }
  if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {
   throw new BindingError("Cannot register multiple constructors with identical number of parameters (" + (argCount - 1) + ") for class '" + classType.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
  }
  classType.registeredClass.constructor_body[argCount - 1] = function unboundTypeHandler() {
   throwUnboundTypeError("Cannot construct " + classType.name + " due to unbound types", rawArgTypes);
  };
  whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
   classType.registeredClass.constructor_body[argCount - 1] = function constructor_body() {
    if (arguments.length !== argCount - 1) {
     throwBindingError(humanName + " called with " + arguments.length + " arguments, expected " + (argCount - 1));
    }
    destructors.length = 0;
    args.length = argCount;
    for (var i = 1; i < argCount; ++i) {
     args[i] = argTypes[i]["toWireType"](destructors, arguments[i - 1]);
    }
    var ptr = invoker.apply(null, args);
    runDestructors(destructors);
    return argTypes[0]["fromWireType"](ptr);
   };
   return [];
  });
  return [];
 });
}

function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual) {
 var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
 methodName = readLatin1String(methodName);
 rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
 whenDependentTypesAreResolved([], [ rawClassType ], function(classType) {
  classType = classType[0];
  var humanName = classType.name + "." + methodName;
  if (isPureVirtual) {
   classType.registeredClass.pureVirtualFunctions.push(methodName);
  }
  function unboundTypesHandler() {
   throwUnboundTypeError("Cannot call " + humanName + " due to unbound types", rawArgTypes);
  }
  var proto = classType.registeredClass.instancePrototype;
  var method = proto[methodName];
  if (undefined === method || undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {
   unboundTypesHandler.argCount = argCount - 2;
   unboundTypesHandler.className = classType.name;
   proto[methodName] = unboundTypesHandler;
  } else {
   ensureOverloadTable(proto, methodName, humanName);
   proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
  }
  whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
   var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);
   if (undefined === proto[methodName].overloadTable) {
    memberFunction.argCount = argCount - 2;
    proto[methodName] = memberFunction;
   } else {
    proto[methodName].overloadTable[argCount - 2] = memberFunction;
   }
   return [];
  });
  return [];
 });
}

function __embind_register_class_property(classType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
 fieldName = readLatin1String(fieldName);
 getter = embind__requireFunction(getterSignature, getter);
 whenDependentTypesAreResolved([], [ classType ], function(classType) {
  classType = classType[0];
  var humanName = classType.name + "." + fieldName;
  var desc = {
   get: function() {
    throwUnboundTypeError("Cannot access " + humanName + " due to unbound types", [ getterReturnType, setterArgumentType ]);
   },
   enumerable: true,
   configurable: true
  };
  if (setter) {
   desc.set = function() {
    throwUnboundTypeError("Cannot access " + humanName + " due to unbound types", [ getterReturnType, setterArgumentType ]);
   };
  } else {
   desc.set = function(v) {
    throwBindingError(humanName + " is a read-only property");
   };
  }
  Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);
  whenDependentTypesAreResolved([], setter ? [ getterReturnType, setterArgumentType ] : [ getterReturnType ], function(types) {
   var getterReturnType = types[0];
   var desc = {
    get: function() {
     var ptr = validateThis(this, classType, humanName + " getter");
     return getterReturnType["fromWireType"](getter(getterContext, ptr));
    },
    enumerable: true
   };
   if (setter) {
    setter = embind__requireFunction(setterSignature, setter);
    var setterArgumentType = types[1];
    desc.set = function(v) {
     var ptr = validateThis(this, classType, humanName + " setter");
     var destructors = [];
     setter(setterContext, ptr, setterArgumentType["toWireType"](destructors, v));
     runDestructors(destructors);
    };
   }
   Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);
   return [];
  });
  return [];
 });
}

function __emval_decref(handle) {
 if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {
  emval_handle_array[handle] = undefined;
  emval_free_list.push(handle);
 }
}

function __embind_register_emval(rawType, name) {
 name = readLatin1String(name);
 registerType(rawType, {
  name: name,
  "fromWireType": function(handle) {
   var rv = emval_handle_array[handle].value;
   __emval_decref(handle);
   return rv;
  },
  "toWireType": function(destructors, value) {
   return __emval_register(value);
  },
  "argPackAdvance": 8,
  "readValueFromPointer": simpleReadValueFromPointer,
  destructorFunction: null
 });
}

function enumReadValueFromPointer(name, shift, signed) {
 switch (shift) {
 case 0:
  return function(pointer) {
   var heap = signed ? HEAP8 : HEAPU8;
   return this["fromWireType"](heap[pointer]);
  };

 case 1:
  return function(pointer) {
   var heap = signed ? HEAP16 : HEAPU16;
   return this["fromWireType"](heap[pointer >> 1]);
  };

 case 2:
  return function(pointer) {
   var heap = signed ? HEAP32 : HEAPU32;
   return this["fromWireType"](heap[pointer >> 2]);
  };

 default:
  throw new TypeError("Unknown integer type: " + name);
 }
}

function __embind_register_enum(rawType, name, size, isSigned) {
 var shift = getShiftFromSize(size);
 name = readLatin1String(name);
 function ctor() {}
 ctor.values = {};
 registerType(rawType, {
  name: name,
  constructor: ctor,
  "fromWireType": function(c) {
   return this.constructor.values[c];
  },
  "toWireType": function(destructors, c) {
   return c.value;
  },
  "argPackAdvance": 8,
  "readValueFromPointer": enumReadValueFromPointer(name, shift, isSigned),
  destructorFunction: null
 });
 exposePublicSymbol(name, ctor);
}

function __embind_register_enum_value(rawEnumType, name, enumValue) {
 var enumType = requireRegisteredType(rawEnumType, "enum");
 name = readLatin1String(name);
 var Enum = enumType.constructor;
 var Value = Object.create(enumType.constructor.prototype, {
  value: {
   value: enumValue
  },
  constructor: {
   value: createNamedFunction(enumType.name + "_" + name, function() {})
  }
 });
 Enum.values[enumValue] = Value;
 Enum[name] = Value;
}

function _embind_repr(v) {
 if (v === null) {
  return "null";
 }
 var t = typeof v;
 if (t === "object" || t === "array" || t === "function") {
  return v.toString();
 } else {
  return "" + v;
 }
}

function floatReadValueFromPointer(name, shift) {
 switch (shift) {
 case 2:
  return function(pointer) {
   return this["fromWireType"](HEAPF32[pointer >> 2]);
  };

 case 3:
  return function(pointer) {
   return this["fromWireType"](HEAPF64[pointer >> 3]);
  };

 default:
  throw new TypeError("Unknown float type: " + name);
 }
}

function __embind_register_float(rawType, name, size) {
 var shift = getShiftFromSize(size);
 name = readLatin1String(name);
 registerType(rawType, {
  name: name,
  "fromWireType": function(value) {
   return value;
  },
  "toWireType": function(destructors, value) {
   if (typeof value !== "number" && typeof value !== "boolean") {
    throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
   }
   return value;
  },
  "argPackAdvance": 8,
  "readValueFromPointer": floatReadValueFromPointer(name, shift),
  destructorFunction: null
 });
}

function __embind_register_function(name, argCount, rawArgTypesAddr, signature, rawInvoker, fn) {
 var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
 name = readLatin1String(name);
 rawInvoker = embind__requireFunction(signature, rawInvoker);
 exposePublicSymbol(name, function() {
  throwUnboundTypeError("Cannot call " + name + " due to unbound types", argTypes);
 }, argCount - 1);
 whenDependentTypesAreResolved([], argTypes, function(argTypes) {
  var invokerArgsArray = [ argTypes[0], null ].concat(argTypes.slice(1));
  replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null, rawInvoker, fn), argCount - 1);
  return [];
 });
}

function integerReadValueFromPointer(name, shift, signed) {
 switch (shift) {
 case 0:
  return signed ? function readS8FromPointer(pointer) {
   return HEAP8[pointer];
  } : function readU8FromPointer(pointer) {
   return HEAPU8[pointer];
  };

 case 1:
  return signed ? function readS16FromPointer(pointer) {
   return HEAP16[pointer >> 1];
  } : function readU16FromPointer(pointer) {
   return HEAPU16[pointer >> 1];
  };

 case 2:
  return signed ? function readS32FromPointer(pointer) {
   return HEAP32[pointer >> 2];
  } : function readU32FromPointer(pointer) {
   return HEAPU32[pointer >> 2];
  };

 default:
  throw new TypeError("Unknown integer type: " + name);
 }
}

function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {
 name = readLatin1String(name);
 if (maxRange === -1) {
  maxRange = 4294967295;
 }
 var shift = getShiftFromSize(size);
 var fromWireType = function(value) {
  return value;
 };
 if (minRange === 0) {
  var bitshift = 32 - 8 * size;
  fromWireType = function(value) {
   return value << bitshift >>> bitshift;
  };
 }
 var isUnsignedType = name.indexOf("unsigned") != -1;
 registerType(primitiveType, {
  name: name,
  "fromWireType": fromWireType,
  "toWireType": function(destructors, value) {
   if (typeof value !== "number" && typeof value !== "boolean") {
    throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
   }
   if (value < minRange || value > maxRange) {
    throw new TypeError('Passing a number "' + _embind_repr(value) + '" from JS side to C/C++ side to an argument of type "' + name + '", which is outside the valid range [' + minRange + ", " + maxRange + "]!");
   }
   return isUnsignedType ? value >>> 0 : value | 0;
  },
  "argPackAdvance": 8,
  "readValueFromPointer": integerReadValueFromPointer(name, shift, minRange !== 0),
  destructorFunction: null
 });
}

function __embind_register_memory_view(rawType, dataTypeIndex, name) {
 var typeMapping = [ Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array ];
 var TA = typeMapping[dataTypeIndex];
 function decodeMemoryView(handle) {
  handle = handle >> 2;
  var heap = HEAPU32;
  var size = heap[handle];
  var data = heap[handle + 1];
  return new TA(buffer, data, size);
 }
 name = readLatin1String(name);
 registerType(rawType, {
  name: name,
  "fromWireType": decodeMemoryView,
  "argPackAdvance": 8,
  "readValueFromPointer": decodeMemoryView
 }, {
  ignoreDuplicateRegistrations: true
 });
}

function __embind_register_std_string(rawType, name) {
 name = readLatin1String(name);
 var stdStringIsUTF8 = name === "std::string";
 registerType(rawType, {
  name: name,
  "fromWireType": function(value) {
   var length = HEAPU32[value >> 2];
   var str;
   if (stdStringIsUTF8) {
    var decodeStartPtr = value + 4;
    for (var i = 0; i <= length; ++i) {
     var currentBytePtr = value + 4 + i;
     if (i == length || HEAPU8[currentBytePtr] == 0) {
      var maxRead = currentBytePtr - decodeStartPtr;
      var stringSegment = UTF8ToString(decodeStartPtr, maxRead);
      if (str === undefined) {
       str = stringSegment;
      } else {
       str += String.fromCharCode(0);
       str += stringSegment;
      }
      decodeStartPtr = currentBytePtr + 1;
     }
    }
   } else {
    var a = new Array(length);
    for (var i = 0; i < length; ++i) {
     a[i] = String.fromCharCode(HEAPU8[value + 4 + i]);
    }
    str = a.join("");
   }
   _free(value);
   return str;
  },
  "toWireType": function(destructors, value) {
   if (value instanceof ArrayBuffer) {
    value = new Uint8Array(value);
   }
   var getLength;
   var valueIsOfTypeString = typeof value === "string";
   if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
    throwBindingError("Cannot pass non-string to std::string");
   }
   if (stdStringIsUTF8 && valueIsOfTypeString) {
    getLength = function() {
     return lengthBytesUTF8(value);
    };
   } else {
    getLength = function() {
     return value.length;
    };
   }
   var length = getLength();
   var ptr = _malloc(4 + length + 1);
   HEAPU32[ptr >> 2] = length;
   if (stdStringIsUTF8 && valueIsOfTypeString) {
    stringToUTF8(value, ptr + 4, length + 1);
   } else {
    if (valueIsOfTypeString) {
     for (var i = 0; i < length; ++i) {
      var charCode = value.charCodeAt(i);
      if (charCode > 255) {
       _free(ptr);
       throwBindingError("String has UTF-16 code units that do not fit in 8 bits");
      }
      HEAPU8[ptr + 4 + i] = charCode;
     }
    } else {
     for (var i = 0; i < length; ++i) {
      HEAPU8[ptr + 4 + i] = value[i];
     }
    }
   }
   if (destructors !== null) {
    destructors.push(_free, ptr);
   }
   return ptr;
  },
  "argPackAdvance": 8,
  "readValueFromPointer": simpleReadValueFromPointer,
  destructorFunction: function(ptr) {
   _free(ptr);
  }
 });
}

function __embind_register_std_wstring(rawType, charSize, name) {
 name = readLatin1String(name);
 var decodeString, encodeString, getHeap, lengthBytesUTF, shift;
 if (charSize === 2) {
  decodeString = UTF16ToString;
  encodeString = stringToUTF16;
  lengthBytesUTF = lengthBytesUTF16;
  getHeap = function() {
   return HEAPU16;
  };
  shift = 1;
 } else if (charSize === 4) {
  decodeString = UTF32ToString;
  encodeString = stringToUTF32;
  lengthBytesUTF = lengthBytesUTF32;
  getHeap = function() {
   return HEAPU32;
  };
  shift = 2;
 }
 registerType(rawType, {
  name: name,
  "fromWireType": function(value) {
   var length = HEAPU32[value >> 2];
   var HEAP = getHeap();
   var str;
   var decodeStartPtr = value + 4;
   for (var i = 0; i <= length; ++i) {
    var currentBytePtr = value + 4 + i * charSize;
    if (i == length || HEAP[currentBytePtr >> shift] == 0) {
     var maxReadBytes = currentBytePtr - decodeStartPtr;
     var stringSegment = decodeString(decodeStartPtr, maxReadBytes);
     if (str === undefined) {
      str = stringSegment;
     } else {
      str += String.fromCharCode(0);
      str += stringSegment;
     }
     decodeStartPtr = currentBytePtr + charSize;
    }
   }
   _free(value);
   return str;
  },
  "toWireType": function(destructors, value) {
   if (!(typeof value === "string")) {
    throwBindingError("Cannot pass non-string to C++ string type " + name);
   }
   var length = lengthBytesUTF(value);
   var ptr = _malloc(4 + length + charSize);
   HEAPU32[ptr >> 2] = length >> shift;
   encodeString(value, ptr + 4, length + charSize);
   if (destructors !== null) {
    destructors.push(_free, ptr);
   }
   return ptr;
  },
  "argPackAdvance": 8,
  "readValueFromPointer": simpleReadValueFromPointer,
  destructorFunction: function(ptr) {
   _free(ptr);
  }
 });
}

function __embind_register_value_object(rawType, name, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {
 structRegistrations[rawType] = {
  name: readLatin1String(name),
  rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),
  rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),
  fields: []
 };
}

function __embind_register_value_object_field(structType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
 structRegistrations[structType].fields.push({
  fieldName: readLatin1String(fieldName),
  getterReturnType: getterReturnType,
  getter: embind__requireFunction(getterSignature, getter),
  getterContext: getterContext,
  setterArgumentType: setterArgumentType,
  setter: embind__requireFunction(setterSignature, setter),
  setterContext: setterContext
 });
}

function __embind_register_void(rawType, name) {
 name = readLatin1String(name);
 registerType(rawType, {
  isVoid: true,
  name: name,
  "argPackAdvance": 0,
  "fromWireType": function() {
   return undefined;
  },
  "toWireType": function(destructors, o) {
   return undefined;
  }
 });
}

function __emval_as(handle, returnType, destructorsRef) {
 handle = requireHandle(handle);
 returnType = requireRegisteredType(returnType, "emval::as");
 var destructors = [];
 var rd = __emval_register(destructors);
 HEAP32[destructorsRef >> 2] = rd;
 return returnType["toWireType"](destructors, handle);
}

function __emval_allocateDestructors(destructorsRef) {
 var destructors = [];
 HEAP32[destructorsRef >> 2] = __emval_register(destructors);
 return destructors;
}

var emval_symbols = {};

function getStringOrSymbol(address) {
 var symbol = emval_symbols[address];
 if (symbol === undefined) {
  return readLatin1String(address);
 } else {
  return symbol;
 }
}

var emval_methodCallers = [];

function __emval_call_method(caller, handle, methodName, destructorsRef, args) {
 caller = emval_methodCallers[caller];
 handle = requireHandle(handle);
 methodName = getStringOrSymbol(methodName);
 return caller(handle, methodName, __emval_allocateDestructors(destructorsRef), args);
}

function __emval_call_void_method(caller, handle, methodName, args) {
 caller = emval_methodCallers[caller];
 handle = requireHandle(handle);
 methodName = getStringOrSymbol(methodName);
 caller(handle, methodName, null, args);
}

function __emval_addMethodCaller(caller) {
 var id = emval_methodCallers.length;
 emval_methodCallers.push(caller);
 return id;
}

function __emval_lookupTypes(argCount, argTypes) {
 var a = new Array(argCount);
 for (var i = 0; i < argCount; ++i) {
  a[i] = requireRegisteredType(HEAP32[(argTypes >> 2) + i], "parameter " + i);
 }
 return a;
}

function __emval_get_method_caller(argCount, argTypes) {
 var types = __emval_lookupTypes(argCount, argTypes);
 var retType = types[0];
 var signatureName = retType.name + "_$" + types.slice(1).map(function(t) {
  return t.name;
 }).join("_") + "$";
 var params = [ "retType" ];
 var args = [ retType ];
 var argsList = "";
 for (var i = 0; i < argCount - 1; ++i) {
  argsList += (i !== 0 ? ", " : "") + "arg" + i;
  params.push("argType" + i);
  args.push(types[1 + i]);
 }
 var functionName = makeLegalFunctionName("methodCaller_" + signatureName);
 var functionBody = "return function " + functionName + "(handle, name, destructors, args) {\n";
 var offset = 0;
 for (var i = 0; i < argCount - 1; ++i) {
  functionBody += "    var arg" + i + " = argType" + i + ".readValueFromPointer(args" + (offset ? "+" + offset : "") + ");\n";
  offset += types[i + 1]["argPackAdvance"];
 }
 functionBody += "    var rv = handle[name](" + argsList + ");\n";
 for (var i = 0; i < argCount - 1; ++i) {
  if (types[i + 1]["deleteObject"]) {
   functionBody += "    argType" + i + ".deleteObject(arg" + i + ");\n";
  }
 }
 if (!retType.isVoid) {
  functionBody += "    return retType.toWireType(destructors, rv);\n";
 }
 functionBody += "};\n";
 params.push(functionBody);
 var invokerFunction = new_(Function, params).apply(null, args);
 return __emval_addMethodCaller(invokerFunction);
}

function __emval_get_module_property(name) {
 name = getStringOrSymbol(name);
 return __emval_register(Module[name]);
}

function __emval_get_property(handle, key) {
 handle = requireHandle(handle);
 key = requireHandle(key);
 return __emval_register(handle[key]);
}

function __emval_incref(handle) {
 if (handle > 4) {
  emval_handle_array[handle].refcount += 1;
 }
}

function __emval_new_cstring(v) {
 return __emval_register(getStringOrSymbol(v));
}

function __emval_run_destructors(handle) {
 var destructors = emval_handle_array[handle].value;
 runDestructors(destructors);
 __emval_decref(handle);
}

function __emval_take_value(type, argv) {
 type = requireRegisteredType(type, "_emval_take_value");
 var v = type["readValueFromPointer"](argv);
 return __emval_register(v);
}

function _abort() {
 abort();
}

function _emscripten_memcpy_big(dest, src, num) {
 HEAPU8.copyWithin(dest, src, src + num);
}

function _emscripten_get_heap_size() {
 return HEAPU8.length;
}

function emscripten_realloc_buffer(size) {
 try {
  wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);
  updateGlobalBufferAndViews(wasmMemory.buffer);
  return 1;
 } catch (e) {}
}

function _emscripten_resize_heap(requestedSize) {
 requestedSize = requestedSize >>> 0;
 var oldSize = _emscripten_get_heap_size();
 var PAGE_MULTIPLE = 65536;
 var maxHeapSize = 2147483648;
 if (requestedSize > maxHeapSize) {
  return false;
 }
 var minHeapSize = 16777216;
 for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
  var overGrownHeapSize = oldSize * (1 + .2 / cutDown);
  overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
  var newSize = Math.min(maxHeapSize, alignUp(Math.max(minHeapSize, requestedSize, overGrownHeapSize), PAGE_MULTIPLE));
  var replacement = emscripten_realloc_buffer(newSize);
  if (replacement) {
   return true;
  }
 }
 return false;
}

var PATH = {
 splitPath: function(filename) {
  var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
  return splitPathRe.exec(filename).slice(1);
 },
 normalizeArray: function(parts, allowAboveRoot) {
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
   var last = parts[i];
   if (last === ".") {
    parts.splice(i, 1);
   } else if (last === "..") {
    parts.splice(i, 1);
    up++;
   } else if (up) {
    parts.splice(i, 1);
    up--;
   }
  }
  if (allowAboveRoot) {
   for (;up; up--) {
    parts.unshift("..");
   }
  }
  return parts;
 },
 normalize: function(path) {
  var isAbsolute = path.charAt(0) === "/", trailingSlash = path.substr(-1) === "/";
  path = PATH.normalizeArray(path.split("/").filter(function(p) {
   return !!p;
  }), !isAbsolute).join("/");
  if (!path && !isAbsolute) {
   path = ".";
  }
  if (path && trailingSlash) {
   path += "/";
  }
  return (isAbsolute ? "/" : "") + path;
 },
 dirname: function(path) {
  var result = PATH.splitPath(path), root = result[0], dir = result[1];
  if (!root && !dir) {
   return ".";
  }
  if (dir) {
   dir = dir.substr(0, dir.length - 1);
  }
  return root + dir;
 },
 basename: function(path) {
  if (path === "/") return "/";
  var lastSlash = path.lastIndexOf("/");
  if (lastSlash === -1) return path;
  return path.substr(lastSlash + 1);
 },
 extname: function(path) {
  return PATH.splitPath(path)[3];
 },
 join: function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return PATH.normalize(paths.join("/"));
 },
 join2: function(l, r) {
  return PATH.normalize(l + "/" + r);
 }
};

var SYSCALLS = {
 mappings: {},
 buffers: [ null, [], [] ],
 printChar: function(stream, curr) {
  var buffer = SYSCALLS.buffers[stream];
  if (curr === 0 || curr === 10) {
   (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));
   buffer.length = 0;
  } else {
   buffer.push(curr);
  }
 },
 varargs: undefined,
 get: function() {
  SYSCALLS.varargs += 4;
  var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
  return ret;
 },
 getStr: function(ptr) {
  var ret = UTF8ToString(ptr);
  return ret;
 },
 get64: function(low, high) {
  return low;
 }
};

function _fd_close(fd) {
 return 0;
}

function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {}

function _fd_write(fd, iov, iovcnt, pnum) {
 var num = 0;
 for (var i = 0; i < iovcnt; i++) {
  var ptr = HEAP32[iov + i * 8 >> 2];
  var len = HEAP32[iov + (i * 8 + 4) >> 2];
  for (var j = 0; j < len; j++) {
   SYSCALLS.printChar(fd, HEAPU8[ptr + j]);
  }
  num += len;
 }
 HEAP32[pnum >> 2] = num;
 return 0;
}

function _setTempRet0($i) {
 setTempRet0($i | 0);
}

init_emval();

PureVirtualError = Module["PureVirtualError"] = extendError(Error, "PureVirtualError");

embind_init_charCodes();

init_embind();

BindingError = Module["BindingError"] = extendError(Error, "BindingError");

InternalError = Module["InternalError"] = extendError(Error, "InternalError");

init_ClassHandle();

init_RegisteredPointer();

UnboundTypeError = Module["UnboundTypeError"] = extendError(Error, "UnboundTypeError");

var ASSERTIONS = false;

function intArrayToString(array) {
 var ret = [];
 for (var i = 0; i < array.length; i++) {
  var chr = array[i];
  if (chr > 255) {
   if (ASSERTIONS) {
    assert(false, "Character code " + chr + " (" + String.fromCharCode(chr) + ")  at offset " + i + " not in 0x00-0xFF.");
   }
   chr &= 255;
  }
  ret.push(String.fromCharCode(chr));
 }
 return ret.join("");
}

var decodeBase64 = typeof atob === "function" ? atob : function(input) {
 var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
 var output = "";
 var chr1, chr2, chr3;
 var enc1, enc2, enc3, enc4;
 var i = 0;
 input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
 do {
  enc1 = keyStr.indexOf(input.charAt(i++));
  enc2 = keyStr.indexOf(input.charAt(i++));
  enc3 = keyStr.indexOf(input.charAt(i++));
  enc4 = keyStr.indexOf(input.charAt(i++));
  chr1 = enc1 << 2 | enc2 >> 4;
  chr2 = (enc2 & 15) << 4 | enc3 >> 2;
  chr3 = (enc3 & 3) << 6 | enc4;
  output = output + String.fromCharCode(chr1);
  if (enc3 !== 64) {
   output = output + String.fromCharCode(chr2);
  }
  if (enc4 !== 64) {
   output = output + String.fromCharCode(chr3);
  }
 } while (i < input.length);
 return output;
};

function intArrayFromBase64(s) {
 if (typeof ENVIRONMENT_IS_NODE === "boolean" && ENVIRONMENT_IS_NODE) {
  var buf;
  try {
   buf = Buffer.from(s, "base64");
  } catch (_) {
   buf = new Buffer(s, "base64");
  }
  return new Uint8Array(buf["buffer"], buf["byteOffset"], buf["byteLength"]);
 }
 try {
  var decoded = decodeBase64(s);
  var bytes = new Uint8Array(decoded.length);
  for (var i = 0; i < decoded.length; ++i) {
   bytes[i] = decoded.charCodeAt(i);
  }
  return bytes;
 } catch (_) {
  throw new Error("Converting base64 string to bytes failed.");
 }
}

function tryParseAsDataURI(filename) {
 if (!isDataURI(filename)) {
  return;
 }
 return intArrayFromBase64(filename.slice(dataURIPrefix.length));
}

var asmLibraryArg = {
 "n": __embind_create_inheriting_constructor,
 "I": __embind_finalize_value_object,
 "B": __embind_register_bool,
 "c": __embind_register_class,
 "i": __embind_register_class_class_function,
 "f": __embind_register_class_class_property,
 "r": __embind_register_class_constructor,
 "a": __embind_register_class_function,
 "b": __embind_register_class_property,
 "A": __embind_register_emval,
 "k": __embind_register_enum,
 "j": __embind_register_enum_value,
 "p": __embind_register_float,
 "L": __embind_register_function,
 "h": __embind_register_integer,
 "g": __embind_register_memory_view,
 "q": __embind_register_std_string,
 "m": __embind_register_std_wstring,
 "K": __embind_register_value_object,
 "J": __embind_register_value_object_field,
 "C": __embind_register_void,
 "l": __emval_as,
 "H": __emval_call_method,
 "e": __emval_call_void_method,
 "E": __emval_decref,
 "d": __emval_get_method_caller,
 "M": __emval_get_module_property,
 "u": __emval_get_property,
 "D": __emval_incref,
 "F": __emval_new_cstring,
 "G": __emval_run_destructors,
 "t": __emval_take_value,
 "s": _abort,
 "x": _emscripten_memcpy_big,
 "y": _emscripten_resize_heap,
 "z": _fd_close,
 "v": _fd_seek,
 "o": _fd_write,
 "memory": wasmMemory,
 "w": _setTempRet0,
 "table": wasmTable
};

var asm = createWasm();

var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
 return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["N"]).apply(null, arguments);
};

var _malloc = Module["_malloc"] = function() {
 return (_malloc = Module["_malloc"] = Module["asm"]["O"]).apply(null, arguments);
};

var ___getTypeName = Module["___getTypeName"] = function() {
 return (___getTypeName = Module["___getTypeName"] = Module["asm"]["P"]).apply(null, arguments);
};

var ___embind_register_native_and_builtin_types = Module["___embind_register_native_and_builtin_types"] = function() {
 return (___embind_register_native_and_builtin_types = Module["___embind_register_native_and_builtin_types"] = Module["asm"]["Q"]).apply(null, arguments);
};

var _free = Module["_free"] = function() {
 return (_free = Module["_free"] = Module["asm"]["R"]).apply(null, arguments);
};

var dynCall_ii = Module["dynCall_ii"] = function() {
 return (dynCall_ii = Module["dynCall_ii"] = Module["asm"]["S"]).apply(null, arguments);
};

var dynCall_vi = Module["dynCall_vi"] = function() {
 return (dynCall_vi = Module["dynCall_vi"] = Module["asm"]["T"]).apply(null, arguments);
};

var dynCall_iii = Module["dynCall_iii"] = function() {
 return (dynCall_iii = Module["dynCall_iii"] = Module["asm"]["U"]).apply(null, arguments);
};

var dynCall_iiii = Module["dynCall_iiii"] = function() {
 return (dynCall_iiii = Module["dynCall_iiii"] = Module["asm"]["V"]).apply(null, arguments);
};

var dynCall_v = Module["dynCall_v"] = function() {
 return (dynCall_v = Module["dynCall_v"] = Module["asm"]["W"]).apply(null, arguments);
};

var dynCall_viiif = Module["dynCall_viiif"] = function() {
 return (dynCall_viiif = Module["dynCall_viiif"] = Module["asm"]["X"]).apply(null, arguments);
};

var dynCall_viiifif = Module["dynCall_viiifif"] = function() {
 return (dynCall_viiifif = Module["dynCall_viiifif"] = Module["asm"]["Y"]).apply(null, arguments);
};

var dynCall_vii = Module["dynCall_vii"] = function() {
 return (dynCall_vii = Module["dynCall_vii"] = Module["asm"]["Z"]).apply(null, arguments);
};

var dynCall_fi = Module["dynCall_fi"] = function() {
 return (dynCall_fi = Module["dynCall_fi"] = Module["asm"]["_"]).apply(null, arguments);
};

var dynCall_viii = Module["dynCall_viii"] = function() {
 return (dynCall_viii = Module["dynCall_viii"] = Module["asm"]["$"]).apply(null, arguments);
};

var dynCall_viff = Module["dynCall_viff"] = function() {
 return (dynCall_viff = Module["dynCall_viff"] = Module["asm"]["aa"]).apply(null, arguments);
};

var dynCall_viffffff = Module["dynCall_viffffff"] = function() {
 return (dynCall_viffffff = Module["dynCall_viffffff"] = Module["asm"]["ba"]).apply(null, arguments);
};

var dynCall_viiiii = Module["dynCall_viiiii"] = function() {
 return (dynCall_viiiii = Module["dynCall_viiiii"] = Module["asm"]["ca"]).apply(null, arguments);
};

var dynCall_fii = Module["dynCall_fii"] = function() {
 return (dynCall_fii = Module["dynCall_fii"] = Module["asm"]["da"]).apply(null, arguments);
};

var dynCall_iid = Module["dynCall_iid"] = function() {
 return (dynCall_iid = Module["dynCall_iid"] = Module["asm"]["ea"]).apply(null, arguments);
};

var dynCall_vif = Module["dynCall_vif"] = function() {
 return (dynCall_vif = Module["dynCall_vif"] = Module["asm"]["fa"]).apply(null, arguments);
};

var dynCall_viif = Module["dynCall_viif"] = function() {
 return (dynCall_viif = Module["dynCall_viif"] = Module["asm"]["ga"]).apply(null, arguments);
};

var dynCall_viiff = Module["dynCall_viiff"] = function() {
 return (dynCall_viiff = Module["dynCall_viiff"] = Module["asm"]["ha"]).apply(null, arguments);
};

var dynCall_iif = Module["dynCall_iif"] = function() {
 return (dynCall_iif = Module["dynCall_iif"] = Module["asm"]["ia"]).apply(null, arguments);
};

var dynCall_viiii = Module["dynCall_viiii"] = function() {
 return (dynCall_viiii = Module["dynCall_viiii"] = Module["asm"]["ja"]).apply(null, arguments);
};

var dynCall_viiiiii = Module["dynCall_viiiiii"] = function() {
 return (dynCall_viiiiii = Module["dynCall_viiiiii"] = Module["asm"]["ka"]).apply(null, arguments);
};

var dynCall_viiffffff = Module["dynCall_viiffffff"] = function() {
 return (dynCall_viiffffff = Module["dynCall_viiffffff"] = Module["asm"]["la"]).apply(null, arguments);
};

var dynCall_viiffff = Module["dynCall_viiffff"] = function() {
 return (dynCall_viiffff = Module["dynCall_viiffff"] = Module["asm"]["ma"]).apply(null, arguments);
};

var dynCall_iiid = Module["dynCall_iiid"] = function() {
 return (dynCall_iiid = Module["dynCall_iiid"] = Module["asm"]["na"]).apply(null, arguments);
};

var dynCall_viiiff = Module["dynCall_viiiff"] = function() {
 return (dynCall_viiiff = Module["dynCall_viiiff"] = Module["asm"]["oa"]).apply(null, arguments);
};

var dynCall_iiif = Module["dynCall_iiif"] = function() {
 return (dynCall_iiif = Module["dynCall_iiif"] = Module["asm"]["pa"]).apply(null, arguments);
};

var dynCall_i = Module["dynCall_i"] = function() {
 return (dynCall_i = Module["dynCall_i"] = Module["asm"]["qa"]).apply(null, arguments);
};

var dynCall_viffff = Module["dynCall_viffff"] = function() {
 return (dynCall_viffff = Module["dynCall_viffff"] = Module["asm"]["ra"]).apply(null, arguments);
};

var dynCall_jiji = Module["dynCall_jiji"] = function() {
 return (dynCall_jiji = Module["dynCall_jiji"] = Module["asm"]["sa"]).apply(null, arguments);
};

var dynCall_iidiiii = Module["dynCall_iidiiii"] = function() {
 return (dynCall_iidiiii = Module["dynCall_iidiiii"] = Module["asm"]["ta"]).apply(null, arguments);
};

var calledRun;

function ExitStatus(status) {
 this.name = "ExitStatus";
 this.message = "Program terminated with exit(" + status + ")";
 this.status = status;
}

dependenciesFulfilled = function runCaller() {
 if (!calledRun) run();
 if (!calledRun) dependenciesFulfilled = runCaller;
};

function run(args) {
 args = args || arguments_;
 if (runDependencies > 0) {
  return;
 }
 preRun();
 if (runDependencies > 0) return;
 function doRun() {
  if (calledRun) return;
  calledRun = true;
  Module["calledRun"] = true;
  if (ABORT) return;
  initRuntime();
  preMain();
  readyPromiseResolve(Module);
  if (Module["onRuntimeInitialized"]) Module["onRuntimeInitialized"]();
  postRun();
 }
 if (Module["setStatus"]) {
  Module["setStatus"]("Running...");
  setTimeout(function() {
   setTimeout(function() {
    Module["setStatus"]("");
   }, 1);
   doRun();
  }, 1);
 } else {
  doRun();
 }
}

Module["run"] = run;

if (Module["preInit"]) {
 if (typeof Module["preInit"] == "function") Module["preInit"] = [ Module["preInit"] ];
 while (Module["preInit"].length > 0) {
  Module["preInit"].pop()();
 }
}

noExitRuntime = true;

run();

function makeMatrix(m2d) {
    const m = new DOMMatrix();
    m.a = m2d.xx;
    m.b = m2d.xy;
    m.c = m2d.yx;
    m.d = m2d.yy;
    m.e = m2d.tx;
    m.f = m2d.ty;
    return m;
}

Module.onRuntimeInitialized = function () {
    const {
        RenderPaintStyle,
        FillRule,
        RenderPath,
        RenderPaint,
        Renderer,
        StrokeCap,
        StrokeJoin,
        BlendMode
    } = Module;

    const {
        fill,
        stroke
    } = RenderPaintStyle;

    const {
        evenOdd,
        nonZero
    } = FillRule;

    var CanvasRenderPath = RenderPath.extend("CanvasRenderPath", {
        __construct: function () {
            this.__parent.__construct.call(this);
            this._path2D = new Path2D();
        },
        reset: function () {
            this._path2D = new Path2D();
        },
        addPath: function (path, m2d) {
            this._path2D.addPath(path._path2D, makeMatrix(m2d));
        },
        fillRule: function(fillRule) {
            this._fillRule = fillRule;
        },
        moveTo: function (x, y) {
            this._path2D.moveTo(x, y);
        },
        lineTo: function (x, y) {
            this._path2D.lineTo(x, y);
        },
        cubicTo: function (ox, oy, ix, iy, x, y) {
            this._path2D.bezierCurveTo(ox, oy, ix, iy, x, y);
        },
        close: function () {
            this._path2D.closePath();
        }
    });

    function _colorStyle(value) {
        return 'rgba(' + ((0x00ff0000 & value) >>>
                16) + ',' + ((0x0000ff00 &
                value) >>> 8) + ',' + ((0x000000ff & value) >>> 0) + ',' +
            (((0xff000000 & value) >>> 24) / 0xFF) + ')'
    }
    var CanvasRenderPaint = RenderPaint.extend("CanvasRenderPaint", {
        color: function (value) {
            this._value = _colorStyle(value);
        },
        thickness: function (value) {
            this._thickness = value;
        },
        join: function (value) {
            switch (value) {
                case StrokeJoin.miter:
                    this._join = 'miter';
                    break;
                case StrokeJoin.round:
                    this._join = 'round';
                    break;
                case StrokeJoin.bevel:
                    this._join = 'bevel';
                    break;
            }
        },
        cap: function (value) {
            switch (value) {
                case StrokeCap.butt:
                    this._cap = 'butt';
                    break;
                case StrokeCap.round:
                    this._cap = 'round';
                    break;
                case StrokeCap.square:
                    this._cap = 'square';
                    break;
            }
        },
        style: function (value) {
            this._style = value;
        },
        blendMode: function (value) {
            switch (value) {
                case BlendMode.srcOver:
                    this._blend = 'source-over';
                    break;
                case BlendMode.screen:
                    this._blend = 'screen';
                    break;
                case BlendMode.overlay:
                    this._blend = 'overlay';
                    break;
                case BlendMode.darken:
                    this._blend = 'darken';
                    break;
                case BlendMode.lighten:
                    this._blend = 'lighten';
                    break;
                case BlendMode.colorDodge:
                    this._blend = 'color-dodge';
                    break;
                case BlendMode.colorBurn:
                    this._blend = 'color-burn';
                    break;
                case BlendMode.hardLight:
                    this._blend = 'hard-light';
                    break;
                case BlendMode.softLight:
                    this._blend = 'soft-light';
                    break;
                case BlendMode.difference:
                    this._blend = 'difference';
                    break;
                case BlendMode.exclusion:
                    this._blend = 'exclusion';
                    break;
                case BlendMode.multiply:
                    this._blend = 'multiply';
                    break;
                case BlendMode.hue:
                    this._blend = 'hue';
                    break;
                case BlendMode.saturation:
                    this._blend = 'saturation';
                    break;
                case BlendMode.color:
                    this._blend = 'color';
                    break;
                case BlendMode.luminosity:
                    this._blend = 'luminosity';
                    break;
            }
        },
        linearGradient: function (sx, sy, ex, ey) {
            this._gradient = {
                sx,
                sy,
                ex,
                ey,
                stops: []
            };
        },
        radialGradient: function (sx, sy, ex, ey) {
            this._gradient = {
                sx,
                sy,
                ex,
                ey,
                stops: [],
                isRadial: true
            };
        },
        addStop: function (color, stop) {
            this._gradient.stops.push({
                color,
                stop
            });
        },

        completeGradient: function () {

        },

        draw: function (ctx, path) {
            let {
                _style,
                _value,
                _gradient,
                _blend
            } = this;

            ctx.globalCompositeOperation = _blend;

            if (_gradient != null) {
                const {
                    sx,
                    sy,
                    ex,
                    ey,
                    stops,
                    isRadial
                } = _gradient;

                if (isRadial) {
                    var dx = ex - sx;
                    var dy = ey - sy;
                    var radius = Math.sqrt(dx * dx + dy * dy);
                    _value = ctx.createRadialGradient(sx, sy, 0, sx, sy, radius);
                } else {
                    _value = ctx.createLinearGradient(sx, sy, ex, ey);
                }

                for (const {
                        stop,
                        color
                    } of stops) {
                    _value.addColorStop(stop, _colorStyle(color));
                }
                this._value = _value;
                this._gradient = null;
            }
            switch (_style) {
                case stroke:
                    ctx.strokeStyle = _value;
                    ctx.lineWidth = this._thickness;
                    ctx.lineCap = this._cap;
                    ctx.lineJoin = this._join;
                    ctx.stroke(path._path2D);
                    break;
                case fill:
                    ctx.fillStyle = _value;
                    ctx.fill(path._path2D, path._fillRule === evenOdd ? 'evenodd' : 'nonzero');
                    break;
            }
        }
    });

    Module.CanvasRenderer = Renderer.extend("Renderer", {
        __construct: function (ctx) {
            this.__parent.__construct.call(this);
            this._ctx = ctx;
        },
        save: function () {
            this._ctx.save();
        },
        restore: function () {
            this._ctx.restore();
        },
        transform: function (matrix) {
            this._ctx.transform(matrix.xx, matrix.xy, matrix.yx, matrix.yy, matrix.tx,
                matrix.ty);
        },
        drawPath: function (path, paint) {
            paint.draw(this._ctx, path);
        },
        clipPath: function (path) {
            this._ctx.clip(path._path2D, path._fillRule === evenOdd ? 'evenodd' : 'nonzero');
        }
    });

    Module.renderFactory = {
        makeRenderPaint: function () {
            return new CanvasRenderPaint();
        },
        makeRenderPath: function () {
            return new CanvasRenderPath();
        }
    };
};


  return Rive.ready
}
);
})();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Rive);


/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Fit": () => (/* binding */ Fit),
/* harmony export */   "Alignment": () => (/* binding */ Alignment),
/* harmony export */   "Layout": () => (/* binding */ Layout),
/* harmony export */   "RuntimeLoader": () => (/* binding */ RuntimeLoader),
/* harmony export */   "StateMachineInputType": () => (/* binding */ StateMachineInputType),
/* harmony export */   "EventType": () => (/* binding */ EventType),
/* harmony export */   "LoopType": () => (/* binding */ LoopType),
/* harmony export */   "Rive": () => (/* binding */ Rive),
/* harmony export */   "Testing": () => (/* binding */ Testing)
/* harmony export */ });
/* harmony import */ var rive_canvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};

// Tracks playback states; numbers map to the runtime's numerical values
// i.e. play: 0, pause: 1, stop: 2
var PlaybackState;
(function (PlaybackState) {
    PlaybackState[PlaybackState["Play"] = 0] = "Play";
    PlaybackState[PlaybackState["Pause"] = 1] = "Pause";
    PlaybackState[PlaybackState["Stop"] = 2] = "Stop";
})(PlaybackState || (PlaybackState = {}));
// #region layout
// Fit options for the canvas
var Fit;
(function (Fit) {
    Fit["Cover"] = "cover";
    Fit["Contain"] = "contain";
    Fit["Fill"] = "fill";
    Fit["FitWidth"] = "fitWidth";
    Fit["FitHeight"] = "fitHeight";
    Fit["None"] = "none";
    Fit["ScaleDown"] = "scaleDown";
})(Fit || (Fit = {}));
// Alignment options for the canvas
var Alignment;
(function (Alignment) {
    Alignment["Center"] = "center";
    Alignment["TopLeft"] = "topLeft";
    Alignment["TopCenter"] = "topCenter";
    Alignment["TopRight"] = "topRight";
    Alignment["CenterLeft"] = "centerLeft";
    Alignment["CenterRight"] = "centerRight";
    Alignment["BottomLeft"] = "bottomLeft";
    Alignment["BottomCenter"] = "bottomCenter";
    Alignment["BottomRight"] = "bottomRight";
})(Alignment || (Alignment = {}));
// Alignment options for Rive animations in a HTML canvas
var Layout = /** @class */ (function () {
    function Layout(params) {
        var _a, _b, _c, _d, _e, _f;
        this.fit = (_a = params === null || params === void 0 ? void 0 : params.fit) !== null && _a !== void 0 ? _a : Fit.Contain;
        this.alignment = (_b = params === null || params === void 0 ? void 0 : params.alignment) !== null && _b !== void 0 ? _b : Alignment.Center;
        this.minX = (_c = params === null || params === void 0 ? void 0 : params.minX) !== null && _c !== void 0 ? _c : 0;
        this.minY = (_d = params === null || params === void 0 ? void 0 : params.minY) !== null && _d !== void 0 ? _d : 0;
        this.maxX = (_e = params === null || params === void 0 ? void 0 : params.maxX) !== null && _e !== void 0 ? _e : 0;
        this.maxY = (_f = params === null || params === void 0 ? void 0 : params.maxY) !== null && _f !== void 0 ? _f : 0;
    }
    // Alternative constructor to build a Layout from an interface/object
    Layout.new = function (_a) {
        var fit = _a.fit, alignment = _a.alignment, minX = _a.minX, minY = _a.minY, maxX = _a.maxX, maxY = _a.maxY;
        console.warn('This function is deprecated: please use `new Layout({})` instead');
        return new Layout({ fit: fit, alignment: alignment, minX: minX, minY: minY, maxX: maxX, maxY: maxY });
    };
    /**
     * Makes a copy of the layout, replacing any specified parameters
     */
    Layout.prototype.copyWith = function (_a) {
        var fit = _a.fit, alignment = _a.alignment, minX = _a.minX, minY = _a.minY, maxX = _a.maxX, maxY = _a.maxY;
        return new Layout({
            fit: fit !== null && fit !== void 0 ? fit : this.fit,
            alignment: alignment !== null && alignment !== void 0 ? alignment : this.alignment,
            minX: minX !== null && minX !== void 0 ? minX : this.minX,
            minY: minY !== null && minY !== void 0 ? minY : this.minY,
            maxX: maxX !== null && maxX !== void 0 ? maxX : this.maxX,
            maxY: maxY !== null && maxY !== void 0 ? maxY : this.maxY
        });
    };
    // Returns fit for the Wasm runtime format
    Layout.prototype.runtimeFit = function (rive) {
        if (this.cachedRuntimeFit)
            return this.cachedRuntimeFit;
        var fit;
        if (this.fit === Fit.Cover)
            fit = rive.Fit.cover;
        else if (this.fit === Fit.Contain)
            fit = rive.Fit.contain;
        else if (this.fit === Fit.Fill)
            fit = rive.Fit.fill;
        else if (this.fit === Fit.FitWidth)
            fit = rive.Fit.fitWidth;
        else if (this.fit === Fit.FitHeight)
            fit = rive.Fit.fitHeight;
        else if (this.fit === Fit.ScaleDown)
            fit = rive.Fit.scaleDown;
        else
            fit = rive.Fit.none;
        this.cachedRuntimeFit = fit;
        return fit;
    };
    // Returns alignment for the Wasm runtime format
    Layout.prototype.runtimeAlignment = function (rive) {
        if (this.cachedRuntimeAlignment)
            return this.cachedRuntimeAlignment;
        var alignment;
        if (this.alignment === Alignment.TopLeft)
            alignment = rive.Alignment.topLeft;
        else if (this.alignment === Alignment.TopCenter)
            alignment = rive.Alignment.topCenter;
        else if (this.alignment === Alignment.TopRight)
            alignment = rive.Alignment.topRight;
        else if (this.alignment === Alignment.CenterLeft)
            alignment = rive.Alignment.centerLeft;
        else if (this.alignment === Alignment.CenterRight)
            alignment = rive.Alignment.centerRight;
        else if (this.alignment === Alignment.BottomLeft)
            alignment = rive.Alignment.bottomLeft;
        else if (this.alignment === Alignment.BottomCenter)
            alignment = rive.Alignment.bottomCenter;
        else if (this.alignment === Alignment.BottomRight)
            alignment = rive.Alignment.bottomRight;
        else
            alignment = rive.Alignment.center;
        this.cachedRuntimeAlignment = alignment;
        return alignment;
    };
    return Layout;
}());

// Runtime singleton; use getInstance to provide a callback that returns the
// Rive runtime
var RuntimeLoader = /** @class */ (function () {
    // Class is never instantiated
    function RuntimeLoader() {
    }
    // Loads the runtime
    RuntimeLoader.loadRuntime = function () {
        rive_canvas__WEBPACK_IMPORTED_MODULE_0__.default({
            // Loads Wasm bundle
            locateFile: function (file) {
                // if in test mode, attempts to load file locally 
                return (RuntimeLoader.testMode ?
                    RuntimeLoader.wasmFilePath :
                    RuntimeLoader.wasmWebPath) + file;
            }
        }).then(function (rive) {
            var _a;
            RuntimeLoader.runtime = rive;
            // Fire all the callbacks
            while (RuntimeLoader.callBackQueue.length > 0) {
                (_a = RuntimeLoader.callBackQueue.shift()) === null || _a === void 0 ? void 0 : _a(RuntimeLoader.runtime);
            }
        });
    };
    // Provides a runtime instance via a callback
    RuntimeLoader.getInstance = function (callback) {
        // If it's not loading, start loading runtime
        if (!RuntimeLoader.isLoading) {
            RuntimeLoader.isLoading = true;
            RuntimeLoader.loadRuntime();
        }
        if (!RuntimeLoader.runtime) {
            RuntimeLoader.callBackQueue.push(callback);
        }
        else {
            callback(RuntimeLoader.runtime);
        }
    };
    // Provides a runtime instance via a promise
    RuntimeLoader.awaitInstance = function () {
        return new Promise(function (resolve, reject) {
            return RuntimeLoader.getInstance(function (rive) { return resolve(rive); });
        });
    };
    // Places the loader in test mode
    RuntimeLoader.setTestMode = function (mode) {
        RuntimeLoader.testMode = mode;
    };
    // Flag to indicate that loading has started/completed
    RuntimeLoader.isLoading = false;
    // List of callbacks for the runtime that come in while loading
    RuntimeLoader.callBackQueue = [];
    // The url for the Wasm file
    RuntimeLoader.wasmWebPath = 'file://';
    // Local path to the Wasm file; for testing purposes
    RuntimeLoader.wasmFilePath = 'dist/';
    // Are we in test mode?
    RuntimeLoader.testMode = false;
    return RuntimeLoader;
}());

// #endregion
// #region animations
// Wraps animations and instances from the runtime and keeps track of playback
// state
var Animation = /** @class */ (function () {
    /**
     * Constructs a new animation
     * @constructor
     * @param {any} animation: runtime animation object
     * @param {any} instance: runtime animation instance object
     */
    function Animation(animation, runtime, playing) {
        this.animation = animation;
        this.playing = playing;
        this.loopCount = 0;
        this.instance = new runtime.LinearAnimationInstance(animation);
    }
    Object.defineProperty(Animation.prototype, "name", {
        // Returns the animation's name
        get: function () {
            return this.animation.name;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Animation.prototype, "loopValue", {
        // Returns the animation's loop type
        get: function () {
            return this.animation.loopValue;
        },
        enumerable: false,
        configurable: true
    });
    return Animation;
}());
// #endregion
// #region state machines
var StateMachineInputType;
(function (StateMachineInputType) {
    StateMachineInputType[StateMachineInputType["Number"] = 56] = "Number";
    StateMachineInputType[StateMachineInputType["Trigger"] = 58] = "Trigger";
    StateMachineInputType[StateMachineInputType["Boolean"] = 59] = "Boolean";
})(StateMachineInputType || (StateMachineInputType = {}));
/**
 * An input for a state machine
 */
var StateMachineInput = /** @class */ (function () {
    function StateMachineInput(type, runtimeInput) {
        this.type = type;
        this.runtimeInput = runtimeInput;
    }
    Object.defineProperty(StateMachineInput.prototype, "name", {
        /**
         * Returns the name of the input
         */
        get: function () {
            return this.runtimeInput.name;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StateMachineInput.prototype, "value", {
        /**
         * Returns the current value of the input
         */
        get: function () {
            return this.runtimeInput.value;
        },
        /**
         * Sets the value of the input
         */
        set: function (value) {
            this.runtimeInput.value = value;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Fires a trigger; does nothing on Number or Boolean input types
     */
    StateMachineInput.prototype.fire = function () {
        if (this.type === StateMachineInputType.Trigger) {
            this.runtimeInput.fire();
        }
    };
    return StateMachineInput;
}());
var StateMachine = /** @class */ (function () {
    /**
     * @constructor
     * @param stateMachine runtime state machine object
     * @param instance runtime state machine instance object
     */
    function StateMachine(stateMachine, runtime, playing) {
        this.stateMachine = stateMachine;
        this.playing = playing;
        /**
         * Caches the inputs from the runtime
         */
        this.inputs = [];
        this.instance = new runtime.StateMachineInstance(stateMachine);
        this.initInputs(runtime);
    }
    Object.defineProperty(StateMachine.prototype, "name", {
        get: function () {
            return this.stateMachine.name;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Fetches references to the state amchine's inputs and caches them
     * @param runtime an instance of the runtime; needed for the SMIInput types
     */
    StateMachine.prototype.initInputs = function (runtime) {
        // Fetch the inputs from the runtime if we don't have them
        for (var i = 0; i < this.instance.inputCount(); i++) {
            var input = this.instance.input(i);
            this.inputs.push(this.mapRuntimeInput(input, runtime));
        }
    };
    /**
     * Maps a runtime input to it's appropriate type
     * @param input
     */
    StateMachine.prototype.mapRuntimeInput = function (input, runtime) {
        if (input.type === runtime.SMIInput.bool) {
            return new StateMachineInput(StateMachineInputType.Boolean, input.asBool());
        }
        else if (input.type === runtime.SMIInput.number) {
            return new StateMachineInput(StateMachineInputType.Number, input.asNumber());
        }
        else if (input.type === runtime.SMIInput.trigger) {
            return new StateMachineInput(StateMachineInputType.Trigger, input.asTrigger());
        }
    };
    return StateMachine;
}());
// #endregion
// #region animator
/**
 * Manages animation
 */
var Animator = /** @class */ (function () {
    /**
     * Constructs a new animator
     * @constructor
     * @param runtime Rive runtime; needed to instance animations & state machines
     * @param artboard the artboard that holds all animations and state machines
     * @param animations optional list of animations
     * @param stateMachines optional list of state machines
     */
    function Animator(runtime, artboard, eventManager, animations, stateMachines) {
        if (animations === void 0) { animations = []; }
        if (stateMachines === void 0) { stateMachines = []; }
        this.runtime = runtime;
        this.artboard = artboard;
        this.eventManager = eventManager;
        this.animations = animations;
        this.stateMachines = stateMachines;
    }
    /**
     * Adds animations and state machines by their names. If names are shared
     * between animations & state machines, then the first one found wiil be
     * created. Best not to use the same names for these in your Rive file.
     * @param animatable the name(s) of animations and state machines to add
     * @returns a list of names of the playing animations and state machines
     */
    Animator.prototype.add = function (animatables, playing, fireEvent) {
        if (fireEvent === void 0) { fireEvent = true; }
        animatables = mapToStringArray(animatables);
        // If animatables is empty, play or pause everything
        if (animatables.length === 0) {
            this.animations.forEach(function (a) { return a.playing = playing; });
            this.stateMachines.forEach(function (m) { return m.playing = playing; });
        }
        else {
            // Play/pause already instanced items, or create new instances
            var instancedAnimationNames = this.animations.map(function (a) { return a.name; });
            var instancedMachineNames = this.stateMachines.map(function (m) { return m.name; });
            for (var i in animatables) {
                var aIndex = instancedAnimationNames.indexOf(animatables[i]);
                var mIndex = instancedMachineNames.indexOf(animatables[i]);
                if (aIndex >= 0 || mIndex >= 0) {
                    if (aIndex >= 0) {
                        // Animation is instanced, play/pause it
                        this.animations[aIndex].playing = playing;
                    }
                    else {
                        // State machine is instanced, play/pause it
                        this.stateMachines[mIndex].playing = playing;
                    }
                }
                else {
                    // Try to create a new animation instance
                    var anim = this.artboard.animationByName(animatables[i]);
                    if (anim) {
                        this.animations.push(new Animation(anim, this.runtime, playing));
                    }
                    else {
                        // Try to create a new state machine instance
                        var sm = this.artboard.stateMachineByName(animatables[i]);
                        if (sm) {
                            this.stateMachines.push(new StateMachine(sm, this.runtime, playing));
                        }
                    }
                }
            }
        }
        // Fire play/paused events for animations
        if (fireEvent) {
            if (playing) {
                this.eventManager.fire({
                    type: EventType.Play,
                    data: this.playing,
                });
            }
            else {
                this.eventManager.fire({
                    type: EventType.Pause,
                    data: this.paused,
                });
            }
        }
        return playing ? this.playing : this.paused;
    };
    /**
     * Play the named animations/state machines
     * @param animatables the names of the animations/machines to play; plays all if empty
     * @returns a list of the playing items
     */
    Animator.prototype.play = function (animatables) {
        return this.add(animatables, true);
    };
    /**
   * Pauses named aninimations and state machines, or everything if nothing is
   * specified
   * @param animatables names of the animations and state machines to pause
   * @returns a list of names of the animations and state machines paused
   */
    Animator.prototype.pause = function (animatables) {
        return this.add(animatables, false);
    };
    Object.defineProperty(Animator.prototype, "playing", {
        /**
         * Returns a list of names of all animations and state machines currently
         * playing
         */
        get: function () {
            return this.animations.filter(function (a) { return a.playing; }).map(function (a) { return a.name; }).concat(this.stateMachines.filter(function (m) { return m.playing; }).map(function (m) { return m.name; }));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Animator.prototype, "paused", {
        /**
         * Returns a list of names of all animations and state machines currently
         * paused
         */
        get: function () {
            return this.animations.filter(function (a) { return !a.playing; }).map(function (a) { return a.name; }).concat(this.stateMachines.filter(function (m) { return !m.playing; }).map(function (m) { return m.name; }));
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Stops and removes all named animations and state machines
     * @param animatables animations and state machines to remove
     * @returns a list of names of removed items
     */
    Animator.prototype.stop = function (animatables) {
        var _this = this;
        animatables = mapToStringArray(animatables);
        // If nothing's specified, wipe them out, all of them
        var removedNames = [];
        if (animatables.length === 0) {
            removedNames = this.animations.map(function (a) { return a.name; }).concat(this.stateMachines.map(function (m) { return m.name; }));
            this.animations.splice(0, this.animations.length);
            this.stateMachines.splice(0, this.stateMachines.length);
        }
        else {
            // Remove only the named animations/state machines
            var animationsToRemove = this.animations.filter(function (a) { return animatables.includes(a.name); });
            animationsToRemove.forEach(function (a) {
                return _this.animations.splice(_this.animations.indexOf(a), 1);
            });
            var machinesToRemove = this.stateMachines.filter(function (m) { return animatables.includes(m.name); });
            machinesToRemove.forEach(function (m) {
                return _this.stateMachines.splice(_this.stateMachines.indexOf(m), 1);
            });
            removedNames = animationsToRemove.map(function (a) { return a.name; }).concat(machinesToRemove.map(function (m) { return m.name; }));
        }
        this.eventManager.fire({
            type: EventType.Stop,
            data: removedNames,
        });
        // Return the list of animations removed
        return removedNames;
    };
    Object.defineProperty(Animator.prototype, "isPlaying", {
        /**
         * Returns true if at least one animation is active
         */
        get: function () {
            return this.animations.reduce(function (acc, curr) { return acc || curr.playing; }, false)
                || this.stateMachines.reduce(function (acc, curr) { return acc || curr.playing; }, false);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Animator.prototype, "isPaused", {
        /**
         * Returns true if all animations are paused and there's at least one animation
         */
        get: function () {
            return !this.isPlaying &&
                (this.animations.length > 0 || this.stateMachines.length > 0);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Animator.prototype, "isStopped", {
        /**
         * Returns true if there are no playing or paused animations/state machines
         */
        get: function () {
            return this.animations.length === 0 && this.stateMachines.length === 0;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * If there are no animations or state machines, add the first one found
     * @returns the name of the animation or state machine instanced
     */
    Animator.prototype.atLeastOne = function (playing, fireEvent) {
        if (fireEvent === void 0) { fireEvent = true; }
        var instancedName;
        if (this.animations.length === 0 && this.stateMachines.length === 0) {
            if (this.artboard.animationCount() > 0) {
                // Add the first animation
                this.add([instancedName = this.artboard.animationByIndex(0).name], playing, fireEvent);
            }
            else if (this.artboard.stateMachineCount() > 0) {
                // Add the first state machine
                this.add([instancedName = this.artboard.stateMachineByIndex(0).name], playing, fireEvent);
            }
        }
        return instancedName;
    };
    /**
     * Checks if any animations have looped and if so, fire the appropriate event
     */
    Animator.prototype.handleLooping = function () {
        for (var _i = 0, _a = this.animations; _i < _a.length; _i++) {
            var animation = _a[_i];
            // Emit if the animation looped
            if (animation.loopValue === 0 && animation.loopCount) {
                animation.loopCount = 0;
                // This is a one-shot; if it has ended, delete the instance
                this.stop(animation.name);
            }
            else if (animation.loopValue === 1 && animation.loopCount) {
                this.eventManager.fire({
                    type: EventType.Loop,
                    data: { animation: animation.name, type: LoopType.Loop }
                });
                animation.loopCount = 0;
            }
            // Wasm indicates a loop at each time the animation
            // changes direction, so a full loop/lap occurs every
            // two loop counts
            else if (animation.loopValue === 2 && animation.loopCount > 1) {
                this.eventManager.fire({
                    type: EventType.Loop,
                    data: { animation: animation.name, type: LoopType.PingPong }
                });
                animation.loopCount = 0;
            }
        }
    };
    return Animator;
}());
// #endregion
// #region events
/**
 * Supported event types triggered in Rive
 */
var EventType;
(function (EventType) {
    EventType["Load"] = "load";
    EventType["LoadError"] = "loaderror";
    EventType["Play"] = "play";
    EventType["Pause"] = "pause";
    EventType["Stop"] = "stop";
    EventType["Loop"] = "loop";
    EventType["Draw"] = "draw";
})(EventType || (EventType = {}));
/**
 * Looping types: one-shot, loop, and ping-pong
 */
var LoopType;
(function (LoopType) {
    LoopType["OneShot"] = "oneshot";
    LoopType["Loop"] = "loop";
    LoopType["PingPong"] = "pingpong"; // has value 2 in runtime
})(LoopType || (LoopType = {}));
// Manages Rive events and listeners
var EventManager = /** @class */ (function () {
    function EventManager(listeners) {
        if (listeners === void 0) { listeners = []; }
        this.listeners = listeners;
    }
    // Gets listeners of specified type
    EventManager.prototype.getListeners = function (type) {
        return this.listeners.filter(function (e) { return e.type === type; });
    };
    // Adds a listener
    EventManager.prototype.add = function (listener) {
        if (!this.listeners.includes(listener)) {
            this.listeners.push(listener);
        }
    };
    /**
     * Removes a listener
     * @param listener the listener with the callback to be removed
     */
    EventManager.prototype.remove = function (listener) {
        // We can't simply look for the listener as it'll be a different instance to
        // one originally subscribed. Find all the listeners of the right type and
        // then check their callbacks which should match.
        for (var i = 0; i < this.listeners.length; i++) {
            var currentListener = this.listeners[i];
            if (currentListener.type === listener.type) {
                if (currentListener.callback === listener.callback) {
                    this.listeners.splice(i, 1);
                    break;
                }
            }
        }
    };
    /**
     * Clears all listeners of specified type, or every listener if no type is
     * specified
     * @param type the type of listeners to clear, or all listeners if not
     * specified
     */
    EventManager.prototype.removeAll = function (type) {
        var _this = this;
        if (!type) {
            this.listeners.splice(0, this.listeners.length);
        }
        else {
            this.listeners
                .filter(function (l) { return l.type === type; })
                .forEach(function (l) { return _this.remove(l); });
        }
    };
    // Fires an event
    EventManager.prototype.fire = function (event) {
        var eventListeners = this.getListeners(event.type);
        eventListeners.forEach(function (listener) { return listener.callback(event); });
    };
    return EventManager;
}());
// Manages a queue of tasks
var TaskQueueManager = /** @class */ (function () {
    function TaskQueueManager(eventManager) {
        this.eventManager = eventManager;
        this.queue = [];
    }
    // Adds a task top the queue
    TaskQueueManager.prototype.add = function (task) {
        this.queue.push(task);
    };
    // Processes all tasks in the queue
    TaskQueueManager.prototype.process = function () {
        while (this.queue.length > 0) {
            var task = this.queue.shift();
            task === null || task === void 0 ? void 0 : task.action();
            if (task === null || task === void 0 ? void 0 : task.event) {
                this.eventManager.fire(task.event);
            }
        }
    };
    return TaskQueueManager;
}());
var Rive = /** @class */ (function () {
    function Rive(params) {
        var _a;
        // Flag to indicate if the layout has changed; used by the renderer to know
        // when to align
        this._updateLayout = true;
        /**
         * Flag to active/deactivate renderer
         */
        this.isRendererActive = true;
        // Tracks if a Rive file is loaded
        this.loaded = false;
        /**
         * Tracks if a Rive file is loaded; we need this in addition to loaded as some
         * commands (e.g. contents) can be called as soon as the file is loaded.
         * However, playback commands need to be queued and run in order once initial
         * animations and autoplay has been sorted out. This applies to play, pause,
         * and start.
         */
        this.readyForPlaying = false;
        // Runtime artboard
        this.artboard = null;
        /**
         * Used be draw to track when a second of active rendering time has passed. Used for debugging purposes
         */
        this.renderSecondTimer = 0;
        this.canvas = params.canvas;
        this.src = params.src;
        this.buffer = params.buffer;
        this.layout = (_a = params.layout) !== null && _a !== void 0 ? _a : new Layout();
        this._updateLayout = true;
        // Fetch the 2d context from the canvas
        this.ctx = this.canvas.getContext('2d');
        // New event management system
        this.eventManager = new EventManager();
        if (params.onload)
            this.on(EventType.Load, params.onload);
        if (params.onloaderror)
            this.on(EventType.LoadError, params.onloaderror);
        if (params.onplay)
            this.on(EventType.Play, params.onplay);
        if (params.onpause)
            this.on(EventType.Pause, params.onpause);
        if (params.onstop)
            this.on(EventType.Stop, params.onstop);
        if (params.onloop)
            this.on(EventType.Loop, params.onloop);
        // Hook up the task queue
        this.taskQueue = new TaskQueueManager(this.eventManager);
        this.init({
            src: this.src,
            buffer: this.buffer,
            autoplay: params.autoplay,
            animations: params.animations,
            stateMachines: params.stateMachines,
            artboard: params.artboard
        });
    }
    // Alternative constructor to build a Rive instance from an interface/object
    Rive.new = function (params) {
        console.warn('This function is deprecated: please use `new Rive({})` instead');
        return new Rive(params);
    };
    // Initializes the Rive object either from constructor or load()
    Rive.prototype.init = function (_a) {
        var _this = this;
        var src = _a.src, buffer = _a.buffer, animations = _a.animations, stateMachines = _a.stateMachines, artboard = _a.artboard, _b = _a.autoplay, autoplay = _b === void 0 ? false : _b;
        this.src = src;
        this.buffer = buffer;
        // If no source file url specified, it's a bust
        if (!this.src && !this.buffer) {
            throw new Error(Rive.missingErrorMessage);
        }
        // List of animations that should be initialized.
        var startingAnimationNames = mapToStringArray(animations);
        // List of state machines that should be initialized
        var startingStateMachineNames = mapToStringArray(stateMachines);
        // Ensure loaded is marked as false if loading new file
        this.loaded = false;
        this.readyForPlaying = false;
        // Ensure the runtime is loaded
        RuntimeLoader.awaitInstance().then(function (runtime) {
            _this.runtime = runtime;
            // Load Rive data from a source uri or a data buffer
            _this.initData(artboard, startingAnimationNames, startingStateMachineNames, autoplay).catch(function (e) {
                console.error(e);
            });
        }).catch(function (e) {
            console.error(e);
        });
    };
    // Initializes runtime with Rive data and preps for playing
    Rive.prototype.initData = function (artboardName, animationNames, stateMachineNames, autoplay) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var _b, _c, msg;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (!this.src) return [3 /*break*/, 2];
                        _b = this;
                        return [4 /*yield*/, loadRiveFile(this.src)];
                    case 1:
                        _b.buffer = _d.sent();
                        _d.label = 2;
                    case 2:
                        // Load the Rive file
                        _c = this;
                        return [4 /*yield*/, this.runtime.load(new Uint8Array(this.buffer))];
                    case 3:
                        // Load the Rive file
                        _c.file = _d.sent();
                        if (this.file) {
                            // Initialize and draw frame
                            this.initArtboard(artboardName, animationNames, stateMachineNames, autoplay);
                            // Everything's set up, emit a load event
                            this.loaded = true;
                            this.eventManager.fire({
                                type: EventType.Load,
                                data: (_a = this.src) !== null && _a !== void 0 ? _a : 'buffer'
                            });
                            // Flag ready for playback commands and clear the task queue; this order
                            // is important or it may infinitely recurse
                            this.readyForPlaying = true;
                            this.taskQueue.process();
                            this.drawFrame();
                            return [2 /*return*/, Promise.resolve()];
                        }
                        else {
                            msg = 'Problem loading file; may be corrupt!';
                            console.warn(msg);
                            this.eventManager.fire({ type: EventType.LoadError, data: msg });
                            return [2 /*return*/, Promise.reject(msg)];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    // Initialize for playback
    Rive.prototype.initArtboard = function (artboardName, animationNames, stateMachineNames, autoplay) {
        this.artboard = artboardName ?
            this.file.artboardByName(artboardName) :
            this.file.defaultArtboard();
        if (!this.artboard) {
            var msg = 'Invalid artboard name or no default artboard';
            console.warn(msg);
            this.eventManager.fire({ type: EventType.LoadError, data: msg });
            return;
        }
        // Check that the artboard has at least 1 animation
        if (this.artboard.animationCount() < 1) {
            var msg = 'Artboard has no animations';
            this.eventManager.fire({ type: EventType.LoadError, data: msg });
            throw msg;
        }
        // Initialize the animator
        this.animator = new Animator(this.runtime, this.artboard, this.eventManager);
        // Get the canvas where you want to render the animation and create a renderer
        this.renderer = new this.runtime.CanvasRenderer(this.ctx);
        // Initialize the animations; as loaded hasn't happened yet, we need to
        // suppress firing the play/pause events until the load event has fired. To
        // do this we tell the animator to suppress firing events, and add event
        // firing to the task queue.
        var instanceNames;
        if (animationNames.length > 0 || stateMachineNames.length > 0) {
            instanceNames = animationNames.concat(stateMachineNames);
            this.animator.add(instanceNames, autoplay, false);
        }
        else {
            instanceNames = [this.animator.atLeastOne(autoplay, false)];
        }
        // Queue up firing the playback events
        this.taskQueue.add({
            action: function () { },
            event: {
                type: autoplay ? EventType.Play : EventType.Pause,
                data: instanceNames,
            }
        });
    };
    // Draws the current artboard frame
    Rive.prototype.drawFrame = function () {
        this.startRendering();
    };
    /**
     * Draw rendering loop; renders animation frames at the correct time interval.
     * @param time the time at which to render a frame
     */
    Rive.prototype.draw = function (time, onSecond) {
        // Clear the frameRequestId, as we're now rendering a fresh frame
        this.frameRequestId = null;
        // On the first pass, make sure lastTime has a valid value
        if (!this.lastRenderTime) {
            this.lastRenderTime = time;
        }
        // Handle the onSecond callback
        this.renderSecondTimer += (time - this.lastRenderTime);
        if (this.renderSecondTimer > 5000) {
            this.renderSecondTimer = 0;
            onSecond === null || onSecond === void 0 ? void 0 : onSecond();
        }
        // Calculate the elapsed time between frames in seconds
        var elapsedTime = (time - this.lastRenderTime) / 1000;
        this.lastRenderTime = time;
        // Advance non-paused animations by the elapsed number of seconds
        var activeAnimations = this.animator.animations.filter(function (a) { return a.playing; });
        for (var _i = 0, activeAnimations_1 = activeAnimations; _i < activeAnimations_1.length; _i++) {
            var animation = activeAnimations_1[_i];
            animation.instance.advance(elapsedTime);
            if (animation.instance.didLoop) {
                animation.loopCount += 1;
            }
            animation.instance.apply(this.artboard, 1.0);
        }
        // Advance non-paused state machines by the elapsed number of seconds
        var activeStateMachines = this.animator.stateMachines.filter(function (a) { return a.playing; });
        for (var _a = 0, activeStateMachines_1 = activeStateMachines; _a < activeStateMachines_1.length; _a++) {
            var stateMachine = activeStateMachines_1[_a];
            stateMachine.instance.advance(elapsedTime);
            stateMachine.instance.apply(this.artboard);
        }
        // Once the animations have been applied to the artboard, advance it
        // by the elapsed time.
        this.artboard.advance(elapsedTime);
        // Update the renderer alignment if necessary
        this.alignRenderer();
        var bounds = this.artboard.bounds;
        this.ctx.clearRect(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
        this.artboard.draw(this.renderer);
        this.animator.handleLooping();
        // Calling requestAnimationFrame will rerun draw() at the correct rate:
        // https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Basic_animations
        if (this.animator.isPlaying) {
            // Request a new rendering frame
            this.startRendering();
        }
        else if (this.animator.isPaused) {
            // Reset the end time so on playback it starts at the correct frame
            this.lastRenderTime = 0;
        }
        else if (this.animator.isStopped) {
            // Reset animation instances, artboard and time
            // TODO: implement this properly when we have instancing
            // this.initArtboard();
            // this.drawFrame();
            this.lastRenderTime = 0;
        }
    };
    /**
     * Align the renderer
     */
    Rive.prototype.alignRenderer = function () {
        // Update the renderer alignment if necessary
        if (this._updateLayout) {
            // Restore from previous save in case a previous align occurred
            this.ctx.restore();
            // Canvas must be wiped to prevent artifacts
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            // Now save so that future changes to align can restore
            this.ctx.save();
            // Align things up safe in the knowledge we can restore if changed
            this.renderer.align(this._layout.runtimeFit(this.runtime), this._layout.runtimeAlignment(this.runtime), {
                minX: this._layout.minX,
                minY: this._layout.minY,
                maxX: this._layout.maxX,
                maxY: this._layout.maxY
            }, this.artboard.bounds);
            this._updateLayout = false;
        }
    };
    // Plays specified animations; if none specified, it unpauses everything.
    Rive.prototype.play = function (animationNames, autoplay) {
        var _this = this;
        animationNames = mapToStringArray(animationNames);
        // If the file's not loaded, queue up the play
        if (!this.readyForPlaying) {
            this.taskQueue.add({
                action: function () { return _this.play(animationNames, autoplay); },
            });
            return;
        }
        this.animator.play(animationNames);
        this.startRendering();
    };
    // Pauses specified animations; if none specified, pauses all.
    Rive.prototype.pause = function (animationNames) {
        var _this = this;
        animationNames = mapToStringArray(animationNames);
        // If the file's not loaded, early out, nothing to pause
        if (!this.readyForPlaying) {
            this.taskQueue.add({
                action: function () { return _this.pause(animationNames); },
            });
            return;
        }
        this.animator.pause(animationNames);
    };
    // Stops specified animations; if none specifies, stops them all.
    Rive.prototype.stop = function (animationNames) {
        var _this = this;
        animationNames = mapToStringArray(animationNames);
        // If the file's not loaded, early out, nothing to pause
        if (!this.readyForPlaying) {
            this.taskQueue.add({
                action: function () { return _this.stop(animationNames); },
            });
            return;
        }
        this.animator.stop(animationNames);
    };
    // Loads a new Rive file, keeping listeners in place
    Rive.prototype.load = function (params) {
        // Stop all animations
        this.stop();
        // Update the layout to account for new renderer
        this._updateLayout = true;
        // Reinitialize
        this.init(params);
    };
    Object.defineProperty(Rive.prototype, "layout", {
        /**
         * Returns the current layout. Note that layout should be treated as
         * immutable. If you want to change the layout, create a new one use the
         * layout setter
         */
        get: function () {
            return this._layout;
        },
        // Sets a new layout
        set: function (layout) {
            this._layout = layout;
            this._updateLayout = true;
            // If the maxX or maxY are 0, then set them to the canvas width and height
            if (!layout.maxX || !layout.maxY) {
                this.resizeToCanvas();
            }
            if (this.loaded && !this.animator.isPlaying) {
                this.drawFrame();
            }
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Sets the layout bounds to the current canvas size; this is typically called
     * when the canvas is resized
     */
    Rive.prototype.resizeToCanvas = function () {
        this._layout = this.layout.copyWith({
            minX: 0,
            minY: 0,
            maxX: this.canvas.width,
            maxY: this.canvas.height
        });
        this._updateLayout = true;
    };
    Object.defineProperty(Rive.prototype, "source", {
        // Returns the animation source, which may be undefined
        get: function () {
            return this.src;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Rive.prototype, "animationNames", {
        // Returns a list of animation names on the chosen artboard
        get: function () {
            // If the file's not loaded, we got nothing to return
            if (!this.loaded) {
                return [];
            }
            var animationNames = [];
            for (var i = 0; i < this.artboard.animationCount(); i++) {
                animationNames.push(this.artboard.animationByIndex(i).name);
            }
            return animationNames;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Rive.prototype, "stateMachineNames", {
        /**
         * Returns a list of state machine names from the current artboard
         */
        get: function () {
            // If the file's not loaded, we got nothing to return
            if (!this.loaded) {
                return [];
            }
            var stateMachineNames = [];
            for (var i = 0; i < this.artboard.stateMachineCount(); i++) {
                stateMachineNames.push(this.artboard.stateMachineByIndex(i).name);
            }
            return stateMachineNames;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Returns the inputs for the specified instanced state machine, or an empty
     * list if the name is invalid or the state machine is not instanced
     * @param name the state machine name
     * @returns the inputs for the named state machine
     */
    Rive.prototype.stateMachineInputs = function (name) {
        // If the file's not loaded, early out, nothing to pause
        if (!this.loaded) {
            return;
        }
        var stateMachine = this.animator.stateMachines.find(function (m) { return m.name === name; });
        return stateMachine === null || stateMachine === void 0 ? void 0 : stateMachine.inputs;
    };
    Object.defineProperty(Rive.prototype, "playingStateMachineNames", {
        // Returns a list of playing machine names
        get: function () {
            // If the file's not loaded, we got nothing to return
            if (!this.loaded) {
                return [];
            }
            return this.animator.stateMachines
                .filter(function (m) { return m.playing; })
                .map(function (m) { return m.name; });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Rive.prototype, "playingAnimationNames", {
        // Returns a list of playing animation names
        get: function () {
            // If the file's not loaded, we got nothing to return
            if (!this.loaded) {
                return [];
            }
            return this.animator.animations
                .filter(function (a) { return a.playing; })
                .map(function (a) { return a.name; });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Rive.prototype, "pausedAnimationNames", {
        // Returns a list of paused animation names
        get: function () {
            // If the file's not loaded, we got nothing to return
            if (!this.loaded) {
                return [];
            }
            return this.animator.animations
                .filter(function (a) { return !a.playing; })
                .map(function (a) { return a.name; });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Rive.prototype, "pausedStateMachineNames", {
        /**
         *  Returns a list of paused machine names
         * @returns a list of state machine names that are paused
         */
        get: function () {
            // If the file's not loaded, we got nothing to return
            if (!this.loaded) {
                return [];
            }
            return this.animator.stateMachines
                .filter(function (m) { return !m.playing; })
                .map(function (m) { return m.name; });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Rive.prototype, "isPlaying", {
        // Returns true if playing
        get: function () {
            return this.animator.isPlaying;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Rive.prototype, "isPaused", {
        // Returns trus if all animations are paused
        get: function () {
            return this.animator.isPaused;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Rive.prototype, "isStopped", {
        // Returns true if all animations are stopped
        get: function () {
            return this.animator.isStopped;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Subscribe to Rive-generated events
     * @param type the type of event to subscribe to
     * @param callback callback to fire when the event occurs
     */
    Rive.prototype.on = function (type, callback) {
        this.eventManager.add({
            type: type,
            callback: callback,
        });
    };
    /**
     * Unsubscribes from a Rive-generated event
     * @param callback the callback to unsubscribe from
     */
    Rive.prototype.unsubscribe = function (type, callback) {
        this.eventManager.remove({
            type: type,
            callback: callback,
        });
    };
    /**
     * Unsubscribes all listeners from an event type, or everything if no type is
     * given
     * @param type the type of event to unsubscribe from, or all types if
     * undefined
     */
    Rive.prototype.unsubscribeAll = function (type) {
        this.eventManager.removeAll(type);
    };
    /**
     * Stops the rendering loop; this is different from pausing in that it doesn't
     * change the state of any animation. It stops rendering from occurring. This
     * is designed for situations such as when Rive isn't visible.
     *
     * The only way to start rendering again is to call `startRendering`/
     */
    Rive.prototype.stopRendering = function () {
        cancelAnimationFrame(this.frameRequestId);
        this.frameRequestId = null;
    };
    /**
     * Starts the rendering loop if it has been previously stopped. If the
     * renderer is already active, then this will have zero effect.
     */
    Rive.prototype.startRendering = function () {
        if (!this.frameRequestId) {
            this.frameRequestId = requestAnimationFrame(this.draw.bind(this));
        }
    };
    Object.defineProperty(Rive.prototype, "contents", {
        /**
         * Returns the contents of a Rive file: the artboards, animations, and state machines
         */
        get: function () {
            if (!this.loaded) {
                return undefined;
            }
            var riveContents = {
                artboards: [],
            };
            for (var i = 0; i < this.file.artboardCount(); i++) {
                var artboard = this.file.artboardByIndex(i);
                var artboardContents = {
                    name: artboard.name,
                    animations: [],
                    stateMachines: [],
                };
                for (var j = 0; j < artboard.animationCount(); j++) {
                    var animation = artboard.animationByIndex(j);
                    artboardContents.animations.push(animation.name);
                }
                for (var k = 0; k < artboard.stateMachineCount(); k++) {
                    var stateMachine = artboard.stateMachineByIndex(k);
                    var name_1 = stateMachine.name;
                    var instance = new this.runtime.StateMachineInstance(stateMachine);
                    var inputContents = [];
                    for (var l = 0; l < instance.inputCount(); l++) {
                        var input = instance.input(l);
                        inputContents.push({ name: input.name, type: input.type });
                    }
                    artboardContents.stateMachines.push({ name: name_1, inputs: inputContents });
                }
                riveContents.artboards.push(artboardContents);
            }
            return riveContents;
        },
        enumerable: false,
        configurable: true
    });
    // Error message for missing source or buffer
    Rive.missingErrorMessage = 'Rive source file or data buffer required';
    return Rive;
}());

// Loads Rive data from a URI via fetch.
var loadRiveFile = function (src) { return __awaiter(void 0, void 0, void 0, function () {
    var req, res, buffer;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                req = new Request(src);
                return [4 /*yield*/, fetch(req)];
            case 1:
                res = _a.sent();
                return [4 /*yield*/, res.arrayBuffer()];
            case 2:
                buffer = _a.sent();
                return [2 /*return*/, buffer];
        }
    });
}); };
// #endregion
// #region utility functions
/*
 * Utility function to ensure an object is a string array
 */
var mapToStringArray = function (obj) {
    if (typeof obj === 'string') {
        return [obj];
    }
    else if (obj instanceof Array) {
        return obj;
    }
    // If obj is undefined, return empty array
    return [];
};
// #endregion
// #region testing utilities
// Exports to only be used for tests
var Testing = {
    EventManager: EventManager,
    TaskQueueManager: TaskQueueManager,
};
// #endregion

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=rive.dev.js.map