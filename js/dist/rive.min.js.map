{"version":3,"sources":["webpack://rive/../wasm/publish/rive.js","webpack://rive/webpack/bootstrap","webpack://rive/webpack/runtime/compat get default export","webpack://rive/webpack/runtime/define property getters","webpack://rive/webpack/runtime/hasOwnProperty shorthand","webpack://rive/webpack/runtime/make namespace object","webpack://rive/./src/rive.ts"],"names":["_scriptDir","Rive","document","currentScript","src","undefined","readyPromiseResolve","readyPromiseReject","Module","Promise","resolve","reject","key","moduleOverrides","hasOwnProperty","arguments_","ENVIRONMENT_IS_WEB","ENVIRONMENT_IS_WORKER","ENVIRONMENT_IS_NODE","ENVIRONMENT_IS_SHELL","window","importScripts","process","versions","node","read_","readBinary","nodeFS","nodePath","scriptDirectory","locateFile","path","__dirname","filename","binary","ret","buffer","Uint8Array","assert","length","replace","slice","ex","ExitStatus","abort","read","f","data","readbuffer","scriptArgs","arguments","print","console","log","warn","error","printErr","self","location","href","indexOf","substr","lastIndexOf","url","xhr","XMLHttpRequest","open","send","responseText","responseType","response","out","bind","err","wasmBinary","wasmMemory","setTempRet0","value","WebAssembly","wasmTable","Table","ABORT","condition","text","UTF8Decoder","TextDecoder","UTF8ArrayToString","heap","idx","maxBytesToRead","endIdx","endPtr","subarray","decode","str","u0","u1","u2","String","fromCharCode","ch","UTF8ToString","ptr","HEAPU8","stringToUTF8Array","outIdx","maxBytesToWrite","startIdx","i","u","charCodeAt","stringToUTF8","outPtr","lengthBytesUTF8","len","UTF16Decoder","UTF16ToString","maxIdx","HEAPU16","codeUnit","HEAP16","stringToUTF16","startPtr","numCharsToWrite","lengthBytesUTF16","UTF32ToString","utf32","HEAP32","stringToUTF32","lengthBytesUTF32","HEAP8","HEAPU32","HEAPF32","HEAPF64","WASM_PAGE_SIZE","alignUp","x","multiple","updateGlobalBufferAndViews","buf","Int8Array","Int16Array","Int32Array","Uint16Array","Uint32Array","Float32Array","Float64Array","DYNAMIC_BASE","DYNAMICTOP_PTR","INITIAL_INITIAL_MEMORY","callRuntimeCallbacks","callbacks","callback","shift","func","arg","Memory","byteLength","__ATPRERUN__","__ATINIT__","__ATMAIN__","__ATPOSTRUN__","preRun","addOnPreRun","initRuntime","preMain","postRun","addOnPostRun","cb","unshift","runDependencies","runDependencyWatcher","dependenciesFulfilled","addRunDependency","id","removeRunDependency","clearInterval","what","e","RuntimeError","hasPrefix","prefix","prototype","startsWith","dataURIPrefix","isDataURI","fileURIPrefix","isFileURI","wasmBinaryFile","getBinary","getBinaryPromise","fetch","then","credentials","catch","createWasm","info","asmLibraryArg","receiveInstance","instance","module","exports","receiveInstantiatedSource","output","instantiateArrayBuffer","receiver","instantiate","reason","instantiateStreaming","instantiateAsync","push","___wasm_call_ctors","char_0","char_9","makeLegalFunctionName","name","createNamedFunction","body","Function","emval_free_list","emval_handle_array","count_emval_handles","count","get_first_emval","init_emval","__emval_register","handle","pop","refcount","extendError","baseErrorType","errorName","errorClass","message","this","stack","Error","toString","Object","create","constructor","PureVirtualError","embind_init_charCodes","codes","Array","embind_charCodes","readLatin1String","c","getInheritedInstanceCount","keys","registeredInstances","getLiveInheritedInstances","rv","k","deletionQueue","flushPendingDeletes","obj","$$","deleteScheduled","delayFunction","setDelayFunction","fn","init_embind","BindingError","throwBindingError","getBasestPointer","class_","baseClass","upcast","registerInheritedInstance","requireHandle","registeredTypes","getTypeName","type","___getTypeName","_free","requireRegisteredType","rawType","humanName","impl","unregisterInheritedInstance","detachFinalizer","finalizationGroup","runDestructor","smartPtr","smartPtrType","rawDestructor","ptrType","registeredClass","releaseClassHandle","attachFinalizer","FinalizationGroup","iter","result","next","done","unregister","register","__embind_create_inheriting_constructor","constructorName","wrapperType","properties","arraySlice","wrapperPrototype","instancePrototype","baseClassPrototype","baseConstructor","ctor","pureVirtualFunctions","forEach","defineProperty","apply","call","p","inner","concat","preservePointerOnDelete","defineProperties","structRegistrations","runDestructors","destructors","del","simpleReadValueFromPointer","pointer","awaitingDependencies","typeDependencies","InternalError","throwInternalError","whenDependentTypesAreResolved","myTypes","dependentTypes","getTypeConverters","onComplete","typeConverters","myTypeConverters","registerType","unregisteredTypes","registered","dt","__embind_finalize_value_object","structType","reg","rawConstructor","fieldRecords","fields","map","field","getterReturnType","setterArgumentType","fieldTypes","fieldName","getter","getterContext","setter","setterContext","write","o","TypeError","destructorFunction","getShiftFromSize","size","registeredInstance","options","ignoreDuplicateRegistrations","__embind_register_bool","trueValue","falseValue","wt","ClassHandle_isAliasOf","other","ClassHandle","leftClass","left","rightClass","right","shallowCopyInternalPointer","throwInstanceAlreadyDeleted","ClassHandle_clone","clone","getPrototypeOf","ClassHandle_delete","ClassHandle_isDeleted","ClassHandle_deleteLater","init_ClassHandle","registeredPointers","ensureOverloadTable","proto","methodName","overloadTable","prevFunc","argCount","exposePublicSymbol","numArguments","RegisteredClass","getActualType","downcast","upcastPointer","ptrClass","desiredClass","constNoSmartPtrRawPointerToWireType","isReference","_embind_repr","handleClass","genericPointerToWireType","isSmartPointer","isConst","sharingPolicy","clonedHandle","rawShare","nonConstNoSmartPtrRawPointerToWireType","RegisteredPointer_getPointee","rawGetPointee","RegisteredPointer_destructor","RegisteredPointer_deleteObject","downcastPointer","getInheritedInstance","makeClassHandle","record","RegisteredPointer_fromWireType","rawPointer","getPointee","destructor","makeDefaultHandle","pointeeType","toType","actualType","registeredPointerRecord","constPointerType","pointerType","dp","init_RegisteredPointer","RegisteredPointer","replacePublicSymbol","embind__requireFunction","signature","rawFunction","fp","dynCall","args","join","makeDynCaller","UnboundTypeError","throwUnboundTypeError","types","unboundTypes","seen","visit","__embind_register_class","rawPointerType","rawConstPointerType","baseClassRawType","getActualTypeSignature","upcastSignature","downcastSignature","destructorSignature","legalFunctionName","base","basePrototype","constructor_body","referenceConverter","pointerConverter","constPointerConverter","new_","argumentList","dummy","r","craftInvokerFunction","argTypes","classType","cppInvokerFunc","cppTargetFunc","isClassMethodFunc","needsDestructorStack","returns","argsList","argsListWired","invokerFnBody","dtorStack","args1","args2","paramName","heap32VectorToArray","firstElement","array","__embind_register_class_class_function","rawClassType","rawArgTypesAddr","invokerSignature","rawInvoker","rawArgTypes","unboundTypesHandler","invokerArgsArray","validateThis","this_","__embind_register_class_class_property","rawFieldType","rawFieldPtr","getterSignature","setterSignature","desc","get","enumerable","configurable","set","v","fieldType","__embind_register_class_constructor","invoker","__embind_register_class_function","context","isPureVirtual","method","className","memberFunction","__embind_register_class_property","__emval_decref","__embind_register_emval","enumReadValueFromPointer","signed","__embind_register_enum","isSigned","values","__embind_register_enum_value","rawEnumType","enumValue","enumType","Enum","Value","t","floatReadValueFromPointer","__embind_register_float","__embind_register_function","integerReadValueFromPointer","__embind_register_integer","primitiveType","minRange","maxRange","fromWireType","bitshift","isUnsignedType","__embind_register_memory_view","dataTypeIndex","TA","decodeMemoryView","__embind_register_std_string","stdStringIsUTF8","decodeStartPtr","currentBytePtr","stringSegment","a","ArrayBuffer","valueIsOfTypeString","Uint8ClampedArray","_malloc","charCode","__embind_register_std_wstring","charSize","decodeString","encodeString","getHeap","lengthBytesUTF","HEAP","__embind_register_value_object","constructorSignature","__embind_register_value_object_field","__embind_register_void","isVoid","__emval_as","returnType","destructorsRef","rd","__emval_allocateDestructors","emval_symbols","getStringOrSymbol","address","symbol","emval_methodCallers","__emval_call_method","caller","__emval_call_void_method","__emval_addMethodCaller","__emval_lookupTypes","__emval_get_method_caller","retType","signatureName","params","functionBody","offset","__emval_get_module_property","__emval_get_property","__emval_incref","__emval_new_cstring","__emval_run_destructors","__emval_take_value","argv","_abort","_emscripten_memcpy_big","dest","num","copyWithin","_emscripten_get_heap_size","emscripten_realloc_buffer","grow","_emscripten_resize_heap","requestedSize","oldSize","maxHeapSize","cutDown","overGrownHeapSize","Math","min","max","SYSCALLS","mappings","buffers","printChar","stream","curr","varargs","getStr","get64","low","high","_fd_close","fd","_fd_seek","offset_low","offset_high","whence","newOffset","_fd_write","iov","iovcnt","pnum","j","_setTempRet0","$i","calledRun","status","run","doRun","setTimeout","runCaller","makeMatrix","m2d","m","DOMMatrix","xx","b","xy","yx","d","yy","tx","ty","onRuntimeInitialized","RenderPaintStyle","FillRule","RenderPath","RenderPaint","Renderer","StrokeCap","StrokeJoin","BlendMode","fill","stroke","evenOdd","nonZero","CanvasRenderPath","extend","__construct","__parent","_path2D","Path2D","reset","addPath","fillRule","_fillRule","moveTo","y","lineTo","cubicTo","ox","oy","ix","iy","bezierCurveTo","close","closePath","_colorStyle","CanvasRenderPaint","color","_value","thickness","_thickness","miter","_join","round","bevel","cap","butt","_cap","square","style","_style","blendMode","srcOver","_blend","screen","overlay","darken","lighten","colorDodge","colorBurn","hardLight","softLight","difference","exclusion","multiply","hue","saturation","luminosity","linearGradient","sx","sy","ey","_gradient","stops","radialGradient","isRadial","addStop","stop","completeGradient","draw","ctx","globalCompositeOperation","dx","dy","radius","sqrt","createRadialGradient","createLinearGradient","addColorStop","strokeStyle","lineWidth","lineCap","lineJoin","fillStyle","CanvasRenderer","_ctx","save","restore","transform","matrix","drawPath","paint","clipPath","clip","renderFactory","makeRenderPaint","makeRenderPath","ready","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","n","__esModule","definition","prop","Symbol","toStringTag","PlaybackState","Fit","Alignment","EventType","LoopType","fit","alignment","minX","minY","maxX","maxY","Contain","Center","new","Layout","runtimeFit","rive","cachedRuntimeFit","Cover","cover","contain","Fill","FitWidth","fitWidth","FitHeight","fitHeight","ScaleDown","scaleDown","none","runtimeAlignment","cachedRuntimeAlignment","TopLeft","topLeft","TopCenter","topCenter","TopRight","topRight","CenterLeft","centerLeft","CenterRight","centerRight","BottomLeft","bottomLeft","BottomCenter","bottomCenter","BottomRight","bottomRight","center","loadRuntime","file","RuntimeLoader","testMode","wasmFilePath","wasmWebPath","runtime","callBackQueue","getInstance","isLoading","awaitInstance","setTestMode","mode","animation","loopCount","paused","loopValue","listeners","getListeners","filter","add","listener","includes","remove","index","splice","fire","event","ignoreDuplicate","eventManager","queue","task","action","canvas","artboard","animations","_layout","autoplay","onload","onloaderror","onplay","onpause","onstop","onloop","playState","Stop","loaded","getContext","EventManager","on","Load","LoadError","Play","Pause","Loop","taskQueue","TaskQueueManager","init","missingErrorMessage","artboardName","startingAnimationNames","mapToStringArray","play","initData","loadRiveFile","load","initArtboard","drawFrame","msg","defaultArtboard","animationCount","renderer","playAnimations","align","width","height","bounds","advance","animationNames","instancedAnimationNames","anim","animationByName","inst","LinearAnimationInstance","Animation","removeAnimations","animationsToRemove","removeAllAnimations","names","pauseAnimations","pausedAnimationNames","reduce","acc","atLeastOneAnimationForPlayback","animationByIndex","time","lastRenderTime","elapsedTime","didLoop","clearRect","PingPong","frameRequestId","requestAnimationFrame","playingAnimationNames","pause","hasPlayingAnimations","stoppedAnimationNames","cancelAnimationFrame","layout","req","Request","arrayBuffer","Testing"],"mappings":"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","file":"rive.min.js","sourcesContent":["\nvar Rive = (function() {\n  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\n  if (typeof __filename !== 'undefined') _scriptDir = _scriptDir || __filename;\n  return (\nfunction(Rive) {\n  Rive = Rive || {};\n\nnull;\n\nvar Module = typeof Rive !== \"undefined\" ? Rive : {};\n\nvar readyPromiseResolve, readyPromiseReject;\n\nModule[\"ready\"] = new Promise(function(resolve, reject) {\n readyPromiseResolve = resolve;\n readyPromiseReject = reject;\n});\n\nvar moduleOverrides = {};\n\nvar key;\n\nfor (key in Module) {\n if (Module.hasOwnProperty(key)) {\n  moduleOverrides[key] = Module[key];\n }\n}\n\nvar arguments_ = [];\n\nvar thisProgram = \"./this.program\";\n\nvar quit_ = function(status, toThrow) {\n throw toThrow;\n};\n\nvar ENVIRONMENT_IS_WEB = false;\n\nvar ENVIRONMENT_IS_WORKER = false;\n\nvar ENVIRONMENT_IS_NODE = false;\n\nvar ENVIRONMENT_IS_SHELL = false;\n\nENVIRONMENT_IS_WEB = typeof window === \"object\";\n\nENVIRONMENT_IS_WORKER = typeof importScripts === \"function\";\n\nENVIRONMENT_IS_NODE = typeof process === \"object\" && typeof process.versions === \"object\" && typeof process.versions.node === \"string\";\n\nENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n\nvar scriptDirectory = \"\";\n\nfunction locateFile(path) {\n if (Module[\"locateFile\"]) {\n  return Module[\"locateFile\"](path, scriptDirectory);\n }\n return scriptDirectory + path;\n}\n\nvar read_, readAsync, readBinary, setWindowTitle;\n\nvar nodeFS;\n\nvar nodePath;\n\nif (ENVIRONMENT_IS_NODE) {\n if (ENVIRONMENT_IS_WORKER) {\n  scriptDirectory = require(\"path\").dirname(scriptDirectory) + \"/\";\n } else {\n  scriptDirectory = __dirname + \"/\";\n }\n read_ = function shell_read(filename, binary) {\n  if (!nodeFS) nodeFS = require(\"fs\");\n  if (!nodePath) nodePath = require(\"path\");\n  filename = nodePath[\"normalize\"](filename);\n  return nodeFS[\"readFileSync\"](filename, binary ? null : \"utf8\");\n };\n readBinary = function readBinary(filename) {\n  var ret = read_(filename, true);\n  if (!ret.buffer) {\n   ret = new Uint8Array(ret);\n  }\n  assert(ret.buffer);\n  return ret;\n };\n if (process[\"argv\"].length > 1) {\n  thisProgram = process[\"argv\"][1].replace(/\\\\/g, \"/\");\n }\n arguments_ = process[\"argv\"].slice(2);\n process[\"on\"](\"uncaughtException\", function(ex) {\n  if (!(ex instanceof ExitStatus)) {\n   throw ex;\n  }\n });\n process[\"on\"](\"unhandledRejection\", abort);\n quit_ = function(status) {\n  process[\"exit\"](status);\n };\n Module[\"inspect\"] = function() {\n  return \"[Emscripten Module object]\";\n };\n} else if (ENVIRONMENT_IS_SHELL) {\n if (typeof read != \"undefined\") {\n  read_ = function shell_read(f) {\n   return read(f);\n  };\n }\n readBinary = function readBinary(f) {\n  var data;\n  if (typeof readbuffer === \"function\") {\n   return new Uint8Array(readbuffer(f));\n  }\n  data = read(f, \"binary\");\n  assert(typeof data === \"object\");\n  return data;\n };\n if (typeof scriptArgs != \"undefined\") {\n  arguments_ = scriptArgs;\n } else if (typeof arguments != \"undefined\") {\n  arguments_ = arguments;\n }\n if (typeof quit === \"function\") {\n  quit_ = function(status) {\n   quit(status);\n  };\n }\n if (typeof print !== \"undefined\") {\n  if (typeof console === \"undefined\") console = {};\n  console.log = print;\n  console.warn = console.error = typeof printErr !== \"undefined\" ? printErr : print;\n }\n} else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n if (ENVIRONMENT_IS_WORKER) {\n  scriptDirectory = self.location.href;\n } else if (document.currentScript) {\n  scriptDirectory = document.currentScript.src;\n }\n if (_scriptDir) {\n  scriptDirectory = _scriptDir;\n }\n if (scriptDirectory.indexOf(\"blob:\") !== 0) {\n  scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf(\"/\") + 1);\n } else {\n  scriptDirectory = \"\";\n }\n {\n  read_ = function shell_read(url) {\n   var xhr = new XMLHttpRequest();\n   xhr.open(\"GET\", url, false);\n   xhr.send(null);\n   return xhr.responseText;\n  };\n  if (ENVIRONMENT_IS_WORKER) {\n   readBinary = function readBinary(url) {\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", url, false);\n    xhr.responseType = \"arraybuffer\";\n    xhr.send(null);\n    return new Uint8Array(xhr.response);\n   };\n  }\n  readAsync = function readAsync(url, onload, onerror) {\n   var xhr = new XMLHttpRequest();\n   xhr.open(\"GET\", url, true);\n   xhr.responseType = \"arraybuffer\";\n   xhr.onload = function xhr_onload() {\n    if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n     onload(xhr.response);\n     return;\n    }\n    onerror();\n   };\n   xhr.onerror = onerror;\n   xhr.send(null);\n  };\n }\n setWindowTitle = function(title) {\n  document.title = title;\n };\n} else {}\n\nvar out = Module[\"print\"] || console.log.bind(console);\n\nvar err = Module[\"printErr\"] || console.warn.bind(console);\n\nfor (key in moduleOverrides) {\n if (moduleOverrides.hasOwnProperty(key)) {\n  Module[key] = moduleOverrides[key];\n }\n}\n\nmoduleOverrides = null;\n\nif (Module[\"arguments\"]) arguments_ = Module[\"arguments\"];\n\nif (Module[\"thisProgram\"]) thisProgram = Module[\"thisProgram\"];\n\nif (Module[\"quit\"]) quit_ = Module[\"quit\"];\n\nvar tempRet0 = 0;\n\nvar setTempRet0 = function(value) {\n tempRet0 = value;\n};\n\nvar wasmBinary;\n\nif (Module[\"wasmBinary\"]) wasmBinary = Module[\"wasmBinary\"];\n\nvar noExitRuntime;\n\nif (Module[\"noExitRuntime\"]) noExitRuntime = Module[\"noExitRuntime\"];\n\nif (typeof WebAssembly !== \"object\") {\n abort(\"no native wasm support detected\");\n}\n\nvar wasmMemory;\n\nvar wasmTable = new WebAssembly.Table({\n \"initial\": 902,\n \"maximum\": 902 + 0,\n \"element\": \"anyfunc\"\n});\n\nvar ABORT = false;\n\nvar EXITSTATUS = 0;\n\nfunction assert(condition, text) {\n if (!condition) {\n  abort(\"Assertion failed: \" + text);\n }\n}\n\nvar UTF8Decoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf8\") : undefined;\n\nfunction UTF8ArrayToString(heap, idx, maxBytesToRead) {\n var endIdx = idx + maxBytesToRead;\n var endPtr = idx;\n while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {\n  return UTF8Decoder.decode(heap.subarray(idx, endPtr));\n } else {\n  var str = \"\";\n  while (idx < endPtr) {\n   var u0 = heap[idx++];\n   if (!(u0 & 128)) {\n    str += String.fromCharCode(u0);\n    continue;\n   }\n   var u1 = heap[idx++] & 63;\n   if ((u0 & 224) == 192) {\n    str += String.fromCharCode((u0 & 31) << 6 | u1);\n    continue;\n   }\n   var u2 = heap[idx++] & 63;\n   if ((u0 & 240) == 224) {\n    u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n   } else {\n    u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63;\n   }\n   if (u0 < 65536) {\n    str += String.fromCharCode(u0);\n   } else {\n    var ch = u0 - 65536;\n    str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n   }\n  }\n }\n return str;\n}\n\nfunction UTF8ToString(ptr, maxBytesToRead) {\n return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \"\";\n}\n\nfunction stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {\n if (!(maxBytesToWrite > 0)) return 0;\n var startIdx = outIdx;\n var endIdx = outIdx + maxBytesToWrite - 1;\n for (var i = 0; i < str.length; ++i) {\n  var u = str.charCodeAt(i);\n  if (u >= 55296 && u <= 57343) {\n   var u1 = str.charCodeAt(++i);\n   u = 65536 + ((u & 1023) << 10) | u1 & 1023;\n  }\n  if (u <= 127) {\n   if (outIdx >= endIdx) break;\n   heap[outIdx++] = u;\n  } else if (u <= 2047) {\n   if (outIdx + 1 >= endIdx) break;\n   heap[outIdx++] = 192 | u >> 6;\n   heap[outIdx++] = 128 | u & 63;\n  } else if (u <= 65535) {\n   if (outIdx + 2 >= endIdx) break;\n   heap[outIdx++] = 224 | u >> 12;\n   heap[outIdx++] = 128 | u >> 6 & 63;\n   heap[outIdx++] = 128 | u & 63;\n  } else {\n   if (outIdx + 3 >= endIdx) break;\n   heap[outIdx++] = 240 | u >> 18;\n   heap[outIdx++] = 128 | u >> 12 & 63;\n   heap[outIdx++] = 128 | u >> 6 & 63;\n   heap[outIdx++] = 128 | u & 63;\n  }\n }\n heap[outIdx] = 0;\n return outIdx - startIdx;\n}\n\nfunction stringToUTF8(str, outPtr, maxBytesToWrite) {\n return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n}\n\nfunction lengthBytesUTF8(str) {\n var len = 0;\n for (var i = 0; i < str.length; ++i) {\n  var u = str.charCodeAt(i);\n  if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;\n  if (u <= 127) ++len; else if (u <= 2047) len += 2; else if (u <= 65535) len += 3; else len += 4;\n }\n return len;\n}\n\nvar UTF16Decoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf-16le\") : undefined;\n\nfunction UTF16ToString(ptr, maxBytesToRead) {\n var endPtr = ptr;\n var idx = endPtr >> 1;\n var maxIdx = idx + maxBytesToRead / 2;\n while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;\n endPtr = idx << 1;\n if (endPtr - ptr > 32 && UTF16Decoder) {\n  return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n } else {\n  var i = 0;\n  var str = \"\";\n  while (1) {\n   var codeUnit = HEAP16[ptr + i * 2 >> 1];\n   if (codeUnit == 0 || i == maxBytesToRead / 2) return str;\n   ++i;\n   str += String.fromCharCode(codeUnit);\n  }\n }\n}\n\nfunction stringToUTF16(str, outPtr, maxBytesToWrite) {\n if (maxBytesToWrite === undefined) {\n  maxBytesToWrite = 2147483647;\n }\n if (maxBytesToWrite < 2) return 0;\n maxBytesToWrite -= 2;\n var startPtr = outPtr;\n var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n for (var i = 0; i < numCharsToWrite; ++i) {\n  var codeUnit = str.charCodeAt(i);\n  HEAP16[outPtr >> 1] = codeUnit;\n  outPtr += 2;\n }\n HEAP16[outPtr >> 1] = 0;\n return outPtr - startPtr;\n}\n\nfunction lengthBytesUTF16(str) {\n return str.length * 2;\n}\n\nfunction UTF32ToString(ptr, maxBytesToRead) {\n var i = 0;\n var str = \"\";\n while (!(i >= maxBytesToRead / 4)) {\n  var utf32 = HEAP32[ptr + i * 4 >> 2];\n  if (utf32 == 0) break;\n  ++i;\n  if (utf32 >= 65536) {\n   var ch = utf32 - 65536;\n   str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n  } else {\n   str += String.fromCharCode(utf32);\n  }\n }\n return str;\n}\n\nfunction stringToUTF32(str, outPtr, maxBytesToWrite) {\n if (maxBytesToWrite === undefined) {\n  maxBytesToWrite = 2147483647;\n }\n if (maxBytesToWrite < 4) return 0;\n var startPtr = outPtr;\n var endPtr = startPtr + maxBytesToWrite - 4;\n for (var i = 0; i < str.length; ++i) {\n  var codeUnit = str.charCodeAt(i);\n  if (codeUnit >= 55296 && codeUnit <= 57343) {\n   var trailSurrogate = str.charCodeAt(++i);\n   codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;\n  }\n  HEAP32[outPtr >> 2] = codeUnit;\n  outPtr += 4;\n  if (outPtr + 4 > endPtr) break;\n }\n HEAP32[outPtr >> 2] = 0;\n return outPtr - startPtr;\n}\n\nfunction lengthBytesUTF32(str) {\n var len = 0;\n for (var i = 0; i < str.length; ++i) {\n  var codeUnit = str.charCodeAt(i);\n  if (codeUnit >= 55296 && codeUnit <= 57343) ++i;\n  len += 4;\n }\n return len;\n}\n\nvar WASM_PAGE_SIZE = 65536;\n\nfunction alignUp(x, multiple) {\n if (x % multiple > 0) {\n  x += multiple - x % multiple;\n }\n return x;\n}\n\nvar buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\n\nfunction updateGlobalBufferAndViews(buf) {\n buffer = buf;\n Module[\"HEAP8\"] = HEAP8 = new Int8Array(buf);\n Module[\"HEAP16\"] = HEAP16 = new Int16Array(buf);\n Module[\"HEAP32\"] = HEAP32 = new Int32Array(buf);\n Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(buf);\n Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(buf);\n Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(buf);\n Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(buf);\n Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(buf);\n}\n\nvar DYNAMIC_BASE = 5265424, DYNAMICTOP_PTR = 22384;\n\nvar INITIAL_INITIAL_MEMORY = Module[\"INITIAL_MEMORY\"] || 16777216;\n\nif (Module[\"wasmMemory\"]) {\n wasmMemory = Module[\"wasmMemory\"];\n} else {\n wasmMemory = new WebAssembly.Memory({\n  \"initial\": INITIAL_INITIAL_MEMORY / WASM_PAGE_SIZE,\n  \"maximum\": 2147483648 / WASM_PAGE_SIZE\n });\n}\n\nif (wasmMemory) {\n buffer = wasmMemory.buffer;\n}\n\nINITIAL_INITIAL_MEMORY = buffer.byteLength;\n\nupdateGlobalBufferAndViews(buffer);\n\nHEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;\n\nfunction callRuntimeCallbacks(callbacks) {\n while (callbacks.length > 0) {\n  var callback = callbacks.shift();\n  if (typeof callback == \"function\") {\n   callback(Module);\n   continue;\n  }\n  var func = callback.func;\n  if (typeof func === \"number\") {\n   if (callback.arg === undefined) {\n    Module[\"dynCall_v\"](func);\n   } else {\n    Module[\"dynCall_vi\"](func, callback.arg);\n   }\n  } else {\n   func(callback.arg === undefined ? null : callback.arg);\n  }\n }\n}\n\nvar __ATPRERUN__ = [];\n\nvar __ATINIT__ = [];\n\nvar __ATMAIN__ = [];\n\nvar __ATPOSTRUN__ = [];\n\nvar runtimeInitialized = false;\n\nfunction preRun() {\n if (Module[\"preRun\"]) {\n  if (typeof Module[\"preRun\"] == \"function\") Module[\"preRun\"] = [ Module[\"preRun\"] ];\n  while (Module[\"preRun\"].length) {\n   addOnPreRun(Module[\"preRun\"].shift());\n  }\n }\n callRuntimeCallbacks(__ATPRERUN__);\n}\n\nfunction initRuntime() {\n runtimeInitialized = true;\n callRuntimeCallbacks(__ATINIT__);\n}\n\nfunction preMain() {\n callRuntimeCallbacks(__ATMAIN__);\n}\n\nfunction postRun() {\n if (Module[\"postRun\"]) {\n  if (typeof Module[\"postRun\"] == \"function\") Module[\"postRun\"] = [ Module[\"postRun\"] ];\n  while (Module[\"postRun\"].length) {\n   addOnPostRun(Module[\"postRun\"].shift());\n  }\n }\n callRuntimeCallbacks(__ATPOSTRUN__);\n}\n\nfunction addOnPreRun(cb) {\n __ATPRERUN__.unshift(cb);\n}\n\nfunction addOnPostRun(cb) {\n __ATPOSTRUN__.unshift(cb);\n}\n\nvar runDependencies = 0;\n\nvar runDependencyWatcher = null;\n\nvar dependenciesFulfilled = null;\n\nfunction addRunDependency(id) {\n runDependencies++;\n if (Module[\"monitorRunDependencies\"]) {\n  Module[\"monitorRunDependencies\"](runDependencies);\n }\n}\n\nfunction removeRunDependency(id) {\n runDependencies--;\n if (Module[\"monitorRunDependencies\"]) {\n  Module[\"monitorRunDependencies\"](runDependencies);\n }\n if (runDependencies == 0) {\n  if (runDependencyWatcher !== null) {\n   clearInterval(runDependencyWatcher);\n   runDependencyWatcher = null;\n  }\n  if (dependenciesFulfilled) {\n   var callback = dependenciesFulfilled;\n   dependenciesFulfilled = null;\n   callback();\n  }\n }\n}\n\nModule[\"preloadedImages\"] = {};\n\nModule[\"preloadedAudios\"] = {};\n\nfunction abort(what) {\n if (Module[\"onAbort\"]) {\n  Module[\"onAbort\"](what);\n }\n what += \"\";\n err(what);\n ABORT = true;\n EXITSTATUS = 1;\n what = \"abort(\" + what + \"). Build with -s ASSERTIONS=1 for more info.\";\n var e = new WebAssembly.RuntimeError(what);\n readyPromiseReject(e);\n throw e;\n}\n\nfunction hasPrefix(str, prefix) {\n return String.prototype.startsWith ? str.startsWith(prefix) : str.indexOf(prefix) === 0;\n}\n\nvar dataURIPrefix = \"data:application/octet-stream;base64,\";\n\nfunction isDataURI(filename) {\n return hasPrefix(filename, dataURIPrefix);\n}\n\nvar fileURIPrefix = \"file://\";\n\nfunction isFileURI(filename) {\n return hasPrefix(filename, fileURIPrefix);\n}\n\nvar wasmBinaryFile = \"rive.wasm\";\n\nif (!isDataURI(wasmBinaryFile)) {\n wasmBinaryFile = locateFile(wasmBinaryFile);\n}\n\nfunction getBinary() {\n try {\n  if (wasmBinary) {\n   return new Uint8Array(wasmBinary);\n  }\n  if (readBinary) {\n   return readBinary(wasmBinaryFile);\n  } else {\n   throw \"both async and sync fetching of the wasm failed\";\n  }\n } catch (err) {\n  abort(err);\n }\n}\n\nfunction getBinaryPromise() {\n if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === \"function\" && !isFileURI(wasmBinaryFile)) {\n  return fetch(wasmBinaryFile, {\n   credentials: \"same-origin\"\n  }).then(function(response) {\n   if (!response[\"ok\"]) {\n    throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\n   }\n   return response[\"arrayBuffer\"]();\n  }).catch(function() {\n   return getBinary();\n  });\n }\n return Promise.resolve().then(getBinary);\n}\n\nfunction createWasm() {\n var info = {\n  \"a\": asmLibraryArg\n };\n function receiveInstance(instance, module) {\n  var exports = instance.exports;\n  Module[\"asm\"] = exports;\n  removeRunDependency(\"wasm-instantiate\");\n }\n addRunDependency(\"wasm-instantiate\");\n function receiveInstantiatedSource(output) {\n  receiveInstance(output[\"instance\"]);\n }\n function instantiateArrayBuffer(receiver) {\n  return getBinaryPromise().then(function(binary) {\n   return WebAssembly.instantiate(binary, info);\n  }).then(receiver, function(reason) {\n   err(\"failed to asynchronously prepare wasm: \" + reason);\n   abort(reason);\n  });\n }\n function instantiateAsync() {\n  if (!wasmBinary && typeof WebAssembly.instantiateStreaming === \"function\" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && typeof fetch === \"function\") {\n   fetch(wasmBinaryFile, {\n    credentials: \"same-origin\"\n   }).then(function(response) {\n    var result = WebAssembly.instantiateStreaming(response, info);\n    return result.then(receiveInstantiatedSource, function(reason) {\n     err(\"wasm streaming compile failed: \" + reason);\n     err(\"falling back to ArrayBuffer instantiation\");\n     return instantiateArrayBuffer(receiveInstantiatedSource);\n    });\n   });\n  } else {\n   return instantiateArrayBuffer(receiveInstantiatedSource);\n  }\n }\n if (Module[\"instantiateWasm\"]) {\n  try {\n   var exports = Module[\"instantiateWasm\"](info, receiveInstance);\n   return exports;\n  } catch (e) {\n   err(\"Module.instantiateWasm callback failed with error: \" + e);\n   return false;\n  }\n }\n instantiateAsync();\n return {};\n}\n\n__ATINIT__.push({\n func: function() {\n  ___wasm_call_ctors();\n }\n});\n\nvar char_0 = 48;\n\nvar char_9 = 57;\n\nfunction makeLegalFunctionName(name) {\n if (undefined === name) {\n  return \"_unknown\";\n }\n name = name.replace(/[^a-zA-Z0-9_]/g, \"$\");\n var f = name.charCodeAt(0);\n if (f >= char_0 && f <= char_9) {\n  return \"_\" + name;\n } else {\n  return name;\n }\n}\n\nfunction createNamedFunction(name, body) {\n name = makeLegalFunctionName(name);\n return new Function(\"body\", \"return function \" + name + \"() {\\n\" + '    \"use strict\";' + \"    return body.apply(this, arguments);\\n\" + \"};\\n\")(body);\n}\n\nvar emval_free_list = [];\n\nvar emval_handle_array = [ {}, {\n value: undefined\n}, {\n value: null\n}, {\n value: true\n}, {\n value: false\n} ];\n\nfunction count_emval_handles() {\n var count = 0;\n for (var i = 5; i < emval_handle_array.length; ++i) {\n  if (emval_handle_array[i] !== undefined) {\n   ++count;\n  }\n }\n return count;\n}\n\nfunction get_first_emval() {\n for (var i = 5; i < emval_handle_array.length; ++i) {\n  if (emval_handle_array[i] !== undefined) {\n   return emval_handle_array[i];\n  }\n }\n return null;\n}\n\nfunction init_emval() {\n Module[\"count_emval_handles\"] = count_emval_handles;\n Module[\"get_first_emval\"] = get_first_emval;\n}\n\nfunction __emval_register(value) {\n switch (value) {\n case undefined:\n  {\n   return 1;\n  }\n\n case null:\n  {\n   return 2;\n  }\n\n case true:\n  {\n   return 3;\n  }\n\n case false:\n  {\n   return 4;\n  }\n\n default:\n  {\n   var handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;\n   emval_handle_array[handle] = {\n    refcount: 1,\n    value: value\n   };\n   return handle;\n  }\n }\n}\n\nfunction extendError(baseErrorType, errorName) {\n var errorClass = createNamedFunction(errorName, function(message) {\n  this.name = errorName;\n  this.message = message;\n  var stack = new Error(message).stack;\n  if (stack !== undefined) {\n   this.stack = this.toString() + \"\\n\" + stack.replace(/^Error(:[^\\n]*)?\\n/, \"\");\n  }\n });\n errorClass.prototype = Object.create(baseErrorType.prototype);\n errorClass.prototype.constructor = errorClass;\n errorClass.prototype.toString = function() {\n  if (this.message === undefined) {\n   return this.name;\n  } else {\n   return this.name + \": \" + this.message;\n  }\n };\n return errorClass;\n}\n\nvar PureVirtualError = undefined;\n\nfunction embind_init_charCodes() {\n var codes = new Array(256);\n for (var i = 0; i < 256; ++i) {\n  codes[i] = String.fromCharCode(i);\n }\n embind_charCodes = codes;\n}\n\nvar embind_charCodes = undefined;\n\nfunction readLatin1String(ptr) {\n var ret = \"\";\n var c = ptr;\n while (HEAPU8[c]) {\n  ret += embind_charCodes[HEAPU8[c++]];\n }\n return ret;\n}\n\nfunction getInheritedInstanceCount() {\n return Object.keys(registeredInstances).length;\n}\n\nfunction getLiveInheritedInstances() {\n var rv = [];\n for (var k in registeredInstances) {\n  if (registeredInstances.hasOwnProperty(k)) {\n   rv.push(registeredInstances[k]);\n  }\n }\n return rv;\n}\n\nvar deletionQueue = [];\n\nfunction flushPendingDeletes() {\n while (deletionQueue.length) {\n  var obj = deletionQueue.pop();\n  obj.$$.deleteScheduled = false;\n  obj[\"delete\"]();\n }\n}\n\nvar delayFunction = undefined;\n\nfunction setDelayFunction(fn) {\n delayFunction = fn;\n if (deletionQueue.length && delayFunction) {\n  delayFunction(flushPendingDeletes);\n }\n}\n\nfunction init_embind() {\n Module[\"getInheritedInstanceCount\"] = getInheritedInstanceCount;\n Module[\"getLiveInheritedInstances\"] = getLiveInheritedInstances;\n Module[\"flushPendingDeletes\"] = flushPendingDeletes;\n Module[\"setDelayFunction\"] = setDelayFunction;\n}\n\nvar registeredInstances = {};\n\nvar BindingError = undefined;\n\nfunction throwBindingError(message) {\n throw new BindingError(message);\n}\n\nfunction getBasestPointer(class_, ptr) {\n if (ptr === undefined) {\n  throwBindingError(\"ptr should not be undefined\");\n }\n while (class_.baseClass) {\n  ptr = class_.upcast(ptr);\n  class_ = class_.baseClass;\n }\n return ptr;\n}\n\nfunction registerInheritedInstance(class_, ptr, instance) {\n ptr = getBasestPointer(class_, ptr);\n if (registeredInstances.hasOwnProperty(ptr)) {\n  throwBindingError(\"Tried to register registered instance: \" + ptr);\n } else {\n  registeredInstances[ptr] = instance;\n }\n}\n\nfunction requireHandle(handle) {\n if (!handle) {\n  throwBindingError(\"Cannot use deleted val. handle = \" + handle);\n }\n return emval_handle_array[handle].value;\n}\n\nvar registeredTypes = {};\n\nfunction getTypeName(type) {\n var ptr = ___getTypeName(type);\n var rv = readLatin1String(ptr);\n _free(ptr);\n return rv;\n}\n\nfunction requireRegisteredType(rawType, humanName) {\n var impl = registeredTypes[rawType];\n if (undefined === impl) {\n  throwBindingError(humanName + \" has unknown type \" + getTypeName(rawType));\n }\n return impl;\n}\n\nfunction unregisterInheritedInstance(class_, ptr) {\n ptr = getBasestPointer(class_, ptr);\n if (registeredInstances.hasOwnProperty(ptr)) {\n  delete registeredInstances[ptr];\n } else {\n  throwBindingError(\"Tried to unregister unregistered instance: \" + ptr);\n }\n}\n\nfunction detachFinalizer(handle) {}\n\nvar finalizationGroup = false;\n\nfunction runDestructor($$) {\n if ($$.smartPtr) {\n  $$.smartPtrType.rawDestructor($$.smartPtr);\n } else {\n  $$.ptrType.registeredClass.rawDestructor($$.ptr);\n }\n}\n\nfunction releaseClassHandle($$) {\n $$.count.value -= 1;\n var toDelete = 0 === $$.count.value;\n if (toDelete) {\n  runDestructor($$);\n }\n}\n\nfunction attachFinalizer(handle) {\n if (\"undefined\" === typeof FinalizationGroup) {\n  attachFinalizer = function(handle) {\n   return handle;\n  };\n  return handle;\n }\n finalizationGroup = new FinalizationGroup(function(iter) {\n  for (var result = iter.next(); !result.done; result = iter.next()) {\n   var $$ = result.value;\n   if (!$$.ptr) {\n    console.warn(\"object already deleted: \" + $$.ptr);\n   } else {\n    releaseClassHandle($$);\n   }\n  }\n });\n attachFinalizer = function(handle) {\n  finalizationGroup.register(handle, handle.$$, handle.$$);\n  return handle;\n };\n detachFinalizer = function(handle) {\n  finalizationGroup.unregister(handle.$$);\n };\n return attachFinalizer(handle);\n}\n\nfunction __embind_create_inheriting_constructor(constructorName, wrapperType, properties) {\n constructorName = readLatin1String(constructorName);\n wrapperType = requireRegisteredType(wrapperType, \"wrapper\");\n properties = requireHandle(properties);\n var arraySlice = [].slice;\n var registeredClass = wrapperType.registeredClass;\n var wrapperPrototype = registeredClass.instancePrototype;\n var baseClass = registeredClass.baseClass;\n var baseClassPrototype = baseClass.instancePrototype;\n var baseConstructor = registeredClass.baseClass.constructor;\n var ctor = createNamedFunction(constructorName, function() {\n  registeredClass.baseClass.pureVirtualFunctions.forEach(function(name) {\n   if (this[name] === baseClassPrototype[name]) {\n    throw new PureVirtualError(\"Pure virtual function \" + name + \" must be implemented in JavaScript\");\n   }\n  }.bind(this));\n  Object.defineProperty(this, \"__parent\", {\n   value: wrapperPrototype\n  });\n  this[\"__construct\"].apply(this, arraySlice.call(arguments));\n });\n wrapperPrototype[\"__construct\"] = function __construct() {\n  if (this === wrapperPrototype) {\n   throwBindingError(\"Pass correct 'this' to __construct\");\n  }\n  var inner = baseConstructor[\"implement\"].apply(undefined, [ this ].concat(arraySlice.call(arguments)));\n  detachFinalizer(inner);\n  var $$ = inner.$$;\n  inner[\"notifyOnDestruction\"]();\n  $$.preservePointerOnDelete = true;\n  Object.defineProperties(this, {\n   $$: {\n    value: $$\n   }\n  });\n  attachFinalizer(this);\n  registerInheritedInstance(registeredClass, $$.ptr, this);\n };\n wrapperPrototype[\"__destruct\"] = function __destruct() {\n  if (this === wrapperPrototype) {\n   throwBindingError(\"Pass correct 'this' to __destruct\");\n  }\n  detachFinalizer(this);\n  unregisterInheritedInstance(registeredClass, this.$$.ptr);\n };\n ctor.prototype = Object.create(wrapperPrototype);\n for (var p in properties) {\n  ctor.prototype[p] = properties[p];\n }\n return __emval_register(ctor);\n}\n\nvar structRegistrations = {};\n\nfunction runDestructors(destructors) {\n while (destructors.length) {\n  var ptr = destructors.pop();\n  var del = destructors.pop();\n  del(ptr);\n }\n}\n\nfunction simpleReadValueFromPointer(pointer) {\n return this[\"fromWireType\"](HEAPU32[pointer >> 2]);\n}\n\nvar awaitingDependencies = {};\n\nvar typeDependencies = {};\n\nvar InternalError = undefined;\n\nfunction throwInternalError(message) {\n throw new InternalError(message);\n}\n\nfunction whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {\n myTypes.forEach(function(type) {\n  typeDependencies[type] = dependentTypes;\n });\n function onComplete(typeConverters) {\n  var myTypeConverters = getTypeConverters(typeConverters);\n  if (myTypeConverters.length !== myTypes.length) {\n   throwInternalError(\"Mismatched type converter count\");\n  }\n  for (var i = 0; i < myTypes.length; ++i) {\n   registerType(myTypes[i], myTypeConverters[i]);\n  }\n }\n var typeConverters = new Array(dependentTypes.length);\n var unregisteredTypes = [];\n var registered = 0;\n dependentTypes.forEach(function(dt, i) {\n  if (registeredTypes.hasOwnProperty(dt)) {\n   typeConverters[i] = registeredTypes[dt];\n  } else {\n   unregisteredTypes.push(dt);\n   if (!awaitingDependencies.hasOwnProperty(dt)) {\n    awaitingDependencies[dt] = [];\n   }\n   awaitingDependencies[dt].push(function() {\n    typeConverters[i] = registeredTypes[dt];\n    ++registered;\n    if (registered === unregisteredTypes.length) {\n     onComplete(typeConverters);\n    }\n   });\n  }\n });\n if (0 === unregisteredTypes.length) {\n  onComplete(typeConverters);\n }\n}\n\nfunction __embind_finalize_value_object(structType) {\n var reg = structRegistrations[structType];\n delete structRegistrations[structType];\n var rawConstructor = reg.rawConstructor;\n var rawDestructor = reg.rawDestructor;\n var fieldRecords = reg.fields;\n var fieldTypes = fieldRecords.map(function(field) {\n  return field.getterReturnType;\n }).concat(fieldRecords.map(function(field) {\n  return field.setterArgumentType;\n }));\n whenDependentTypesAreResolved([ structType ], fieldTypes, function(fieldTypes) {\n  var fields = {};\n  fieldRecords.forEach(function(field, i) {\n   var fieldName = field.fieldName;\n   var getterReturnType = fieldTypes[i];\n   var getter = field.getter;\n   var getterContext = field.getterContext;\n   var setterArgumentType = fieldTypes[i + fieldRecords.length];\n   var setter = field.setter;\n   var setterContext = field.setterContext;\n   fields[fieldName] = {\n    read: function(ptr) {\n     return getterReturnType[\"fromWireType\"](getter(getterContext, ptr));\n    },\n    write: function(ptr, o) {\n     var destructors = [];\n     setter(setterContext, ptr, setterArgumentType[\"toWireType\"](destructors, o));\n     runDestructors(destructors);\n    }\n   };\n  });\n  return [ {\n   name: reg.name,\n   \"fromWireType\": function(ptr) {\n    var rv = {};\n    for (var i in fields) {\n     rv[i] = fields[i].read(ptr);\n    }\n    rawDestructor(ptr);\n    return rv;\n   },\n   \"toWireType\": function(destructors, o) {\n    for (var fieldName in fields) {\n     if (!(fieldName in o)) {\n      throw new TypeError('Missing field:  \"' + fieldName + '\"');\n     }\n    }\n    var ptr = rawConstructor();\n    for (fieldName in fields) {\n     fields[fieldName].write(ptr, o[fieldName]);\n    }\n    if (destructors !== null) {\n     destructors.push(rawDestructor, ptr);\n    }\n    return ptr;\n   },\n   \"argPackAdvance\": 8,\n   \"readValueFromPointer\": simpleReadValueFromPointer,\n   destructorFunction: rawDestructor\n  } ];\n });\n}\n\nfunction getShiftFromSize(size) {\n switch (size) {\n case 1:\n  return 0;\n\n case 2:\n  return 1;\n\n case 4:\n  return 2;\n\n case 8:\n  return 3;\n\n default:\n  throw new TypeError(\"Unknown type size: \" + size);\n }\n}\n\nfunction registerType(rawType, registeredInstance, options) {\n options = options || {};\n if (!(\"argPackAdvance\" in registeredInstance)) {\n  throw new TypeError(\"registerType registeredInstance requires argPackAdvance\");\n }\n var name = registeredInstance.name;\n if (!rawType) {\n  throwBindingError('type \"' + name + '\" must have a positive integer typeid pointer');\n }\n if (registeredTypes.hasOwnProperty(rawType)) {\n  if (options.ignoreDuplicateRegistrations) {\n   return;\n  } else {\n   throwBindingError(\"Cannot register type '\" + name + \"' twice\");\n  }\n }\n registeredTypes[rawType] = registeredInstance;\n delete typeDependencies[rawType];\n if (awaitingDependencies.hasOwnProperty(rawType)) {\n  var callbacks = awaitingDependencies[rawType];\n  delete awaitingDependencies[rawType];\n  callbacks.forEach(function(cb) {\n   cb();\n  });\n }\n}\n\nfunction __embind_register_bool(rawType, name, size, trueValue, falseValue) {\n var shift = getShiftFromSize(size);\n name = readLatin1String(name);\n registerType(rawType, {\n  name: name,\n  \"fromWireType\": function(wt) {\n   return !!wt;\n  },\n  \"toWireType\": function(destructors, o) {\n   return o ? trueValue : falseValue;\n  },\n  \"argPackAdvance\": 8,\n  \"readValueFromPointer\": function(pointer) {\n   var heap;\n   if (size === 1) {\n    heap = HEAP8;\n   } else if (size === 2) {\n    heap = HEAP16;\n   } else if (size === 4) {\n    heap = HEAP32;\n   } else {\n    throw new TypeError(\"Unknown boolean type size: \" + name);\n   }\n   return this[\"fromWireType\"](heap[pointer >> shift]);\n  },\n  destructorFunction: null\n });\n}\n\nfunction ClassHandle_isAliasOf(other) {\n if (!(this instanceof ClassHandle)) {\n  return false;\n }\n if (!(other instanceof ClassHandle)) {\n  return false;\n }\n var leftClass = this.$$.ptrType.registeredClass;\n var left = this.$$.ptr;\n var rightClass = other.$$.ptrType.registeredClass;\n var right = other.$$.ptr;\n while (leftClass.baseClass) {\n  left = leftClass.upcast(left);\n  leftClass = leftClass.baseClass;\n }\n while (rightClass.baseClass) {\n  right = rightClass.upcast(right);\n  rightClass = rightClass.baseClass;\n }\n return leftClass === rightClass && left === right;\n}\n\nfunction shallowCopyInternalPointer(o) {\n return {\n  count: o.count,\n  deleteScheduled: o.deleteScheduled,\n  preservePointerOnDelete: o.preservePointerOnDelete,\n  ptr: o.ptr,\n  ptrType: o.ptrType,\n  smartPtr: o.smartPtr,\n  smartPtrType: o.smartPtrType\n };\n}\n\nfunction throwInstanceAlreadyDeleted(obj) {\n function getInstanceTypeName(handle) {\n  return handle.$$.ptrType.registeredClass.name;\n }\n throwBindingError(getInstanceTypeName(obj) + \" instance already deleted\");\n}\n\nfunction ClassHandle_clone() {\n if (!this.$$.ptr) {\n  throwInstanceAlreadyDeleted(this);\n }\n if (this.$$.preservePointerOnDelete) {\n  this.$$.count.value += 1;\n  return this;\n } else {\n  var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {\n   $$: {\n    value: shallowCopyInternalPointer(this.$$)\n   }\n  }));\n  clone.$$.count.value += 1;\n  clone.$$.deleteScheduled = false;\n  return clone;\n }\n}\n\nfunction ClassHandle_delete() {\n if (!this.$$.ptr) {\n  throwInstanceAlreadyDeleted(this);\n }\n if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n  throwBindingError(\"Object already scheduled for deletion\");\n }\n detachFinalizer(this);\n releaseClassHandle(this.$$);\n if (!this.$$.preservePointerOnDelete) {\n  this.$$.smartPtr = undefined;\n  this.$$.ptr = undefined;\n }\n}\n\nfunction ClassHandle_isDeleted() {\n return !this.$$.ptr;\n}\n\nfunction ClassHandle_deleteLater() {\n if (!this.$$.ptr) {\n  throwInstanceAlreadyDeleted(this);\n }\n if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n  throwBindingError(\"Object already scheduled for deletion\");\n }\n deletionQueue.push(this);\n if (deletionQueue.length === 1 && delayFunction) {\n  delayFunction(flushPendingDeletes);\n }\n this.$$.deleteScheduled = true;\n return this;\n}\n\nfunction init_ClassHandle() {\n ClassHandle.prototype[\"isAliasOf\"] = ClassHandle_isAliasOf;\n ClassHandle.prototype[\"clone\"] = ClassHandle_clone;\n ClassHandle.prototype[\"delete\"] = ClassHandle_delete;\n ClassHandle.prototype[\"isDeleted\"] = ClassHandle_isDeleted;\n ClassHandle.prototype[\"deleteLater\"] = ClassHandle_deleteLater;\n}\n\nfunction ClassHandle() {}\n\nvar registeredPointers = {};\n\nfunction ensureOverloadTable(proto, methodName, humanName) {\n if (undefined === proto[methodName].overloadTable) {\n  var prevFunc = proto[methodName];\n  proto[methodName] = function() {\n   if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {\n    throwBindingError(\"Function '\" + humanName + \"' called with an invalid number of arguments (\" + arguments.length + \") - expects one of (\" + proto[methodName].overloadTable + \")!\");\n   }\n   return proto[methodName].overloadTable[arguments.length].apply(this, arguments);\n  };\n  proto[methodName].overloadTable = [];\n  proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\n }\n}\n\nfunction exposePublicSymbol(name, value, numArguments) {\n if (Module.hasOwnProperty(name)) {\n  if (undefined === numArguments || undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments]) {\n   throwBindingError(\"Cannot register public name '\" + name + \"' twice\");\n  }\n  ensureOverloadTable(Module, name, name);\n  if (Module.hasOwnProperty(numArguments)) {\n   throwBindingError(\"Cannot register multiple overloads of a function with the same number of arguments (\" + numArguments + \")!\");\n  }\n  Module[name].overloadTable[numArguments] = value;\n } else {\n  Module[name] = value;\n  if (undefined !== numArguments) {\n   Module[name].numArguments = numArguments;\n  }\n }\n}\n\nfunction RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {\n this.name = name;\n this.constructor = constructor;\n this.instancePrototype = instancePrototype;\n this.rawDestructor = rawDestructor;\n this.baseClass = baseClass;\n this.getActualType = getActualType;\n this.upcast = upcast;\n this.downcast = downcast;\n this.pureVirtualFunctions = [];\n}\n\nfunction upcastPointer(ptr, ptrClass, desiredClass) {\n while (ptrClass !== desiredClass) {\n  if (!ptrClass.upcast) {\n   throwBindingError(\"Expected null or instance of \" + desiredClass.name + \", got an instance of \" + ptrClass.name);\n  }\n  ptr = ptrClass.upcast(ptr);\n  ptrClass = ptrClass.baseClass;\n }\n return ptr;\n}\n\nfunction constNoSmartPtrRawPointerToWireType(destructors, handle) {\n if (handle === null) {\n  if (this.isReference) {\n   throwBindingError(\"null is not a valid \" + this.name);\n  }\n  return 0;\n }\n if (!handle.$$) {\n  throwBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name);\n }\n if (!handle.$$.ptr) {\n  throwBindingError(\"Cannot pass deleted object as a pointer of type \" + this.name);\n }\n var handleClass = handle.$$.ptrType.registeredClass;\n var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n return ptr;\n}\n\nfunction genericPointerToWireType(destructors, handle) {\n var ptr;\n if (handle === null) {\n  if (this.isReference) {\n   throwBindingError(\"null is not a valid \" + this.name);\n  }\n  if (this.isSmartPointer) {\n   ptr = this.rawConstructor();\n   if (destructors !== null) {\n    destructors.push(this.rawDestructor, ptr);\n   }\n   return ptr;\n  } else {\n   return 0;\n  }\n }\n if (!handle.$$) {\n  throwBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name);\n }\n if (!handle.$$.ptr) {\n  throwBindingError(\"Cannot pass deleted object as a pointer of type \" + this.name);\n }\n if (!this.isConst && handle.$$.ptrType.isConst) {\n  throwBindingError(\"Cannot convert argument of type \" + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + \" to parameter type \" + this.name);\n }\n var handleClass = handle.$$.ptrType.registeredClass;\n ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n if (this.isSmartPointer) {\n  if (undefined === handle.$$.smartPtr) {\n   throwBindingError(\"Passing raw pointer to smart pointer is illegal\");\n  }\n  switch (this.sharingPolicy) {\n  case 0:\n   if (handle.$$.smartPtrType === this) {\n    ptr = handle.$$.smartPtr;\n   } else {\n    throwBindingError(\"Cannot convert argument of type \" + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + \" to parameter type \" + this.name);\n   }\n   break;\n\n  case 1:\n   ptr = handle.$$.smartPtr;\n   break;\n\n  case 2:\n   if (handle.$$.smartPtrType === this) {\n    ptr = handle.$$.smartPtr;\n   } else {\n    var clonedHandle = handle[\"clone\"]();\n    ptr = this.rawShare(ptr, __emval_register(function() {\n     clonedHandle[\"delete\"]();\n    }));\n    if (destructors !== null) {\n     destructors.push(this.rawDestructor, ptr);\n    }\n   }\n   break;\n\n  default:\n   throwBindingError(\"Unsupporting sharing policy\");\n  }\n }\n return ptr;\n}\n\nfunction nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {\n if (handle === null) {\n  if (this.isReference) {\n   throwBindingError(\"null is not a valid \" + this.name);\n  }\n  return 0;\n }\n if (!handle.$$) {\n  throwBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name);\n }\n if (!handle.$$.ptr) {\n  throwBindingError(\"Cannot pass deleted object as a pointer of type \" + this.name);\n }\n if (handle.$$.ptrType.isConst) {\n  throwBindingError(\"Cannot convert argument of type \" + handle.$$.ptrType.name + \" to parameter type \" + this.name);\n }\n var handleClass = handle.$$.ptrType.registeredClass;\n var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n return ptr;\n}\n\nfunction RegisteredPointer_getPointee(ptr) {\n if (this.rawGetPointee) {\n  ptr = this.rawGetPointee(ptr);\n }\n return ptr;\n}\n\nfunction RegisteredPointer_destructor(ptr) {\n if (this.rawDestructor) {\n  this.rawDestructor(ptr);\n }\n}\n\nfunction RegisteredPointer_deleteObject(handle) {\n if (handle !== null) {\n  handle[\"delete\"]();\n }\n}\n\nfunction downcastPointer(ptr, ptrClass, desiredClass) {\n if (ptrClass === desiredClass) {\n  return ptr;\n }\n if (undefined === desiredClass.baseClass) {\n  return null;\n }\n var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);\n if (rv === null) {\n  return null;\n }\n return desiredClass.downcast(rv);\n}\n\nfunction getInheritedInstance(class_, ptr) {\n ptr = getBasestPointer(class_, ptr);\n return registeredInstances[ptr];\n}\n\nfunction makeClassHandle(prototype, record) {\n if (!record.ptrType || !record.ptr) {\n  throwInternalError(\"makeClassHandle requires ptr and ptrType\");\n }\n var hasSmartPtrType = !!record.smartPtrType;\n var hasSmartPtr = !!record.smartPtr;\n if (hasSmartPtrType !== hasSmartPtr) {\n  throwInternalError(\"Both smartPtrType and smartPtr must be specified\");\n }\n record.count = {\n  value: 1\n };\n return attachFinalizer(Object.create(prototype, {\n  $$: {\n   value: record\n  }\n }));\n}\n\nfunction RegisteredPointer_fromWireType(ptr) {\n var rawPointer = this.getPointee(ptr);\n if (!rawPointer) {\n  this.destructor(ptr);\n  return null;\n }\n var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);\n if (undefined !== registeredInstance) {\n  if (0 === registeredInstance.$$.count.value) {\n   registeredInstance.$$.ptr = rawPointer;\n   registeredInstance.$$.smartPtr = ptr;\n   return registeredInstance[\"clone\"]();\n  } else {\n   var rv = registeredInstance[\"clone\"]();\n   this.destructor(ptr);\n   return rv;\n  }\n }\n function makeDefaultHandle() {\n  if (this.isSmartPointer) {\n   return makeClassHandle(this.registeredClass.instancePrototype, {\n    ptrType: this.pointeeType,\n    ptr: rawPointer,\n    smartPtrType: this,\n    smartPtr: ptr\n   });\n  } else {\n   return makeClassHandle(this.registeredClass.instancePrototype, {\n    ptrType: this,\n    ptr: ptr\n   });\n  }\n }\n var actualType = this.registeredClass.getActualType(rawPointer);\n var registeredPointerRecord = registeredPointers[actualType];\n if (!registeredPointerRecord) {\n  return makeDefaultHandle.call(this);\n }\n var toType;\n if (this.isConst) {\n  toType = registeredPointerRecord.constPointerType;\n } else {\n  toType = registeredPointerRecord.pointerType;\n }\n var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);\n if (dp === null) {\n  return makeDefaultHandle.call(this);\n }\n if (this.isSmartPointer) {\n  return makeClassHandle(toType.registeredClass.instancePrototype, {\n   ptrType: toType,\n   ptr: dp,\n   smartPtrType: this,\n   smartPtr: ptr\n  });\n } else {\n  return makeClassHandle(toType.registeredClass.instancePrototype, {\n   ptrType: toType,\n   ptr: dp\n  });\n }\n}\n\nfunction init_RegisteredPointer() {\n RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;\n RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;\n RegisteredPointer.prototype[\"argPackAdvance\"] = 8;\n RegisteredPointer.prototype[\"readValueFromPointer\"] = simpleReadValueFromPointer;\n RegisteredPointer.prototype[\"deleteObject\"] = RegisteredPointer_deleteObject;\n RegisteredPointer.prototype[\"fromWireType\"] = RegisteredPointer_fromWireType;\n}\n\nfunction RegisteredPointer(name, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {\n this.name = name;\n this.registeredClass = registeredClass;\n this.isReference = isReference;\n this.isConst = isConst;\n this.isSmartPointer = isSmartPointer;\n this.pointeeType = pointeeType;\n this.sharingPolicy = sharingPolicy;\n this.rawGetPointee = rawGetPointee;\n this.rawConstructor = rawConstructor;\n this.rawShare = rawShare;\n this.rawDestructor = rawDestructor;\n if (!isSmartPointer && registeredClass.baseClass === undefined) {\n  if (isConst) {\n   this[\"toWireType\"] = constNoSmartPtrRawPointerToWireType;\n   this.destructorFunction = null;\n  } else {\n   this[\"toWireType\"] = nonConstNoSmartPtrRawPointerToWireType;\n   this.destructorFunction = null;\n  }\n } else {\n  this[\"toWireType\"] = genericPointerToWireType;\n }\n}\n\nfunction replacePublicSymbol(name, value, numArguments) {\n if (!Module.hasOwnProperty(name)) {\n  throwInternalError(\"Replacing nonexistant public symbol\");\n }\n if (undefined !== Module[name].overloadTable && undefined !== numArguments) {\n  Module[name].overloadTable[numArguments] = value;\n } else {\n  Module[name] = value;\n  Module[name].argCount = numArguments;\n }\n}\n\nfunction embind__requireFunction(signature, rawFunction) {\n signature = readLatin1String(signature);\n function makeDynCaller(dynCall) {\n  var args = [];\n  for (var i = 1; i < signature.length; ++i) {\n   args.push(\"a\" + i);\n  }\n  var name = \"dynCall_\" + signature + \"_\" + rawFunction;\n  var body = \"return function \" + name + \"(\" + args.join(\", \") + \") {\\n\";\n  body += \"    return dynCall(rawFunction\" + (args.length ? \", \" : \"\") + args.join(\", \") + \");\\n\";\n  body += \"};\\n\";\n  return new Function(\"dynCall\", \"rawFunction\", body)(dynCall, rawFunction);\n }\n var dc = Module[\"dynCall_\" + signature];\n var fp = makeDynCaller(dc);\n if (typeof fp !== \"function\") {\n  throwBindingError(\"unknown function pointer with signature \" + signature + \": \" + rawFunction);\n }\n return fp;\n}\n\nvar UnboundTypeError = undefined;\n\nfunction throwUnboundTypeError(message, types) {\n var unboundTypes = [];\n var seen = {};\n function visit(type) {\n  if (seen[type]) {\n   return;\n  }\n  if (registeredTypes[type]) {\n   return;\n  }\n  if (typeDependencies[type]) {\n   typeDependencies[type].forEach(visit);\n   return;\n  }\n  unboundTypes.push(type);\n  seen[type] = true;\n }\n types.forEach(visit);\n throw new UnboundTypeError(message + \": \" + unboundTypes.map(getTypeName).join([ \", \" ]));\n}\n\nfunction __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name, destructorSignature, rawDestructor) {\n name = readLatin1String(name);\n getActualType = embind__requireFunction(getActualTypeSignature, getActualType);\n if (upcast) {\n  upcast = embind__requireFunction(upcastSignature, upcast);\n }\n if (downcast) {\n  downcast = embind__requireFunction(downcastSignature, downcast);\n }\n rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\n var legalFunctionName = makeLegalFunctionName(name);\n exposePublicSymbol(legalFunctionName, function() {\n  throwUnboundTypeError(\"Cannot construct \" + name + \" due to unbound types\", [ baseClassRawType ]);\n });\n whenDependentTypesAreResolved([ rawType, rawPointerType, rawConstPointerType ], baseClassRawType ? [ baseClassRawType ] : [], function(base) {\n  base = base[0];\n  var baseClass;\n  var basePrototype;\n  if (baseClassRawType) {\n   baseClass = base.registeredClass;\n   basePrototype = baseClass.instancePrototype;\n  } else {\n   basePrototype = ClassHandle.prototype;\n  }\n  var constructor = createNamedFunction(legalFunctionName, function() {\n   if (Object.getPrototypeOf(this) !== instancePrototype) {\n    throw new BindingError(\"Use 'new' to construct \" + name);\n   }\n   if (undefined === registeredClass.constructor_body) {\n    throw new BindingError(name + \" has no accessible constructor\");\n   }\n   var body = registeredClass.constructor_body[arguments.length];\n   if (undefined === body) {\n    throw new BindingError(\"Tried to invoke ctor of \" + name + \" with invalid number of parameters (\" + arguments.length + \") - expected (\" + Object.keys(registeredClass.constructor_body).toString() + \") parameters instead!\");\n   }\n   return body.apply(this, arguments);\n  });\n  var instancePrototype = Object.create(basePrototype, {\n   constructor: {\n    value: constructor\n   }\n  });\n  constructor.prototype = instancePrototype;\n  var registeredClass = new RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);\n  var referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false);\n  var pointerConverter = new RegisteredPointer(name + \"*\", registeredClass, false, false, false);\n  var constPointerConverter = new RegisteredPointer(name + \" const*\", registeredClass, false, true, false);\n  registeredPointers[rawType] = {\n   pointerType: pointerConverter,\n   constPointerType: constPointerConverter\n  };\n  replacePublicSymbol(legalFunctionName, constructor);\n  return [ referenceConverter, pointerConverter, constPointerConverter ];\n });\n}\n\nfunction new_(constructor, argumentList) {\n if (!(constructor instanceof Function)) {\n  throw new TypeError(\"new_ called with constructor type \" + typeof constructor + \" which is not a function\");\n }\n var dummy = createNamedFunction(constructor.name || \"unknownFunctionName\", function() {});\n dummy.prototype = constructor.prototype;\n var obj = new dummy();\n var r = constructor.apply(obj, argumentList);\n return r instanceof Object ? r : obj;\n}\n\nfunction craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {\n var argCount = argTypes.length;\n if (argCount < 2) {\n  throwBindingError(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\n }\n var isClassMethodFunc = argTypes[1] !== null && classType !== null;\n var needsDestructorStack = false;\n for (var i = 1; i < argTypes.length; ++i) {\n  if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {\n   needsDestructorStack = true;\n   break;\n  }\n }\n var returns = argTypes[0].name !== \"void\";\n var argsList = \"\";\n var argsListWired = \"\";\n for (var i = 0; i < argCount - 2; ++i) {\n  argsList += (i !== 0 ? \", \" : \"\") + \"arg\" + i;\n  argsListWired += (i !== 0 ? \", \" : \"\") + \"arg\" + i + \"Wired\";\n }\n var invokerFnBody = \"return function \" + makeLegalFunctionName(humanName) + \"(\" + argsList + \") {\\n\" + \"if (arguments.length !== \" + (argCount - 2) + \") {\\n\" + \"throwBindingError('function \" + humanName + \" called with ' + arguments.length + ' arguments, expected \" + (argCount - 2) + \" args!');\\n\" + \"}\\n\";\n if (needsDestructorStack) {\n  invokerFnBody += \"var destructors = [];\\n\";\n }\n var dtorStack = needsDestructorStack ? \"destructors\" : \"null\";\n var args1 = [ \"throwBindingError\", \"invoker\", \"fn\", \"runDestructors\", \"retType\", \"classParam\" ];\n var args2 = [ throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1] ];\n if (isClassMethodFunc) {\n  invokerFnBody += \"var thisWired = classParam.toWireType(\" + dtorStack + \", this);\\n\";\n }\n for (var i = 0; i < argCount - 2; ++i) {\n  invokerFnBody += \"var arg\" + i + \"Wired = argType\" + i + \".toWireType(\" + dtorStack + \", arg\" + i + \"); // \" + argTypes[i + 2].name + \"\\n\";\n  args1.push(\"argType\" + i);\n  args2.push(argTypes[i + 2]);\n }\n if (isClassMethodFunc) {\n  argsListWired = \"thisWired\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired;\n }\n invokerFnBody += (returns ? \"var rv = \" : \"\") + \"invoker(fn\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired + \");\\n\";\n if (needsDestructorStack) {\n  invokerFnBody += \"runDestructors(destructors);\\n\";\n } else {\n  for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {\n   var paramName = i === 1 ? \"thisWired\" : \"arg\" + (i - 2) + \"Wired\";\n   if (argTypes[i].destructorFunction !== null) {\n    invokerFnBody += paramName + \"_dtor(\" + paramName + \"); // \" + argTypes[i].name + \"\\n\";\n    args1.push(paramName + \"_dtor\");\n    args2.push(argTypes[i].destructorFunction);\n   }\n  }\n }\n if (returns) {\n  invokerFnBody += \"var ret = retType.fromWireType(rv);\\n\" + \"return ret;\\n\";\n } else {}\n invokerFnBody += \"}\\n\";\n args1.push(invokerFnBody);\n var invokerFunction = new_(Function, args1).apply(null, args2);\n return invokerFunction;\n}\n\nfunction heap32VectorToArray(count, firstElement) {\n var array = [];\n for (var i = 0; i < count; i++) {\n  array.push(HEAP32[(firstElement >> 2) + i]);\n }\n return array;\n}\n\nfunction __embind_register_class_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, fn) {\n var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n methodName = readLatin1String(methodName);\n rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);\n whenDependentTypesAreResolved([], [ rawClassType ], function(classType) {\n  classType = classType[0];\n  var humanName = classType.name + \".\" + methodName;\n  function unboundTypesHandler() {\n   throwUnboundTypeError(\"Cannot call \" + humanName + \" due to unbound types\", rawArgTypes);\n  }\n  var proto = classType.registeredClass.constructor;\n  if (undefined === proto[methodName]) {\n   unboundTypesHandler.argCount = argCount - 1;\n   proto[methodName] = unboundTypesHandler;\n  } else {\n   ensureOverloadTable(proto, methodName, humanName);\n   proto[methodName].overloadTable[argCount - 1] = unboundTypesHandler;\n  }\n  whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {\n   var invokerArgsArray = [ argTypes[0], null ].concat(argTypes.slice(1));\n   var func = craftInvokerFunction(humanName, invokerArgsArray, null, rawInvoker, fn);\n   if (undefined === proto[methodName].overloadTable) {\n    func.argCount = argCount - 1;\n    proto[methodName] = func;\n   } else {\n    proto[methodName].overloadTable[argCount - 1] = func;\n   }\n   return [];\n  });\n  return [];\n });\n}\n\nfunction validateThis(this_, classType, humanName) {\n if (!(this_ instanceof Object)) {\n  throwBindingError(humanName + ' with invalid \"this\": ' + this_);\n }\n if (!(this_ instanceof classType.registeredClass.constructor)) {\n  throwBindingError(humanName + ' incompatible with \"this\" of type ' + this_.constructor.name);\n }\n if (!this_.$$.ptr) {\n  throwBindingError(\"cannot call emscripten binding method \" + humanName + \" on deleted object\");\n }\n return upcastPointer(this_.$$.ptr, this_.$$.ptrType.registeredClass, classType.registeredClass);\n}\n\nfunction __embind_register_class_class_property(rawClassType, fieldName, rawFieldType, rawFieldPtr, getterSignature, getter, setterSignature, setter) {\n fieldName = readLatin1String(fieldName);\n getter = embind__requireFunction(getterSignature, getter);\n whenDependentTypesAreResolved([], [ rawClassType ], function(classType) {\n  classType = classType[0];\n  var humanName = classType.name + \".\" + fieldName;\n  var desc = {\n   get: function() {\n    throwUnboundTypeError(\"Cannot access \" + humanName + \" due to unbound types\", [ rawFieldType ]);\n   },\n   enumerable: true,\n   configurable: true\n  };\n  if (setter) {\n   desc.set = function() {\n    throwUnboundTypeError(\"Cannot access \" + humanName + \" due to unbound types\", [ rawFieldType ]);\n   };\n  } else {\n   desc.set = function(v) {\n    throwBindingError(humanName + \" is a read-only property\");\n   };\n  }\n  Object.defineProperty(classType.registeredClass.constructor, fieldName, desc);\n  whenDependentTypesAreResolved([], [ rawFieldType ], function(fieldType) {\n   fieldType = fieldType[0];\n   var desc = {\n    get: function() {\n     return fieldType[\"fromWireType\"](getter(rawFieldPtr));\n    },\n    enumerable: true\n   };\n   if (setter) {\n    setter = embind__requireFunction(setterSignature, setter);\n    desc.set = function(v) {\n     var destructors = [];\n     setter(rawFieldPtr, fieldType[\"toWireType\"](destructors, v));\n     runDestructors(destructors);\n    };\n   }\n   Object.defineProperty(classType.registeredClass.constructor, fieldName, desc);\n   return [];\n  });\n  return [];\n });\n}\n\nfunction __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {\n assert(argCount > 0);\n var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n invoker = embind__requireFunction(invokerSignature, invoker);\n var args = [ rawConstructor ];\n var destructors = [];\n whenDependentTypesAreResolved([], [ rawClassType ], function(classType) {\n  classType = classType[0];\n  var humanName = \"constructor \" + classType.name;\n  if (undefined === classType.registeredClass.constructor_body) {\n   classType.registeredClass.constructor_body = [];\n  }\n  if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {\n   throw new BindingError(\"Cannot register multiple constructors with identical number of parameters (\" + (argCount - 1) + \") for class '\" + classType.name + \"'! Overload resolution is currently only performed using the parameter count, not actual type info!\");\n  }\n  classType.registeredClass.constructor_body[argCount - 1] = function unboundTypeHandler() {\n   throwUnboundTypeError(\"Cannot construct \" + classType.name + \" due to unbound types\", rawArgTypes);\n  };\n  whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {\n   classType.registeredClass.constructor_body[argCount - 1] = function constructor_body() {\n    if (arguments.length !== argCount - 1) {\n     throwBindingError(humanName + \" called with \" + arguments.length + \" arguments, expected \" + (argCount - 1));\n    }\n    destructors.length = 0;\n    args.length = argCount;\n    for (var i = 1; i < argCount; ++i) {\n     args[i] = argTypes[i][\"toWireType\"](destructors, arguments[i - 1]);\n    }\n    var ptr = invoker.apply(null, args);\n    runDestructors(destructors);\n    return argTypes[0][\"fromWireType\"](ptr);\n   };\n   return [];\n  });\n  return [];\n });\n}\n\nfunction __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual) {\n var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n methodName = readLatin1String(methodName);\n rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);\n whenDependentTypesAreResolved([], [ rawClassType ], function(classType) {\n  classType = classType[0];\n  var humanName = classType.name + \".\" + methodName;\n  if (isPureVirtual) {\n   classType.registeredClass.pureVirtualFunctions.push(methodName);\n  }\n  function unboundTypesHandler() {\n   throwUnboundTypeError(\"Cannot call \" + humanName + \" due to unbound types\", rawArgTypes);\n  }\n  var proto = classType.registeredClass.instancePrototype;\n  var method = proto[methodName];\n  if (undefined === method || undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {\n   unboundTypesHandler.argCount = argCount - 2;\n   unboundTypesHandler.className = classType.name;\n   proto[methodName] = unboundTypesHandler;\n  } else {\n   ensureOverloadTable(proto, methodName, humanName);\n   proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;\n  }\n  whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {\n   var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);\n   if (undefined === proto[methodName].overloadTable) {\n    memberFunction.argCount = argCount - 2;\n    proto[methodName] = memberFunction;\n   } else {\n    proto[methodName].overloadTable[argCount - 2] = memberFunction;\n   }\n   return [];\n  });\n  return [];\n });\n}\n\nfunction __embind_register_class_property(classType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {\n fieldName = readLatin1String(fieldName);\n getter = embind__requireFunction(getterSignature, getter);\n whenDependentTypesAreResolved([], [ classType ], function(classType) {\n  classType = classType[0];\n  var humanName = classType.name + \".\" + fieldName;\n  var desc = {\n   get: function() {\n    throwUnboundTypeError(\"Cannot access \" + humanName + \" due to unbound types\", [ getterReturnType, setterArgumentType ]);\n   },\n   enumerable: true,\n   configurable: true\n  };\n  if (setter) {\n   desc.set = function() {\n    throwUnboundTypeError(\"Cannot access \" + humanName + \" due to unbound types\", [ getterReturnType, setterArgumentType ]);\n   };\n  } else {\n   desc.set = function(v) {\n    throwBindingError(humanName + \" is a read-only property\");\n   };\n  }\n  Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);\n  whenDependentTypesAreResolved([], setter ? [ getterReturnType, setterArgumentType ] : [ getterReturnType ], function(types) {\n   var getterReturnType = types[0];\n   var desc = {\n    get: function() {\n     var ptr = validateThis(this, classType, humanName + \" getter\");\n     return getterReturnType[\"fromWireType\"](getter(getterContext, ptr));\n    },\n    enumerable: true\n   };\n   if (setter) {\n    setter = embind__requireFunction(setterSignature, setter);\n    var setterArgumentType = types[1];\n    desc.set = function(v) {\n     var ptr = validateThis(this, classType, humanName + \" setter\");\n     var destructors = [];\n     setter(setterContext, ptr, setterArgumentType[\"toWireType\"](destructors, v));\n     runDestructors(destructors);\n    };\n   }\n   Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);\n   return [];\n  });\n  return [];\n });\n}\n\nfunction __emval_decref(handle) {\n if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {\n  emval_handle_array[handle] = undefined;\n  emval_free_list.push(handle);\n }\n}\n\nfunction __embind_register_emval(rawType, name) {\n name = readLatin1String(name);\n registerType(rawType, {\n  name: name,\n  \"fromWireType\": function(handle) {\n   var rv = emval_handle_array[handle].value;\n   __emval_decref(handle);\n   return rv;\n  },\n  \"toWireType\": function(destructors, value) {\n   return __emval_register(value);\n  },\n  \"argPackAdvance\": 8,\n  \"readValueFromPointer\": simpleReadValueFromPointer,\n  destructorFunction: null\n });\n}\n\nfunction enumReadValueFromPointer(name, shift, signed) {\n switch (shift) {\n case 0:\n  return function(pointer) {\n   var heap = signed ? HEAP8 : HEAPU8;\n   return this[\"fromWireType\"](heap[pointer]);\n  };\n\n case 1:\n  return function(pointer) {\n   var heap = signed ? HEAP16 : HEAPU16;\n   return this[\"fromWireType\"](heap[pointer >> 1]);\n  };\n\n case 2:\n  return function(pointer) {\n   var heap = signed ? HEAP32 : HEAPU32;\n   return this[\"fromWireType\"](heap[pointer >> 2]);\n  };\n\n default:\n  throw new TypeError(\"Unknown integer type: \" + name);\n }\n}\n\nfunction __embind_register_enum(rawType, name, size, isSigned) {\n var shift = getShiftFromSize(size);\n name = readLatin1String(name);\n function ctor() {}\n ctor.values = {};\n registerType(rawType, {\n  name: name,\n  constructor: ctor,\n  \"fromWireType\": function(c) {\n   return this.constructor.values[c];\n  },\n  \"toWireType\": function(destructors, c) {\n   return c.value;\n  },\n  \"argPackAdvance\": 8,\n  \"readValueFromPointer\": enumReadValueFromPointer(name, shift, isSigned),\n  destructorFunction: null\n });\n exposePublicSymbol(name, ctor);\n}\n\nfunction __embind_register_enum_value(rawEnumType, name, enumValue) {\n var enumType = requireRegisteredType(rawEnumType, \"enum\");\n name = readLatin1String(name);\n var Enum = enumType.constructor;\n var Value = Object.create(enumType.constructor.prototype, {\n  value: {\n   value: enumValue\n  },\n  constructor: {\n   value: createNamedFunction(enumType.name + \"_\" + name, function() {})\n  }\n });\n Enum.values[enumValue] = Value;\n Enum[name] = Value;\n}\n\nfunction _embind_repr(v) {\n if (v === null) {\n  return \"null\";\n }\n var t = typeof v;\n if (t === \"object\" || t === \"array\" || t === \"function\") {\n  return v.toString();\n } else {\n  return \"\" + v;\n }\n}\n\nfunction floatReadValueFromPointer(name, shift) {\n switch (shift) {\n case 2:\n  return function(pointer) {\n   return this[\"fromWireType\"](HEAPF32[pointer >> 2]);\n  };\n\n case 3:\n  return function(pointer) {\n   return this[\"fromWireType\"](HEAPF64[pointer >> 3]);\n  };\n\n default:\n  throw new TypeError(\"Unknown float type: \" + name);\n }\n}\n\nfunction __embind_register_float(rawType, name, size) {\n var shift = getShiftFromSize(size);\n name = readLatin1String(name);\n registerType(rawType, {\n  name: name,\n  \"fromWireType\": function(value) {\n   return value;\n  },\n  \"toWireType\": function(destructors, value) {\n   if (typeof value !== \"number\" && typeof value !== \"boolean\") {\n    throw new TypeError('Cannot convert \"' + _embind_repr(value) + '\" to ' + this.name);\n   }\n   return value;\n  },\n  \"argPackAdvance\": 8,\n  \"readValueFromPointer\": floatReadValueFromPointer(name, shift),\n  destructorFunction: null\n });\n}\n\nfunction __embind_register_function(name, argCount, rawArgTypesAddr, signature, rawInvoker, fn) {\n var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n name = readLatin1String(name);\n rawInvoker = embind__requireFunction(signature, rawInvoker);\n exposePublicSymbol(name, function() {\n  throwUnboundTypeError(\"Cannot call \" + name + \" due to unbound types\", argTypes);\n }, argCount - 1);\n whenDependentTypesAreResolved([], argTypes, function(argTypes) {\n  var invokerArgsArray = [ argTypes[0], null ].concat(argTypes.slice(1));\n  replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null, rawInvoker, fn), argCount - 1);\n  return [];\n });\n}\n\nfunction integerReadValueFromPointer(name, shift, signed) {\n switch (shift) {\n case 0:\n  return signed ? function readS8FromPointer(pointer) {\n   return HEAP8[pointer];\n  } : function readU8FromPointer(pointer) {\n   return HEAPU8[pointer];\n  };\n\n case 1:\n  return signed ? function readS16FromPointer(pointer) {\n   return HEAP16[pointer >> 1];\n  } : function readU16FromPointer(pointer) {\n   return HEAPU16[pointer >> 1];\n  };\n\n case 2:\n  return signed ? function readS32FromPointer(pointer) {\n   return HEAP32[pointer >> 2];\n  } : function readU32FromPointer(pointer) {\n   return HEAPU32[pointer >> 2];\n  };\n\n default:\n  throw new TypeError(\"Unknown integer type: \" + name);\n }\n}\n\nfunction __embind_register_integer(primitiveType, name, size, minRange, maxRange) {\n name = readLatin1String(name);\n if (maxRange === -1) {\n  maxRange = 4294967295;\n }\n var shift = getShiftFromSize(size);\n var fromWireType = function(value) {\n  return value;\n };\n if (minRange === 0) {\n  var bitshift = 32 - 8 * size;\n  fromWireType = function(value) {\n   return value << bitshift >>> bitshift;\n  };\n }\n var isUnsignedType = name.indexOf(\"unsigned\") != -1;\n registerType(primitiveType, {\n  name: name,\n  \"fromWireType\": fromWireType,\n  \"toWireType\": function(destructors, value) {\n   if (typeof value !== \"number\" && typeof value !== \"boolean\") {\n    throw new TypeError('Cannot convert \"' + _embind_repr(value) + '\" to ' + this.name);\n   }\n   if (value < minRange || value > maxRange) {\n    throw new TypeError('Passing a number \"' + _embind_repr(value) + '\" from JS side to C/C++ side to an argument of type \"' + name + '\", which is outside the valid range [' + minRange + \", \" + maxRange + \"]!\");\n   }\n   return isUnsignedType ? value >>> 0 : value | 0;\n  },\n  \"argPackAdvance\": 8,\n  \"readValueFromPointer\": integerReadValueFromPointer(name, shift, minRange !== 0),\n  destructorFunction: null\n });\n}\n\nfunction __embind_register_memory_view(rawType, dataTypeIndex, name) {\n var typeMapping = [ Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array ];\n var TA = typeMapping[dataTypeIndex];\n function decodeMemoryView(handle) {\n  handle = handle >> 2;\n  var heap = HEAPU32;\n  var size = heap[handle];\n  var data = heap[handle + 1];\n  return new TA(buffer, data, size);\n }\n name = readLatin1String(name);\n registerType(rawType, {\n  name: name,\n  \"fromWireType\": decodeMemoryView,\n  \"argPackAdvance\": 8,\n  \"readValueFromPointer\": decodeMemoryView\n }, {\n  ignoreDuplicateRegistrations: true\n });\n}\n\nfunction __embind_register_std_string(rawType, name) {\n name = readLatin1String(name);\n var stdStringIsUTF8 = name === \"std::string\";\n registerType(rawType, {\n  name: name,\n  \"fromWireType\": function(value) {\n   var length = HEAPU32[value >> 2];\n   var str;\n   if (stdStringIsUTF8) {\n    var decodeStartPtr = value + 4;\n    for (var i = 0; i <= length; ++i) {\n     var currentBytePtr = value + 4 + i;\n     if (i == length || HEAPU8[currentBytePtr] == 0) {\n      var maxRead = currentBytePtr - decodeStartPtr;\n      var stringSegment = UTF8ToString(decodeStartPtr, maxRead);\n      if (str === undefined) {\n       str = stringSegment;\n      } else {\n       str += String.fromCharCode(0);\n       str += stringSegment;\n      }\n      decodeStartPtr = currentBytePtr + 1;\n     }\n    }\n   } else {\n    var a = new Array(length);\n    for (var i = 0; i < length; ++i) {\n     a[i] = String.fromCharCode(HEAPU8[value + 4 + i]);\n    }\n    str = a.join(\"\");\n   }\n   _free(value);\n   return str;\n  },\n  \"toWireType\": function(destructors, value) {\n   if (value instanceof ArrayBuffer) {\n    value = new Uint8Array(value);\n   }\n   var getLength;\n   var valueIsOfTypeString = typeof value === \"string\";\n   if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {\n    throwBindingError(\"Cannot pass non-string to std::string\");\n   }\n   if (stdStringIsUTF8 && valueIsOfTypeString) {\n    getLength = function() {\n     return lengthBytesUTF8(value);\n    };\n   } else {\n    getLength = function() {\n     return value.length;\n    };\n   }\n   var length = getLength();\n   var ptr = _malloc(4 + length + 1);\n   HEAPU32[ptr >> 2] = length;\n   if (stdStringIsUTF8 && valueIsOfTypeString) {\n    stringToUTF8(value, ptr + 4, length + 1);\n   } else {\n    if (valueIsOfTypeString) {\n     for (var i = 0; i < length; ++i) {\n      var charCode = value.charCodeAt(i);\n      if (charCode > 255) {\n       _free(ptr);\n       throwBindingError(\"String has UTF-16 code units that do not fit in 8 bits\");\n      }\n      HEAPU8[ptr + 4 + i] = charCode;\n     }\n    } else {\n     for (var i = 0; i < length; ++i) {\n      HEAPU8[ptr + 4 + i] = value[i];\n     }\n    }\n   }\n   if (destructors !== null) {\n    destructors.push(_free, ptr);\n   }\n   return ptr;\n  },\n  \"argPackAdvance\": 8,\n  \"readValueFromPointer\": simpleReadValueFromPointer,\n  destructorFunction: function(ptr) {\n   _free(ptr);\n  }\n });\n}\n\nfunction __embind_register_std_wstring(rawType, charSize, name) {\n name = readLatin1String(name);\n var decodeString, encodeString, getHeap, lengthBytesUTF, shift;\n if (charSize === 2) {\n  decodeString = UTF16ToString;\n  encodeString = stringToUTF16;\n  lengthBytesUTF = lengthBytesUTF16;\n  getHeap = function() {\n   return HEAPU16;\n  };\n  shift = 1;\n } else if (charSize === 4) {\n  decodeString = UTF32ToString;\n  encodeString = stringToUTF32;\n  lengthBytesUTF = lengthBytesUTF32;\n  getHeap = function() {\n   return HEAPU32;\n  };\n  shift = 2;\n }\n registerType(rawType, {\n  name: name,\n  \"fromWireType\": function(value) {\n   var length = HEAPU32[value >> 2];\n   var HEAP = getHeap();\n   var str;\n   var decodeStartPtr = value + 4;\n   for (var i = 0; i <= length; ++i) {\n    var currentBytePtr = value + 4 + i * charSize;\n    if (i == length || HEAP[currentBytePtr >> shift] == 0) {\n     var maxReadBytes = currentBytePtr - decodeStartPtr;\n     var stringSegment = decodeString(decodeStartPtr, maxReadBytes);\n     if (str === undefined) {\n      str = stringSegment;\n     } else {\n      str += String.fromCharCode(0);\n      str += stringSegment;\n     }\n     decodeStartPtr = currentBytePtr + charSize;\n    }\n   }\n   _free(value);\n   return str;\n  },\n  \"toWireType\": function(destructors, value) {\n   if (!(typeof value === \"string\")) {\n    throwBindingError(\"Cannot pass non-string to C++ string type \" + name);\n   }\n   var length = lengthBytesUTF(value);\n   var ptr = _malloc(4 + length + charSize);\n   HEAPU32[ptr >> 2] = length >> shift;\n   encodeString(value, ptr + 4, length + charSize);\n   if (destructors !== null) {\n    destructors.push(_free, ptr);\n   }\n   return ptr;\n  },\n  \"argPackAdvance\": 8,\n  \"readValueFromPointer\": simpleReadValueFromPointer,\n  destructorFunction: function(ptr) {\n   _free(ptr);\n  }\n });\n}\n\nfunction __embind_register_value_object(rawType, name, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {\n structRegistrations[rawType] = {\n  name: readLatin1String(name),\n  rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),\n  rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),\n  fields: []\n };\n}\n\nfunction __embind_register_value_object_field(structType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {\n structRegistrations[structType].fields.push({\n  fieldName: readLatin1String(fieldName),\n  getterReturnType: getterReturnType,\n  getter: embind__requireFunction(getterSignature, getter),\n  getterContext: getterContext,\n  setterArgumentType: setterArgumentType,\n  setter: embind__requireFunction(setterSignature, setter),\n  setterContext: setterContext\n });\n}\n\nfunction __embind_register_void(rawType, name) {\n name = readLatin1String(name);\n registerType(rawType, {\n  isVoid: true,\n  name: name,\n  \"argPackAdvance\": 0,\n  \"fromWireType\": function() {\n   return undefined;\n  },\n  \"toWireType\": function(destructors, o) {\n   return undefined;\n  }\n });\n}\n\nfunction __emval_as(handle, returnType, destructorsRef) {\n handle = requireHandle(handle);\n returnType = requireRegisteredType(returnType, \"emval::as\");\n var destructors = [];\n var rd = __emval_register(destructors);\n HEAP32[destructorsRef >> 2] = rd;\n return returnType[\"toWireType\"](destructors, handle);\n}\n\nfunction __emval_allocateDestructors(destructorsRef) {\n var destructors = [];\n HEAP32[destructorsRef >> 2] = __emval_register(destructors);\n return destructors;\n}\n\nvar emval_symbols = {};\n\nfunction getStringOrSymbol(address) {\n var symbol = emval_symbols[address];\n if (symbol === undefined) {\n  return readLatin1String(address);\n } else {\n  return symbol;\n }\n}\n\nvar emval_methodCallers = [];\n\nfunction __emval_call_method(caller, handle, methodName, destructorsRef, args) {\n caller = emval_methodCallers[caller];\n handle = requireHandle(handle);\n methodName = getStringOrSymbol(methodName);\n return caller(handle, methodName, __emval_allocateDestructors(destructorsRef), args);\n}\n\nfunction __emval_call_void_method(caller, handle, methodName, args) {\n caller = emval_methodCallers[caller];\n handle = requireHandle(handle);\n methodName = getStringOrSymbol(methodName);\n caller(handle, methodName, null, args);\n}\n\nfunction __emval_addMethodCaller(caller) {\n var id = emval_methodCallers.length;\n emval_methodCallers.push(caller);\n return id;\n}\n\nfunction __emval_lookupTypes(argCount, argTypes) {\n var a = new Array(argCount);\n for (var i = 0; i < argCount; ++i) {\n  a[i] = requireRegisteredType(HEAP32[(argTypes >> 2) + i], \"parameter \" + i);\n }\n return a;\n}\n\nfunction __emval_get_method_caller(argCount, argTypes) {\n var types = __emval_lookupTypes(argCount, argTypes);\n var retType = types[0];\n var signatureName = retType.name + \"_$\" + types.slice(1).map(function(t) {\n  return t.name;\n }).join(\"_\") + \"$\";\n var params = [ \"retType\" ];\n var args = [ retType ];\n var argsList = \"\";\n for (var i = 0; i < argCount - 1; ++i) {\n  argsList += (i !== 0 ? \", \" : \"\") + \"arg\" + i;\n  params.push(\"argType\" + i);\n  args.push(types[1 + i]);\n }\n var functionName = makeLegalFunctionName(\"methodCaller_\" + signatureName);\n var functionBody = \"return function \" + functionName + \"(handle, name, destructors, args) {\\n\";\n var offset = 0;\n for (var i = 0; i < argCount - 1; ++i) {\n  functionBody += \"    var arg\" + i + \" = argType\" + i + \".readValueFromPointer(args\" + (offset ? \"+\" + offset : \"\") + \");\\n\";\n  offset += types[i + 1][\"argPackAdvance\"];\n }\n functionBody += \"    var rv = handle[name](\" + argsList + \");\\n\";\n for (var i = 0; i < argCount - 1; ++i) {\n  if (types[i + 1][\"deleteObject\"]) {\n   functionBody += \"    argType\" + i + \".deleteObject(arg\" + i + \");\\n\";\n  }\n }\n if (!retType.isVoid) {\n  functionBody += \"    return retType.toWireType(destructors, rv);\\n\";\n }\n functionBody += \"};\\n\";\n params.push(functionBody);\n var invokerFunction = new_(Function, params).apply(null, args);\n return __emval_addMethodCaller(invokerFunction);\n}\n\nfunction __emval_get_module_property(name) {\n name = getStringOrSymbol(name);\n return __emval_register(Module[name]);\n}\n\nfunction __emval_get_property(handle, key) {\n handle = requireHandle(handle);\n key = requireHandle(key);\n return __emval_register(handle[key]);\n}\n\nfunction __emval_incref(handle) {\n if (handle > 4) {\n  emval_handle_array[handle].refcount += 1;\n }\n}\n\nfunction __emval_new_cstring(v) {\n return __emval_register(getStringOrSymbol(v));\n}\n\nfunction __emval_run_destructors(handle) {\n var destructors = emval_handle_array[handle].value;\n runDestructors(destructors);\n __emval_decref(handle);\n}\n\nfunction __emval_take_value(type, argv) {\n type = requireRegisteredType(type, \"_emval_take_value\");\n var v = type[\"readValueFromPointer\"](argv);\n return __emval_register(v);\n}\n\nfunction _abort() {\n abort();\n}\n\nfunction _emscripten_memcpy_big(dest, src, num) {\n HEAPU8.copyWithin(dest, src, src + num);\n}\n\nfunction _emscripten_get_heap_size() {\n return HEAPU8.length;\n}\n\nfunction emscripten_realloc_buffer(size) {\n try {\n  wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);\n  updateGlobalBufferAndViews(wasmMemory.buffer);\n  return 1;\n } catch (e) {}\n}\n\nfunction _emscripten_resize_heap(requestedSize) {\n requestedSize = requestedSize >>> 0;\n var oldSize = _emscripten_get_heap_size();\n var PAGE_MULTIPLE = 65536;\n var maxHeapSize = 2147483648;\n if (requestedSize > maxHeapSize) {\n  return false;\n }\n var minHeapSize = 16777216;\n for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n  var overGrownHeapSize = oldSize * (1 + .2 / cutDown);\n  overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\n  var newSize = Math.min(maxHeapSize, alignUp(Math.max(minHeapSize, requestedSize, overGrownHeapSize), PAGE_MULTIPLE));\n  var replacement = emscripten_realloc_buffer(newSize);\n  if (replacement) {\n   return true;\n  }\n }\n return false;\n}\n\nvar PATH = {\n splitPath: function(filename) {\n  var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n  return splitPathRe.exec(filename).slice(1);\n },\n normalizeArray: function(parts, allowAboveRoot) {\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n   var last = parts[i];\n   if (last === \".\") {\n    parts.splice(i, 1);\n   } else if (last === \"..\") {\n    parts.splice(i, 1);\n    up++;\n   } else if (up) {\n    parts.splice(i, 1);\n    up--;\n   }\n  }\n  if (allowAboveRoot) {\n   for (;up; up--) {\n    parts.unshift(\"..\");\n   }\n  }\n  return parts;\n },\n normalize: function(path) {\n  var isAbsolute = path.charAt(0) === \"/\", trailingSlash = path.substr(-1) === \"/\";\n  path = PATH.normalizeArray(path.split(\"/\").filter(function(p) {\n   return !!p;\n  }), !isAbsolute).join(\"/\");\n  if (!path && !isAbsolute) {\n   path = \".\";\n  }\n  if (path && trailingSlash) {\n   path += \"/\";\n  }\n  return (isAbsolute ? \"/\" : \"\") + path;\n },\n dirname: function(path) {\n  var result = PATH.splitPath(path), root = result[0], dir = result[1];\n  if (!root && !dir) {\n   return \".\";\n  }\n  if (dir) {\n   dir = dir.substr(0, dir.length - 1);\n  }\n  return root + dir;\n },\n basename: function(path) {\n  if (path === \"/\") return \"/\";\n  var lastSlash = path.lastIndexOf(\"/\");\n  if (lastSlash === -1) return path;\n  return path.substr(lastSlash + 1);\n },\n extname: function(path) {\n  return PATH.splitPath(path)[3];\n },\n join: function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return PATH.normalize(paths.join(\"/\"));\n },\n join2: function(l, r) {\n  return PATH.normalize(l + \"/\" + r);\n }\n};\n\nvar SYSCALLS = {\n mappings: {},\n buffers: [ null, [], [] ],\n printChar: function(stream, curr) {\n  var buffer = SYSCALLS.buffers[stream];\n  if (curr === 0 || curr === 10) {\n   (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));\n   buffer.length = 0;\n  } else {\n   buffer.push(curr);\n  }\n },\n varargs: undefined,\n get: function() {\n  SYSCALLS.varargs += 4;\n  var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];\n  return ret;\n },\n getStr: function(ptr) {\n  var ret = UTF8ToString(ptr);\n  return ret;\n },\n get64: function(low, high) {\n  return low;\n }\n};\n\nfunction _fd_close(fd) {\n return 0;\n}\n\nfunction _fd_seek(fd, offset_low, offset_high, whence, newOffset) {}\n\nfunction _fd_write(fd, iov, iovcnt, pnum) {\n var num = 0;\n for (var i = 0; i < iovcnt; i++) {\n  var ptr = HEAP32[iov + i * 8 >> 2];\n  var len = HEAP32[iov + (i * 8 + 4) >> 2];\n  for (var j = 0; j < len; j++) {\n   SYSCALLS.printChar(fd, HEAPU8[ptr + j]);\n  }\n  num += len;\n }\n HEAP32[pnum >> 2] = num;\n return 0;\n}\n\nfunction _setTempRet0($i) {\n setTempRet0($i | 0);\n}\n\ninit_emval();\n\nPureVirtualError = Module[\"PureVirtualError\"] = extendError(Error, \"PureVirtualError\");\n\nembind_init_charCodes();\n\ninit_embind();\n\nBindingError = Module[\"BindingError\"] = extendError(Error, \"BindingError\");\n\nInternalError = Module[\"InternalError\"] = extendError(Error, \"InternalError\");\n\ninit_ClassHandle();\n\ninit_RegisteredPointer();\n\nUnboundTypeError = Module[\"UnboundTypeError\"] = extendError(Error, \"UnboundTypeError\");\n\nvar asmLibraryArg = {\n \"n\": __embind_create_inheriting_constructor,\n \"I\": __embind_finalize_value_object,\n \"A\": __embind_register_bool,\n \"e\": __embind_register_class,\n \"i\": __embind_register_class_class_function,\n \"g\": __embind_register_class_class_property,\n \"C\": __embind_register_class_constructor,\n \"a\": __embind_register_class_function,\n \"b\": __embind_register_class_property,\n \"z\": __embind_register_emval,\n \"k\": __embind_register_enum,\n \"j\": __embind_register_enum_value,\n \"p\": __embind_register_float,\n \"L\": __embind_register_function,\n \"h\": __embind_register_integer,\n \"f\": __embind_register_memory_view,\n \"q\": __embind_register_std_string,\n \"m\": __embind_register_std_wstring,\n \"K\": __embind_register_value_object,\n \"J\": __embind_register_value_object_field,\n \"B\": __embind_register_void,\n \"l\": __emval_as,\n \"H\": __emval_call_method,\n \"d\": __emval_call_void_method,\n \"E\": __emval_decref,\n \"c\": __emval_get_method_caller,\n \"M\": __emval_get_module_property,\n \"t\": __emval_get_property,\n \"D\": __emval_incref,\n \"F\": __emval_new_cstring,\n \"G\": __emval_run_destructors,\n \"s\": __emval_take_value,\n \"r\": _abort,\n \"w\": _emscripten_memcpy_big,\n \"x\": _emscripten_resize_heap,\n \"y\": _fd_close,\n \"u\": _fd_seek,\n \"o\": _fd_write,\n \"memory\": wasmMemory,\n \"v\": _setTempRet0,\n \"table\": wasmTable\n};\n\nvar asm = createWasm();\n\nvar ___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = function() {\n return (___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = Module[\"asm\"][\"N\"]).apply(null, arguments);\n};\n\nvar _malloc = Module[\"_malloc\"] = function() {\n return (_malloc = Module[\"_malloc\"] = Module[\"asm\"][\"O\"]).apply(null, arguments);\n};\n\nvar ___getTypeName = Module[\"___getTypeName\"] = function() {\n return (___getTypeName = Module[\"___getTypeName\"] = Module[\"asm\"][\"P\"]).apply(null, arguments);\n};\n\nvar ___embind_register_native_and_builtin_types = Module[\"___embind_register_native_and_builtin_types\"] = function() {\n return (___embind_register_native_and_builtin_types = Module[\"___embind_register_native_and_builtin_types\"] = Module[\"asm\"][\"Q\"]).apply(null, arguments);\n};\n\nvar _free = Module[\"_free\"] = function() {\n return (_free = Module[\"_free\"] = Module[\"asm\"][\"R\"]).apply(null, arguments);\n};\n\nvar dynCall_ii = Module[\"dynCall_ii\"] = function() {\n return (dynCall_ii = Module[\"dynCall_ii\"] = Module[\"asm\"][\"S\"]).apply(null, arguments);\n};\n\nvar dynCall_vi = Module[\"dynCall_vi\"] = function() {\n return (dynCall_vi = Module[\"dynCall_vi\"] = Module[\"asm\"][\"T\"]).apply(null, arguments);\n};\n\nvar dynCall_iii = Module[\"dynCall_iii\"] = function() {\n return (dynCall_iii = Module[\"dynCall_iii\"] = Module[\"asm\"][\"U\"]).apply(null, arguments);\n};\n\nvar dynCall_iiii = Module[\"dynCall_iiii\"] = function() {\n return (dynCall_iiii = Module[\"dynCall_iiii\"] = Module[\"asm\"][\"V\"]).apply(null, arguments);\n};\n\nvar dynCall_v = Module[\"dynCall_v\"] = function() {\n return (dynCall_v = Module[\"dynCall_v\"] = Module[\"asm\"][\"W\"]).apply(null, arguments);\n};\n\nvar dynCall_viiif = Module[\"dynCall_viiif\"] = function() {\n return (dynCall_viiif = Module[\"dynCall_viiif\"] = Module[\"asm\"][\"X\"]).apply(null, arguments);\n};\n\nvar dynCall_viiifif = Module[\"dynCall_viiifif\"] = function() {\n return (dynCall_viiifif = Module[\"dynCall_viiifif\"] = Module[\"asm\"][\"Y\"]).apply(null, arguments);\n};\n\nvar dynCall_vii = Module[\"dynCall_vii\"] = function() {\n return (dynCall_vii = Module[\"dynCall_vii\"] = Module[\"asm\"][\"Z\"]).apply(null, arguments);\n};\n\nvar dynCall_fi = Module[\"dynCall_fi\"] = function() {\n return (dynCall_fi = Module[\"dynCall_fi\"] = Module[\"asm\"][\"_\"]).apply(null, arguments);\n};\n\nvar dynCall_viii = Module[\"dynCall_viii\"] = function() {\n return (dynCall_viii = Module[\"dynCall_viii\"] = Module[\"asm\"][\"$\"]).apply(null, arguments);\n};\n\nvar dynCall_viff = Module[\"dynCall_viff\"] = function() {\n return (dynCall_viff = Module[\"dynCall_viff\"] = Module[\"asm\"][\"aa\"]).apply(null, arguments);\n};\n\nvar dynCall_viffffff = Module[\"dynCall_viffffff\"] = function() {\n return (dynCall_viffffff = Module[\"dynCall_viffffff\"] = Module[\"asm\"][\"ba\"]).apply(null, arguments);\n};\n\nvar dynCall_viiiii = Module[\"dynCall_viiiii\"] = function() {\n return (dynCall_viiiii = Module[\"dynCall_viiiii\"] = Module[\"asm\"][\"ca\"]).apply(null, arguments);\n};\n\nvar dynCall_fii = Module[\"dynCall_fii\"] = function() {\n return (dynCall_fii = Module[\"dynCall_fii\"] = Module[\"asm\"][\"da\"]).apply(null, arguments);\n};\n\nvar dynCall_iid = Module[\"dynCall_iid\"] = function() {\n return (dynCall_iid = Module[\"dynCall_iid\"] = Module[\"asm\"][\"ea\"]).apply(null, arguments);\n};\n\nvar dynCall_vif = Module[\"dynCall_vif\"] = function() {\n return (dynCall_vif = Module[\"dynCall_vif\"] = Module[\"asm\"][\"fa\"]).apply(null, arguments);\n};\n\nvar dynCall_viif = Module[\"dynCall_viif\"] = function() {\n return (dynCall_viif = Module[\"dynCall_viif\"] = Module[\"asm\"][\"ga\"]).apply(null, arguments);\n};\n\nvar dynCall_viiff = Module[\"dynCall_viiff\"] = function() {\n return (dynCall_viiff = Module[\"dynCall_viiff\"] = Module[\"asm\"][\"ha\"]).apply(null, arguments);\n};\n\nvar dynCall_iif = Module[\"dynCall_iif\"] = function() {\n return (dynCall_iif = Module[\"dynCall_iif\"] = Module[\"asm\"][\"ia\"]).apply(null, arguments);\n};\n\nvar dynCall_viiii = Module[\"dynCall_viiii\"] = function() {\n return (dynCall_viiii = Module[\"dynCall_viiii\"] = Module[\"asm\"][\"ja\"]).apply(null, arguments);\n};\n\nvar dynCall_viiiiii = Module[\"dynCall_viiiiii\"] = function() {\n return (dynCall_viiiiii = Module[\"dynCall_viiiiii\"] = Module[\"asm\"][\"ka\"]).apply(null, arguments);\n};\n\nvar dynCall_viiffffff = Module[\"dynCall_viiffffff\"] = function() {\n return (dynCall_viiffffff = Module[\"dynCall_viiffffff\"] = Module[\"asm\"][\"la\"]).apply(null, arguments);\n};\n\nvar dynCall_viiffff = Module[\"dynCall_viiffff\"] = function() {\n return (dynCall_viiffff = Module[\"dynCall_viiffff\"] = Module[\"asm\"][\"ma\"]).apply(null, arguments);\n};\n\nvar dynCall_iiid = Module[\"dynCall_iiid\"] = function() {\n return (dynCall_iiid = Module[\"dynCall_iiid\"] = Module[\"asm\"][\"na\"]).apply(null, arguments);\n};\n\nvar dynCall_viiiff = Module[\"dynCall_viiiff\"] = function() {\n return (dynCall_viiiff = Module[\"dynCall_viiiff\"] = Module[\"asm\"][\"oa\"]).apply(null, arguments);\n};\n\nvar dynCall_iiif = Module[\"dynCall_iiif\"] = function() {\n return (dynCall_iiif = Module[\"dynCall_iiif\"] = Module[\"asm\"][\"pa\"]).apply(null, arguments);\n};\n\nvar dynCall_i = Module[\"dynCall_i\"] = function() {\n return (dynCall_i = Module[\"dynCall_i\"] = Module[\"asm\"][\"qa\"]).apply(null, arguments);\n};\n\nvar dynCall_viffff = Module[\"dynCall_viffff\"] = function() {\n return (dynCall_viffff = Module[\"dynCall_viffff\"] = Module[\"asm\"][\"ra\"]).apply(null, arguments);\n};\n\nvar dynCall_jiji = Module[\"dynCall_jiji\"] = function() {\n return (dynCall_jiji = Module[\"dynCall_jiji\"] = Module[\"asm\"][\"sa\"]).apply(null, arguments);\n};\n\nvar dynCall_iidiiii = Module[\"dynCall_iidiiii\"] = function() {\n return (dynCall_iidiiii = Module[\"dynCall_iidiiii\"] = Module[\"asm\"][\"ta\"]).apply(null, arguments);\n};\n\nvar calledRun;\n\nfunction ExitStatus(status) {\n this.name = \"ExitStatus\";\n this.message = \"Program terminated with exit(\" + status + \")\";\n this.status = status;\n}\n\ndependenciesFulfilled = function runCaller() {\n if (!calledRun) run();\n if (!calledRun) dependenciesFulfilled = runCaller;\n};\n\nfunction run(args) {\n args = args || arguments_;\n if (runDependencies > 0) {\n  return;\n }\n preRun();\n if (runDependencies > 0) return;\n function doRun() {\n  if (calledRun) return;\n  calledRun = true;\n  Module[\"calledRun\"] = true;\n  if (ABORT) return;\n  initRuntime();\n  preMain();\n  readyPromiseResolve(Module);\n  if (Module[\"onRuntimeInitialized\"]) Module[\"onRuntimeInitialized\"]();\n  postRun();\n }\n if (Module[\"setStatus\"]) {\n  Module[\"setStatus\"](\"Running...\");\n  setTimeout(function() {\n   setTimeout(function() {\n    Module[\"setStatus\"](\"\");\n   }, 1);\n   doRun();\n  }, 1);\n } else {\n  doRun();\n }\n}\n\nModule[\"run\"] = run;\n\nif (Module[\"preInit\"]) {\n if (typeof Module[\"preInit\"] == \"function\") Module[\"preInit\"] = [ Module[\"preInit\"] ];\n while (Module[\"preInit\"].length > 0) {\n  Module[\"preInit\"].pop()();\n }\n}\n\nnoExitRuntime = true;\n\nrun();\n\nfunction makeMatrix(m2d) {\n    const m = new DOMMatrix();\n    m.a = m2d.xx;\n    m.b = m2d.xy;\n    m.c = m2d.yx;\n    m.d = m2d.yy;\n    m.e = m2d.tx;\n    m.f = m2d.ty;\n    return m;\n}\n\nModule.onRuntimeInitialized = function () {\n    const {\n        RenderPaintStyle,\n        FillRule,\n        RenderPath,\n        RenderPaint,\n        Renderer,\n        StrokeCap,\n        StrokeJoin,\n        BlendMode\n    } = Module;\n\n    const {\n        fill,\n        stroke\n    } = RenderPaintStyle;\n\n    const {\n        evenOdd,\n        nonZero\n    } = FillRule;\n\n    var CanvasRenderPath = RenderPath.extend(\"CanvasRenderPath\", {\n        __construct: function () {\n            this.__parent.__construct.call(this);\n            this._path2D = new Path2D();\n        },\n        reset: function () {\n            this._path2D = new Path2D();\n        },\n        addPath: function (path, m2d) {\n            this._path2D.addPath(path._path2D, makeMatrix(m2d));\n        },\n        fillRule: function(fillRule) {\n            this._fillRule = fillRule;\n        },\n        moveTo: function (x, y) {\n            this._path2D.moveTo(x, y);\n        },\n        lineTo: function (x, y) {\n            this._path2D.lineTo(x, y);\n        },\n        cubicTo: function (ox, oy, ix, iy, x, y) {\n            this._path2D.bezierCurveTo(ox, oy, ix, iy, x, y);\n        },\n        close: function () {\n            this._path2D.closePath();\n        }\n    });\n\n    function _colorStyle(value) {\n        return 'rgba(' + ((0x00ff0000 & value) >>>\n                16) + ',' + ((0x0000ff00 &\n                value) >>> 8) + ',' + ((0x000000ff & value) >>> 0) + ',' +\n            (((0xff000000 & value) >>> 24) / 0xFF) + ')'\n    }\n    var CanvasRenderPaint = RenderPaint.extend(\"CanvasRenderPaint\", {\n        color: function (value) {\n            this._value = _colorStyle(value);\n        },\n        thickness: function (value) {\n            this._thickness = value;\n        },\n        join: function (value) {\n            switch (value) {\n                case StrokeJoin.miter:\n                    this._join = 'miter';\n                    break;\n                case StrokeJoin.round:\n                    this._join = 'round';\n                    break;\n                case StrokeJoin.bevel:\n                    this._join = 'bevel';\n                    break;\n            }\n        },\n        cap: function (value) {\n            switch (value) {\n                case StrokeCap.butt:\n                    this._cap = 'butt';\n                    break;\n                case StrokeCap.round:\n                    this._cap = 'round';\n                    break;\n                case StrokeCap.square:\n                    this._cap = 'square';\n                    break;\n            }\n        },\n        style: function (value) {\n            this._style = value;\n        },\n        blendMode: function (value) {\n            switch (value) {\n                case BlendMode.srcOver:\n                    this._blend = 'source-over';\n                    break;\n                case BlendMode.screen:\n                    this._blend = 'screen';\n                    break;\n                case BlendMode.overlay:\n                    this._blend = 'overlay';\n                    break;\n                case BlendMode.darken:\n                    this._blend = 'darken';\n                    break;\n                case BlendMode.lighten:\n                    this._blend = 'lighten';\n                    break;\n                case BlendMode.colorDodge:\n                    this._blend = 'color-dodge';\n                    break;\n                case BlendMode.colorBurn:\n                    this._blend = 'color-burn';\n                    break;\n                case BlendMode.hardLight:\n                    this._blend = 'hard-light';\n                    break;\n                case BlendMode.softLight:\n                    this._blend = 'soft-light';\n                    break;\n                case BlendMode.difference:\n                    this._blend = 'difference';\n                    break;\n                case BlendMode.exclusion:\n                    this._blend = 'exclusion';\n                    break;\n                case BlendMode.multiply:\n                    this._blend = 'multiply';\n                    break;\n                case BlendMode.hue:\n                    this._blend = 'hue';\n                    break;\n                case BlendMode.saturation:\n                    this._blend = 'saturation';\n                    break;\n                case BlendMode.color:\n                    this._blend = 'color';\n                    break;\n                case BlendMode.luminosity:\n                    this._blend = 'luminosity';\n                    break;\n            }\n        },\n        linearGradient: function (sx, sy, ex, ey) {\n            this._gradient = {\n                sx,\n                sy,\n                ex,\n                ey,\n                stops: []\n            };\n        },\n        radialGradient: function (sx, sy, ex, ey) {\n            this._gradient = {\n                sx,\n                sy,\n                ex,\n                ey,\n                stops: [],\n                isRadial: true\n            };\n        },\n        addStop: function (color, stop) {\n            this._gradient.stops.push({\n                color,\n                stop\n            });\n        },\n\n        completeGradient: function () {\n\n        },\n\n        draw: function (ctx, path) {\n            let {\n                _style,\n                _value,\n                _gradient,\n                _blend\n            } = this;\n\n            ctx.globalCompositeOperation = _blend;\n\n            if (_gradient != null) {\n                const {\n                    sx,\n                    sy,\n                    ex,\n                    ey,\n                    stops,\n                    isRadial\n                } = _gradient;\n\n                if (isRadial) {\n                    var dx = ex - sx;\n                    var dy = ey - sy;\n                    var radius = Math.sqrt(dx * dx + dy * dy);\n                    _value = ctx.createRadialGradient(sx, sy, 0, sx, sy, radius);\n                } else {\n                    _value = ctx.createLinearGradient(sx, sy, ex, ey);\n                }\n\n                for ({\n                        stop,\n                        color\n                    } of stops) {\n                    _value.addColorStop(stop, _colorStyle(color));\n                }\n                this._value = _value;\n                this._gradient = null;\n            }\n            switch (_style) {\n                case stroke:\n                    ctx.strokeStyle = _value;\n                    ctx.lineWidth = this._thickness;\n                    ctx.lineCap = this._cap;\n                    ctx.lineJoin = this._join;\n                    ctx.stroke(path._path2D);\n                    break;\n                case fill:\n                    ctx.fillStyle = _value;\n                    ctx.fill(path._path2D, path._fillRule === evenOdd ? 'evenodd' : 'nonzero');\n                    break;\n            }\n        }\n    });\n\n    Module.CanvasRenderer = Renderer.extend(\"Renderer\", {\n        __construct: function (ctx) {\n            this.__parent.__construct.call(this);\n            this._ctx = ctx;\n        },\n        save: function () {\n            this._ctx.save();\n        },\n        restore: function () {\n            this._ctx.restore();\n        },\n        transform: function (matrix) {\n            this._ctx.transform(matrix.xx, matrix.xy, matrix.yx, matrix.yy, matrix.tx,\n                matrix.ty);\n        },\n        drawPath: function (path, paint) {\n            paint.draw(this._ctx, path);\n        },\n        clipPath: function (path) {\n            this._ctx.clip(path._path2D, path._fillRule === evenOdd ? 'evenodd' : 'nonzero');\n        }\n    });\n\n    Module.renderFactory = {\n        makeRenderPaint: function () {\n            return new CanvasRenderPaint();\n        },\n        makeRenderPath: function () {\n            return new CanvasRenderPath();\n        }\n    };\n};\n\n\n  return Rive.ready\n}\n);\n})();\nif (typeof exports === 'object' && typeof module === 'object')\n      module.exports = Rive;\n    else if (typeof define === 'function' && define['amd'])\n      define([], function() { return Rive; });\n    else if (typeof exports === 'object')\n      exports[\"Rive\"] = Rive;\n    \n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import Runtime from '../../wasm/publish/rive.js';\n\n// Tracks playback states; numbers map to the runtime's numerica values\n// i.e. play: 0, pause: 1, stop: 2\nenum PlaybackState {\n  Play = 0,\n  Pause,\n  Stop\n}\n\n// #region layout\n\n// Fit options for the canvas\nexport enum Fit {\n  Cover     = 'cover',\n  Contain   = 'contain',\n  Fill      = 'fill',\n  FitWidth  = 'fitWidth',\n  FitHeight = 'fitHeight',\n  None      = 'none',\n  ScaleDown = 'scaleDown'\n}\n\n// Alignment options for the canvas\nexport enum Alignment {\n  Center       = 'center',\n  TopLeft      = 'topLeft',\n  TopCenter    = 'topCenter',\n  TopRight     = 'topRight',\n  CenterLeft   = 'centerLeft',\n  CenterRight  = 'centerRight',\n  BottomLeft   = 'bottomLeft',\n  BottomCenter = 'bottomCenter',\n  BottomRight  = 'bottomRight'\n}\n\n// Interface for the Layout static method contructor\nexport interface LayoutParameters {\n  fit?: Fit,\n  alignment?: Alignment,\n  minX?: number,\n  minY?: number,\n  maxX?: number,\n  maxY?: number\n}\n\n// Alignment options for Rive animations in a HTML canvas\nexport class Layout {\n\n  // Runtime fit and alignment are accessed every frame, so we cache their\n  // values to save cycles\n  private cachedRuntimeFit: any;\n  private cachedRuntimeAlignment: any;\n\n  constructor(\n    public readonly fit: Fit = Fit.Contain,\n    public readonly alignment: Alignment = Alignment.Center,\n    public readonly minX: number = 0,\n    public readonly minY: number = 0,\n    public readonly maxX: number = 0,\n    public readonly maxY: number = 0\n  ) {}\n\n  // Alternative constructor to build a Layout from an interface/object\n  static new({fit, alignment, minX, minY, maxX, maxY}: LayoutParameters) : Layout {\n    return new Layout(fit, alignment, minX, minY, maxX, maxY);\n  }\n\n  // Returns fit for the Wasm runtime format\n  public runtimeFit(rive: any): any {\n    if (this.cachedRuntimeFit) return this.cachedRuntimeFit;\n    \n    let fit;\n    if (this.fit === Fit.Cover) fit = rive.Fit.cover;\n    else if (this.fit === Fit.Contain) fit = rive.Fit.contain;\n    else if (this.fit === Fit.Fill) fit = rive.Fit.fill;\n    else if (this.fit === Fit.FitWidth) fit = rive.Fit.fitWidth;\n    else if (this.fit === Fit.FitHeight) fit = rive.Fit.fitHeight;\n    else if (this.fit === Fit.ScaleDown) fit = rive.Fit.scaleDown;\n    else fit = rive.Fit.none;\n\n    this.cachedRuntimeFit = fit;\n    return fit;\n  }\n\n  // Returns alignment for the Wasm runtime format\n  public runtimeAlignment(rive: any): any {\n    if (this.cachedRuntimeAlignment) return this.cachedRuntimeAlignment;\n\n    let alignment;\n    if (this.alignment === Alignment.TopLeft) alignment = rive.Alignment.topLeft;\n    else if (this.alignment === Alignment.TopCenter) alignment = rive.Alignment.topCenter;\n    else if (this.alignment === Alignment.TopRight) alignment = rive.Alignment.topRight;\n    else if (this.alignment === Alignment.CenterLeft) alignment = rive.Alignment.centerLeft;\n    else if (this.alignment === Alignment.CenterRight) alignment = rive.Alignment.centerRight;\n    else if (this.alignment === Alignment.BottomLeft) alignment = rive.Alignment.bottomLeft;\n    else if (this.alignment === Alignment.BottomCenter) alignment = rive.Alignment.bottomCenter;\n    else if (this.alignment === Alignment.BottomRight) alignment = rive.Alignment.bottomRight;\n    else alignment = rive.Alignment.center;\n\n    this.cachedRuntimeAlignment = alignment;\n    return alignment;\n  }\n}\n\n// #endregion\n\n// #region runtime\n\n// Callback type when looking for a runtime instance\nexport type RuntimeCallback = (rive: typeof Runtime) => void;\n\n// Runtime singleton; use getInstance to provide a callback that returns the\n// Rive runtime\nexport class RuntimeLoader {\n  \n  // Singleton helpers\n  private static runtime: typeof Runtime;\n  // Flag to indicate that loading has started/completed\n  private static isLoading: boolean = false;\n  // List of callbacks for the runtime that come in while loading\n  private static callBackQueue: RuntimeCallback[] = [];\n  // Instance of the Rive runtime\n  private static rive: typeof Runtime;\n  // The url for the Wasm file\n  private static wasmWebPath: string = 'https://unpkg.com/rive-js@0.7.4/dist/';\n  // Local path to the Wasm file; for testing purposes\n  private static wasmFilePath: string = 'dist/';\n  // Are we in test mode?\n  private static testMode: boolean = false;\n\n  // Class is never instantiated\n  private constructor() {}\n\n  // Loads the runtime\n  private static loadRuntime() : void {\n    Runtime({\n      // Loads Wasm bundle\n      locateFile: (file: string) =>\n        // if in test mode, attempts to load file locally \n        (RuntimeLoader.testMode ?\n          RuntimeLoader.wasmFilePath :\n          RuntimeLoader.wasmWebPath) + file\n    }).then((rive: typeof Runtime) => {\n      RuntimeLoader.runtime = rive;\n      // Fire all the callbacks\n      while (RuntimeLoader.callBackQueue.length > 0) {\n        RuntimeLoader.callBackQueue.shift()?.(RuntimeLoader.runtime);\n      }\n    });\n  }\n\n  // Provides a runtime instance via a callback\n  public static getInstance(callback: RuntimeCallback): void {\n    // If it's not loading, start loading runtime\n    if (!RuntimeLoader.isLoading) {\n      RuntimeLoader.isLoading = true;\n      RuntimeLoader.loadRuntime();\n    }\n    if (!RuntimeLoader.runtime) {\n      RuntimeLoader.callBackQueue.push(callback);\n    } else {\n      callback(RuntimeLoader.runtime);\n    }\n  }\n\n  // Provides a runtime instance via a promise\n  public static awaitInstance(): Promise<typeof Runtime> {\n    return new Promise<typeof Runtime>((resolve, reject) => \n      RuntimeLoader.getInstance((rive: typeof Runtime): void => resolve(rive))\n    );\n  }\n\n  // Places the loader in test mode\n  public static setTestMode(mode: boolean): void {\n    RuntimeLoader.testMode = mode;\n  }\n}\n\n// #endregion\n\n// #region animations\n\n// Wraps animations and instances from the runtime and keeps track of playback\n// state\nclass Animation {  \n  public loopCount: number = 0;\n  public paused: boolean = false;\n\n/**\n * Constructs a new animation\n * @constructor\n * @param {any} animation: runtime animation object\n * @param {any} instance: runtime animation instance object\n */\n  constructor(private animation: any, public readonly instance: any) {}\n\n  // Returns the animation's name\n  public get name(): string {\n    return this.animation.name;\n  }\n\n  // Returns the animation's loop type\n  public get loopValue(): number {\n    return this.animation.loopValue;\n  } \n}\n\n// #endregion\n\n// #region events\n\n/**\n * Supported event types triggered in Rive\n */\nexport enum EventType {\n  Load      = 'load',\n  LoadError = 'loaderror',\n  Play      = 'play',\n  Pause     = 'pause',\n  Stop      = 'stop',\n  Loop      = 'loop',\n}\n\n// Event fired by Rive\nexport interface Event {\n  type: EventType,\n  data?: string | string[] | LoopEvent,\n}\n\n/**\n * Looping types: one-shot, loop, and ping-pong\n */\nexport enum LoopType {\n  OneShot  = 'oneshot',  // has value 0 in runtime\n  Loop     = 'loop',        // has value 1 in runtime\n  PingPong = 'pingpong' // has value 2 in runtime\n}\n\n/**\n * Loop events are returned through onloop callbacks\n */\nexport interface LoopEvent {\n  animation: string;\n  type: LoopType;\n}\n\n/**\n * Loop events are returned through onloop callbacks\n */\nexport type EventCallback = (event: Event) => void;\n\n/**\n * Event listeners registered with the event manager\n */\nexport interface EventListener {\n  type: EventType,\n  callback: EventCallback, \n}\n\n// Manages Rive events and listeners\nclass EventManager {\n\n  constructor(private listeners: EventListener[] = []) {}\n\n  // Gets listeners of specified type\n  private getListeners(type: EventType): EventListener[] {\n    return this.listeners.filter(e => e.type === type);\n  }\n\n  // Adds a listener\n  public add(listener: EventListener): void {\n    if (!this.listeners.includes(listener)) {\n      this.listeners.push(listener);\n    }\n  }\n\n  // Removes listener\n  public remove(listener: EventListener): void {\n    const index = this.listeners.indexOf(listener, 0);\n    if (index > -1) {\n      this.listeners.splice(index, 1);\n    }\n  }\n\n  // Fires an event\n  public fire(event: Event, ignoreDuplicate = false): void {\n    const eventListeners = this.getListeners(event.type);\n    eventListeners.forEach(\n      listener => listener.callback(event)\n    );\n  }\n}\n\n// #endregion\n\n// #region Manages a queue of tasks\n\n// A task in the queue; will fire the action when the queue is processed; will\n// also optionally fire an event.\nexport interface Task {\n  action: ActionCallback,\n  event?: Event,\n}\n\n// Callback type for task actions\nexport type ActionCallback = () => void;\n\n// Manages a queue of tasks\nclass TaskQueueManager {\n  private queue: Task[] = [];\n\n  constructor(private eventManager: EventManager) {}\n\n  // Adds a task top the queue\n  public add(task: Task): void {\n    this.queue.push(task);\n  }\n\n  // Processes all tasks in the queue\n  public process(): void {\n    while (this.queue.length > 0) {\n      const task = this.queue.shift();\n      task?.action();\n      if (task?.event) {\n        this.eventManager.fire(task.event);\n      }\n    }\n  }\n}\n\n// #endregion\n\n// #region Rive\n\n// Interface for the Rive static method contructor\nexport interface RiveParameters {\n  canvas: HTMLCanvasElement | OffscreenCanvas, // canvas is required\n  src?: string, // one of src or buffer is required\n  buffer?: ArrayBuffer, // one of src or buffer is required\n  artboard?: string,\n  animations?: string[],\n  layout?: Layout,\n  autoplay?: boolean,\n  onload?: EventCallback,\n  onloaderror?: EventCallback,\n  onplay?: EventCallback,\n  onpause?: EventCallback,\n  onstop?: EventCallback,\n  onloop?: EventCallback,\n}\n\n// Interface to Rive.load function\nexport interface RiveLoadParameters {\n  src?: string,\n  buffer?: ArrayBuffer,\n  autoplay?: boolean,\n  artboard?: string,\n  animations?: string | string[],\n}\n\n// Interface for typing a runtime Artboard\ninterface RuntimeArtboard {\n  animationCount: () => number,\n  bounds: any,\n  advance: (elapsedTime: number) => void\n  draw: (renderer: any) => void,\n  animationByName: (name: string) => any,\n  animationByIndex: (index: number) => any,\n}\n\nexport class Rive {\n\n  // Used to track artboard and starting animation names passed into the\n  // constructor\n  private artboardName: string;\n  private startingAnimationNames: string[];\n  \n  // Holds instantiated animations\n  private animations: Animation[] = [];\n  \n  // The canvas 2D context\n  private ctx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D | null;\n  \n  // The runtime renderer\n  private renderer: any;\n\n  // Tracks the playback state\n  private playState: PlaybackState = PlaybackState.Stop;\n\n  // Tracks if a Rive file is loaded\n  private loaded: boolean = false;\n\n  // Wasm runtime\n  private runtime: any;\n\n  // Runtime artboard\n  private artboard: RuntimeArtboard | null = null;\n\n  // Runtime file\n  private file: any;\n\n  // Holds event listeners\n  private eventManager: EventManager;\n\n  // Manages the loading task queue\n  private taskQueue: TaskQueueManager;\n\n  // Error message for missing source or buffer\n  private static readonly missingErrorMessage: string =\n    'Rive source file or data buffer required';\n\n  constructor(\n    private canvas: HTMLCanvasElement | OffscreenCanvas, // canvas in which to render the artboard\n    private src?: string, // uri for a (.riv) Rive file\n    private buffer?: ArrayBuffer, // ArrayBuffer containing Rive data\n    artboard?: string, // name of the artboard to use\n    animations?: string | string[], // list of names of animations to queue for playback\n    private _layout: Layout = new Layout(), // rendering layout inside the canvas\n    private autoplay: boolean = false, // should playback begin immediately?\n    onload?: EventCallback, // callback triggered when Rive file is loaded\n    onloaderror?: EventCallback, // callback triggered if loading fails\n    onplay?: EventCallback, // callback triggered when a play event occurs\n    onpause?: EventCallback, // callback triggered when a pause event occurs\n    onstop?: EventCallback, // callback triggered when a stop event occurs\n    onloop?: EventCallback, // callback triggered when a loop event occurs\n  ) {\n\n    // Fetch the 2d context from the canvas\n    this.ctx = this.canvas.getContext('2d');\n    \n    // New event management system\n    this.eventManager = new EventManager();\n    if (onload) this.on(EventType.Load, onload);\n    if (onloaderror) this.on(EventType.LoadError, onloaderror);\n    if (onplay) this.on(EventType.Play, onplay);\n    if (onpause) this.on(EventType.Pause, onpause);\n    if (onstop) this.on(EventType.Stop, onstop);\n    if (onloop) this.on(EventType.Loop, onloop);\n\n    // Hook up the task queue\n    this.taskQueue = new TaskQueueManager(this.eventManager);\n\n    this.init({\n      src: this.src,\n      buffer: this.buffer,\n      autoplay: this.autoplay,\n      animations: animations,\n      artboard: artboard\n    });\n  }\n\n  // Alternative constructor to build a Rive instance from an interface/object\n  public static new({\n    src,\n    buffer,\n    artboard,\n    animations,\n    canvas,\n    layout,\n    autoplay,\n    onload,\n    onloaderror,\n    onplay,\n    onpause,\n    onstop,\n    onloop }: RiveParameters) : Rive {\n    return new Rive(\n      canvas, src, buffer, artboard, animations, layout, autoplay,\n      onload, onloaderror, onplay, onpause, onstop, onloop,\n    );\n  }\n\n  // Initializes the Rive object either from constructor or load()\n  private init({src, buffer, animations, artboard, autoplay = false}: RiveLoadParameters): void {\n    this.src = src;\n    this.buffer = buffer;\n    this.autoplay = autoplay;\n  \n    // If no source file url specified, it's a bust\n    if (!this.src && !this.buffer) {\n      throw new Error(Rive.missingErrorMessage);\n    }\n\n    // Name of the artboard. Rive operates on only one artboard. If\n    // you want to have multiple artboards, use multiple Rive instances.\n    this.artboardName = artboard;\n\n    // List of animations that should be played.\n    this.startingAnimationNames = mapToStringArray(animations);\n\n    // Queue up play action and event if necessary\n    if (this.autoplay) {\n      this.taskQueue.add({ action: () => this.play() });\n    }\n\n    // Reset the animations list if loading new file\n    this.animations = [];\n\n    // Ensure loaded is marked as false if loading new file\n    this.loaded = false;\n    \n    // Queue up play action and event if necessary\n    if (this.autoplay) {\n      this.taskQueue.add({ action: () => this.play() });\n    }\n  \n    // Ensure the runtime is loaded\n    RuntimeLoader.awaitInstance().then((runtime) => {\n      this.runtime = runtime;\n      // Load Rive data from a source uri or a data buffer\n      this.initData().catch(e => {\n        console.error(e);\n      });\n    }).catch(e => {\n      console.error(e);\n    });\n  }\n\n  // Initializes runtime with Rive data and preps for playing\n  private async initData() : Promise<void> {\n    // Load the buffer from the src if provided\n    if (this.src) {\n      this.buffer = await loadRiveFile(this.src);\n    }\n    // Load the Rive file\n    this.file = await this.runtime.load(new Uint8Array(this.buffer));\n    if (this.file) {\n      this.loaded = true;\n      // Initialize and draw frame\n      this.initArtboard();\n      this.drawFrame();\n      // Everything's set up, emit a load event\n      this.eventManager.fire({\n        type: EventType.Load,\n        data: this.src ?? 'buffer'\n      });\n      // Clear the task queue\n      this.taskQueue.process();\n      return Promise.resolve();\n    } else {\n      const msg = 'Problem loading file; may be corrupt!';\n      this.eventManager.fire({type: EventType.LoadError, data: msg});\n      return Promise.reject(msg);\n    }\n  }\n\n  // Initialize for playback\n  private initArtboard(): void {\n    this.artboard = this.artboardName ?\n      this.file.artboard(this.artboardName) :\n      this.file.defaultArtboard();\n\n    // Check that the artboard has at least 1 animation\n    if (this.artboard.animationCount() < 1) {\n      const msg = 'Artboard has no animations';\n      this.eventManager.fire({type: EventType.LoadError, data: msg});\n      throw msg;\n    }\n\n    // Get the canvas where you want to render the animation and create a renderer\n    this.renderer = new this.runtime.CanvasRenderer(this.ctx);\n\n    // Initialize the animations\n    if (this.startingAnimationNames.length > 0) {\n      this.playAnimations(this.startingAnimationNames);\n    }\n  }\n\n  // Draws the current artboard frame\n  public drawFrame() {\n    // Choose how you want the animation to align in the canvas\n    this.ctx.save();\n    this.renderer.align(\n      this._layout.runtimeFit(this.runtime),\n      this._layout.runtimeAlignment(this.runtime),\n      {\n        minX: this._layout.minX,\n        minY: this._layout.minY,\n        // if the max x & y are 0, make them the canvas width and height\n        maxX: this._layout.maxX ? this._layout.maxX : this.canvas.width,\n        maxY: this._layout.maxY ? this._layout.maxY : this.canvas.height\n      },\n      this.artboard.bounds\n    );\n\n    // Advance to the first frame and draw the artboard\n    this.artboard.advance(0);\n    this.artboard.draw(this.renderer);\n    this.ctx.restore();\n  }\n\n  // Adds animations contained in the artboard for playback\n  private playAnimations(animationNames?: string | string[]): string[] {\n    animationNames = mapToStringArray(animationNames);\n    const instancedAnimationNames = this.animations.map(a => a.name);\n    for (const i in animationNames) {\n      const index = instancedAnimationNames.indexOf(animationNames[i]);\n      if (index >= 0) {\n        // Animation is already instanced, unpause it\n        this.animations[index].paused = false;\n      } else {\n        // Create a new animation instance and add it to the list\n        const anim = this.artboard.animationByName(animationNames[i]);\n        const inst = new this.runtime.LinearAnimationInstance(anim);\n        this.animations.push(new Animation(anim, inst));\n      }\n    }\n  \n    return this.animations.filter(a => !a.paused).map(a => a.name);\n  }\n\n  // Removes animations from playback\n  private removeAnimations(animationNames: string[]): string[] {\n    // Determine which animations need to be removed\n    const animationsToRemove = this.animations.filter(\n      a => animationNames.indexOf(a.name) >= 0\n    );\n\n    // Remove the animations\n    animationsToRemove.forEach(a =>\n      this.animations.splice(this.animations.indexOf(a), 1)\n    );\n\n    // Return the list of animations removed\n    return animationsToRemove.map(a => a.name);\n  }\n\n  // Removes all animations from playback\n  private removeAllAnimations(): string[] {\n    const names = this.animations.map(a => a.name);\n    this.animations.splice(0, this.animations.length);\n    return names;\n  }\n\n  // Pauses animations\n  private pauseAnimations(animationNames: string[]): string[] {\n    const pausedAnimationNames: string[] = [];\n\n    this.animations.forEach((a, i) => {\n      if (animationNames.indexOf(a.name) >= 0) {\n        a.paused = true;\n        pausedAnimationNames.push(a.name);\n      }\n    });\n    return pausedAnimationNames;\n  }\n\n  // Returns true if at least one animation is active\n  private get hasPlayingAnimations(): boolean {\n    return this.animations.reduce((acc, curr) => acc || !curr.paused, false);\n  }\n\n  // Ensure there's at least one animation for playback; if there are none\n  // marked for playback, then ad the first animation in the artboard.\n  private atLeastOneAnimationForPlayback(): void {\n    if (this.animations.length === 0 && this.artboard.animationCount() > 0) {\n      // Add the default animation\n      const animation = this.artboard.animationByIndex(0);\n      const instance = new this.runtime.LinearAnimationInstance(animation);\n      this.animations.push(new Animation(animation, instance));\n    }\n  }\n\n  // Tracks the last timestamp at which the animation was rendered. Used only in\n  // draw().\n  private lastRenderTime: number;\n\n  // Tracks the current animation frame request\n  private frameRequestId: number;\n\n  // Draw rendering loop; renders animation frames at the correct time interval.\n  private draw(time: number): void {\n\n    // On the first pass, make sure lastTime has a valid value\n    if (!this.lastRenderTime) {\n      this.lastRenderTime = time;\n    }\n    // Calculate the elapsed time between frames in seconds\n    const elapsedTime = (time - this.lastRenderTime) / 1000;\n    this.lastRenderTime = time;\n  \n    // Advance non-paused animations by the elapsed number of seconds\n    const activeAnimations = this.animations.filter(a => !a.paused);\n    for (const animation of activeAnimations) {\n      animation.instance.advance(elapsedTime);\n      if (animation.instance.didLoop) {\n        animation.loopCount += 1;\n      }\n      // Apply the animation to the artboard. The reason of this is that\n      // multiple animations may be applied to an artboard, which will\n      // then mix those animations together.\n      animation.instance.apply(this.artboard, 1.0);\n    }\n  \n    // Once the animations have been applied to the artboard, advance it\n    // by the elapsed time.\n    this.artboard.advance(elapsedTime);\n  \n    // Clear the current frame of the canvas\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    // Render the frame in the canvas\n    this.ctx.save();\n    this.renderer.align(\n      this._layout.runtimeFit(this.runtime),\n      this._layout.runtimeAlignment(this.runtime),\n      {\n        minX: this._layout.minX,\n        minY: this._layout.minY,\n        maxX: this._layout.maxX ? this._layout.maxX : this.canvas.width,\n        maxY: this._layout.maxY ? this._layout.maxY : this.canvas.height\n      },\n      this.artboard.bounds\n    );\n    this.artboard.draw(this.renderer);\n    this.ctx.restore();\n  \n    for (const animation of this.animations) {\n      // Emit if the animation looped\n      if (animation.loopValue === 0 && animation.loopCount) {\n        animation.loopCount = 0;\n        // This is a one-shot; if it has ended, delete the instance\n        this.stop(animation.name);\n      }\n      else if (animation.loopValue === 1 && animation.loopCount) {\n        this.eventManager.fire({\n          type: EventType.Loop,\n          data: {animation: animation.name, type: LoopType.Loop}\n        });\n        animation.loopCount = 0;\n      } \n      // Wasm indicates a loop at each time the animation\n      // changes direction, so a full loop/lap occurs every\n      // two loop counts\n      else if (animation.loopValue === 2 && animation.loopCount > 1) {\n        this.eventManager.fire({\n          type: EventType.Loop,\n          data: {animation: animation.name, type: LoopType.PingPong}\n        });\n        animation.loopCount = 0;\n      }\n    }\n\n    // Calling requestAnimationFrame will rerun draw() at the correct rate:\n    // https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Basic_animations\n    // TODO: move handling state change to event listeners?\n    if (this.playState === PlaybackState.Play) {\n      this.frameRequestId = requestAnimationFrame(this.draw.bind(this));\n    } else if (this.playState === PlaybackState.Pause) {\n      // Reset the end time so on playback it starts at the correct frame\n      this.lastRenderTime = 0;\n    } else if (this.playState === PlaybackState.Stop) {\n      // Reset animation instances, artboard and time\n      // TODO: implement this properly when we have instancing\n      this.initArtboard();\n      this.drawFrame();\n      this.lastRenderTime = 0;\n    }\n  }\n\n  // Plays specified animations; if none specified, it plays paused ones.\n  public play(animationNames?: string | string[]): void {\n    animationNames = mapToStringArray(animationNames);\n\n    // If the file's not loaded, queue up the play\n    if (!this.loaded) {\n      this.taskQueue.add({\n        action: () => this.play(animationNames),\n      });\n      return;\n    }\n\n    const playingAnimations = this.playAnimations(animationNames);\n    this.atLeastOneAnimationForPlayback();\n    this.playState = PlaybackState.Play;\n    this.frameRequestId = requestAnimationFrame(this.draw.bind(this));\n    this.eventManager.fire({\n      type: EventType.Play,\n      data: this.playingAnimationNames\n    });\n  }\n\n  // Pauses specified animations; if none specified, pauses all.\n  public pause(animationNames?: string | string[]): void {\n    animationNames = mapToStringArray(animationNames);\n\n    this.pauseAnimations(animationNames);\n    if (!this.hasPlayingAnimations || animationNames.length === 0) {\n      this.playState = PlaybackState.Pause;\n    }\n    this.eventManager.fire({\n      type: EventType.Pause,\n      data: this.pausedAnimationNames,\n    });\n  }\n\n  // Stops specified animations; if none specifies, stops them all.\n  public stop(animationNames?:string | string[] | undefined):void {\n    animationNames = mapToStringArray(animationNames);\n    \n    const stoppedAnimationNames: string[] = animationNames.length === 0 ?\n        this.removeAllAnimations() :\n        this.removeAnimations(animationNames);\n  \n    if (!this.hasPlayingAnimations || animationNames.length === 0) {\n      // Immediately cancel the next frame draw; if we don't do this,\n      // strange things will happen if the Rive file/buffer is\n      // reloaded.\n      cancelAnimationFrame(this.frameRequestId);\n      this.playState = PlaybackState.Stop;\n    }\n    this.eventManager.fire({\n      type: EventType.Stop,\n      data: stoppedAnimationNames,\n    });\n  }\n\n  // Loads a new Rive file, keeping listeners in place\n  public load(params: RiveLoadParameters): void {\n    // Stop all animations\n    this.stop();\n    // Reinitialize\n    this.init(params);\n  }\n\n  // Sets a new layout\n  public set layout(layout: Layout) {\n    this._layout = layout;\n    if(!this.hasPlayingAnimations) {\n      this.drawFrame();\n    }\n  }\n\n  // Returns the animation source, which may be undefined\n  public get source(): string {\n    return this.src;\n  }\n\n  // Returns a list of animation names on the chosen artboard\n  public get animationNames(): string[] {\n    // If the file's not loaded, we got nothing to return\n    if (!this.loaded) {\n      return [];\n    }\n    const animationNames: string[] = [];\n    for (let i = 0; i < this.artboard.animationCount(); i++) {\n      animationNames.push(this.artboard.animationByIndex(i).name);\n    }\n    return animationNames;\n  }\n\n  // Returns a list of playing animation names\n  public get playingAnimationNames(): string[] {\n    // If the file's not loaded, we got nothing to return\n    if (!this.loaded) {\n      return [];\n    }\n    return this.animations\n      .filter(a => !a.paused)\n      .map(a => a.name);\n  }\n\n  // Returns a list of paused animation names\n  public get pausedAnimationNames(): string[] {\n    // If the file's not loaded, we got nothing to return\n    if (!this.loaded) {\n      return [];\n    }\n    return this.animations\n      .filter(a => a.paused)\n      .map(a => a.name);\n  }\n\n  // Returns true if playing\n  public get isPlaying(): boolean {\n    return this.playState === PlaybackState.Play;\n  }\n\n  // Returns trus if all animations are paused\n  public get isPaused(): boolean {\n    return this.playState === PlaybackState.Pause;\n  }\n\n  // Returns true if all animations are stopped\n  public get isStopped(): boolean {\n    return this.playState === PlaybackState.Stop;\n  }\n\n  // Register a new listener\n  public on(type: EventType, callback: EventCallback) {\n    this.eventManager.add({\n      type: type,\n      callback: callback, \n    });\n  }\n\n}\n\n\n// Loads Rive data from a URI via fetch.\nconst loadRiveFile = async (src: string): Promise<ArrayBuffer> => {\n    const req = new Request(src);\n    const res = await fetch(req);\n    const buffer = await res.arrayBuffer();\n    return buffer;\n}\n\n// #endregion\n\n// #region utility functions\n\n/*\n * Utility function to ensure an object is a string array\n */\nlet mapToStringArray = (obj?: string[] | string | undefined): string[] => {\n  if (typeof obj === 'string') {\n    return [obj];\n  } else if (obj instanceof Array) {\n    return obj;\n  }\n  // If obj is undefined, return empty array\n  return [];\n}\n\n// #endregion\n\n// #region exports for testing\n\n// Exports to only be used for tests\nexport const Testing = {\n  EventManager: EventManager,\n  TaskQueueManager: TaskQueueManager,\n} \n\n// #endregion"],"sourceRoot":""}